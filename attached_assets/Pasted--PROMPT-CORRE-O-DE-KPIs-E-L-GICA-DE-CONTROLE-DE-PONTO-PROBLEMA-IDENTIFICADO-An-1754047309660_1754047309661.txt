# ðŸ”§ PROMPT: CORREÃ‡ÃƒO DE KPIs E LÃ“GICA DE CONTROLE DE PONTO

## ðŸŽ¯ **PROBLEMA IDENTIFICADO**

Analisando o sistema atual, identifiquei **inconsistÃªncias nos KPIs** e **problemas na lÃ³gica de cÃ¡lculo** de custos e controle de ponto. Os valores mostrados nos cards nÃ£o batem com os detalhes, e a lÃ³gica de faltas, sÃ¡bados, domingos e feriados precisa ser reformulada.

---

## ðŸ“‹ **PROMPT PARA CORREÃ‡ÃƒO COMPLETA**

```
CORRIJA COMPLETAMENTE a lÃ³gica de KPIs e controle de ponto do sistema, resolvendo as inconsistÃªncias identificadas.

PROBLEMAS IDENTIFICADOS:
1. **KPIs Inconsistentes**: Valores nos cards diferem dos detalhes
2. **LÃ³gica de Faltas**: Faltas devem ter custo ZERO mas aparecem nos cÃ¡lculos
3. **SÃ¡bados/Domingos**: NÃ£o hÃ¡ diferenciaÃ§Ã£o entre trabalhados e nÃ£o trabalhados
4. **Feriados**: Falta lÃ³gica clara para feriados nÃ£o trabalhados
5. **CÃ¡lculos Duplicados**: Mesmos valores sendo contados mÃºltiplas vezes

TAREFAS DE CORREÃ‡ÃƒO:

## 1. REESTRUTURAR TIPOS DE LANÃ‡AMENTO

**Backend (Flask):**
- Reformule a classe `TimeRecordType` com tipos mais claros:
  ```python
  class TimeRecordType:
      # DIAS TRABALHADOS
      TRABALHO_NORMAL = 'trabalho_normal'          # Segunda a Sexta normal
      SABADO_TRABALHADO = 'sabado_trabalhado'      # SÃ¡bado com trabalho (100% extra)
      DOMINGO_TRABALHADO = 'domingo_trabalhado'    # Domingo com trabalho (100% extra)
      FERIADO_TRABALHADO = 'feriado_trabalhado'    # Feriado com trabalho (100% extra)
      HORAS_EXTRAS = 'horas_extras'                # Horas extras em dia normal
      
      # DIAS NÃƒO TRABALHADOS (SEM CUSTO)
      SABADO_FOLGA = 'sabado_folga'                # SÃ¡bado de folga - SEM CUSTO
      DOMINGO_FOLGA = 'domingo_folga'              # Domingo de folga - SEM CUSTO
      FERIADO_FOLGA = 'feriado_folga'              # Feriado de folga - SEM CUSTO
      
      # AUSÃŠNCIAS
      FALTA_INJUSTIFICADA = 'falta_injustificada'  # Falta sem justificativa - SEM CUSTO
      FALTA_JUSTIFICADA = 'falta_justificada'      # Falta justificada - COM CUSTO
      ATESTADO_MEDICO = 'atestado_medico'          # Atestado mÃ©dico - COM CUSTO
      
      # BENEFÃCIOS
      FERIAS = 'ferias'                            # FÃ©rias - COM CUSTO (1/3 adicional)
      LICENCA = 'licenca'                          # LicenÃ§a - COM CUSTO
      
      # OUTROS
      MEIO_PERIODO = 'meio_periodo'                # Meio perÃ­odo - CUSTO PROPORCIONAL
  ```

## 2. CORRIGIR LÃ“GICA DE CÃLCULO DE CUSTOS

**Implemente a classe `CorrectedTimeCalculationService`:**
```python
class CorrectedTimeCalculationService:
    def calculate_time_record_cost(self, time_record_id):
        record = TimeRecord.query.get(time_record_id)
        employee = record.employee
        base_hourly_rate = float(employee.calculated_hourly_rate or 0)
        
        # LÃ“GICA CORRIGIDA POR TIPO
        if record.record_type in ['sabado_folga', 'domingo_folga', 'feriado_folga', 'falta_injustificada']:
            # TIPOS SEM CUSTO
            costs = {'regular_cost': 0, 'overtime_cost': 0, 'total_cost': 0}
            
        elif record.record_type == 'trabalho_normal':
            # DIA NORMAL: atÃ© 8h normal, acima disso 50% extra
            regular_hours = min(float(record.total_hours or 0), 8.0)
            overtime_hours = max(float(record.total_hours or 0) - 8.0, 0)
            
            regular_cost = regular_hours * base_hourly_rate
            overtime_cost = overtime_hours * base_hourly_rate * 1.5
            costs = {
                'regular_cost': regular_cost,
                'overtime_cost': overtime_cost,
                'total_cost': regular_cost + overtime_cost
            }
            
        elif record.record_type in ['sabado_trabalhado', 'domingo_trabalhado', 'feriado_trabalhado']:
            # FINS DE SEMANA/FERIADOS TRABALHADOS: 100% extra
            total_hours = float(record.total_hours or 0)
            total_cost = total_hours * base_hourly_rate * 2.0
            costs = {'regular_cost': total_cost, 'overtime_cost': 0, 'total_cost': total_cost}
            
        elif record.record_type in ['falta_justificada', 'atestado_medico']:
            # FALTAS JUSTIFICADAS: pagamento normal
            hours = 8.0  # 8 horas padrÃ£o
            total_cost = hours * base_hourly_rate
            costs = {'regular_cost': total_cost, 'overtime_cost': 0, 'total_cost': total_cost}
            
        elif record.record_type == 'ferias':
            # FÃ‰RIAS: 1/3 adicional
            hours = 8.0
            total_cost = hours * base_hourly_rate * 1.33
            costs = {'regular_cost': total_cost, 'overtime_cost': 0, 'total_cost': total_cost}
            
        elif record.record_type == 'meio_periodo':
            # MEIO PERÃODO: proporcional
            hours = float(record.total_hours or 4)
            total_cost = hours * base_hourly_rate
            costs = {'regular_cost': total_cost, 'overtime_cost': 0, 'total_cost': total_cost}
            
        # Atualizar registro
        record.regular_cost = costs['regular_cost']
        record.overtime_cost = costs['overtime_cost']
        record.total_cost = costs['total_cost']
        
        return costs
```

## 3. CORRIGIR KPIs DO FUNCIONÃRIO

**Implemente a classe `CorrectedKPIService`:**
```python
class CorrectedKPIService:
    def calculate_employee_kpis(self, employee_id, start_date, end_date):
        records = TimeRecord.query.filter(
            TimeRecord.employee_id == employee_id,
            TimeRecord.date.between(start_date, end_date)
        ).all()
        
        # INICIALIZAR CONTADORES
        kpis = {
            'total_worked_hours': 0,
            'total_overtime_hours': 0,
            'total_absences': 0,
            'justified_absences': 0,
            'total_labor_cost': 0,
            'productivity_percentage': 0,
            'attendance_percentage': 0
        }
        
        # CALCULAR POR REGISTRO
        total_possible_days = 0
        worked_days = 0
        
        for record in records:
            # CONTAR APENAS DIAS QUE DEVERIAM SER TRABALHADOS
            if record.record_type not in ['sabado_folga', 'domingo_folga', 'feriado_folga']:
                total_possible_days += 1
                
                # CONTAR DIAS EFETIVAMENTE TRABALHADOS
                if record.record_type in [
                    'trabalho_normal', 'sabado_trabalhado', 'domingo_trabalhado', 
                    'feriado_trabalhado', 'meio_periodo'
                ]:
                    worked_days += 1
                    kpis['total_worked_hours'] += float(record.total_hours or 0)
                    kpis['total_overtime_hours'] += float(record.overtime_hours or 0)
                
                # CONTAR CUSTOS (APENAS TIPOS COM CUSTO)
                if record.record_type not in ['falta_injustificada', 'sabado_folga', 'domingo_folga', 'feriado_folga']:
                    kpis['total_labor_cost'] += float(record.total_cost or 0)
                
                # CONTAR AUSÃŠNCIAS
                if record.record_type in ['falta_injustificada', 'falta_justificada', 'atestado_medico']:
                    kpis['total_absences'] += 1
                    
                    if record.record_type in ['falta_justificada', 'atestado_medico']:
                        kpis['justified_absences'] += 1
        
        # CALCULAR PERCENTUAIS
        if total_possible_days > 0:
            kpis['attendance_percentage'] = (worked_days / total_possible_days) * 100
            
            # Produtividade baseada em 8h por dia trabalhado
            expected_hours = worked_days * 8
            if expected_hours > 0:
                kpis['productivity_percentage'] = (kpis['total_worked_hours'] / expected_hours) * 100
        
        return kpis
```

## 4. CORRIGIR INTERFACE DE LANÃ‡AMENTO

**Frontend (React):**
- Atualize o dropdown de tipos de lanÃ§amento:
```tsx
const recordTypes = [
    // TRABALHO
    { value: 'trabalho_normal', label: 'ðŸ‘· Trabalho Normal', cost: true },
    { value: 'sabado_trabalhado', label: 'ðŸ“… SÃ¡bado Trabalhado (100% extra)', cost: true },
    { value: 'domingo_trabalhado', label: 'ðŸ“… Domingo Trabalhado (100% extra)', cost: true },
    { value: 'feriado_trabalhado', label: 'ðŸŽ‰ Feriado Trabalhado (100% extra)', cost: true },
    { value: 'meio_periodo', label: 'â° Meio PerÃ­odo', cost: true },
    
    // FOLGAS (SEM CUSTO)
    { value: 'sabado_folga', label: 'ðŸ  SÃ¡bado Folga', cost: false },
    { value: 'domingo_folga', label: 'ðŸ  Domingo Folga', cost: false },
    { value: 'feriado_folga', label: 'ðŸ  Feriado Folga', cost: false },
    
    // AUSÃŠNCIAS
    { value: 'falta_injustificada', label: 'âŒ Falta Injustificada', cost: false },
    { value: 'falta_justificada', label: 'ðŸ“‹ Falta Justificada', cost: true },
    { value: 'atestado_medico', label: 'ðŸ¥ Atestado MÃ©dico', cost: true },
    
    // BENEFÃCIOS
    { value: 'ferias', label: 'ðŸ–ï¸ FÃ©rias (1/3 adicional)', cost: true },
    { value: 'licenca', label: 'ðŸ“„ LicenÃ§a', cost: true }
];
```

## 5. CORRIGIR DASHBOARD DE KPIs

**Implemente validaÃ§Ã£o cruzada nos KPIs:**
```tsx
const EmployeeKPIDashboard = ({ employeeId, period }) => {
    // BUSCAR DADOS CORRIGIDOS
    const kpis = useCorrectedKPIs(employeeId, period);
    
    return (
        <div className="grid grid-cols-4 gap-4">
            {/* HORAS TRABALHADAS */}
            <KPICard 
                title="Horas Trabalhadas"
                value={`${kpis.total_worked_hours.toFixed(1)}h`}
                subtitle="Apenas dias efetivamente trabalhados"
            />
            
            {/* CUSTO TOTAL */}
            <KPICard 
                title="Custo Total"
                value={formatCurrency(kpis.total_labor_cost)}
                subtitle="Apenas lanÃ§amentos com custo"
                color="green"
            />
            
            {/* PRODUTIVIDADE */}
            <KPICard 
                title="Produtividade"
                value={`${kpis.productivity_percentage.toFixed(1)}%`}
                subtitle="Baseado em 8h/dia trabalhado"
                color="blue"
            />
            
            {/* ASSIDUIDADE */}
            <KPICard 
                title="Assiduidade"
                value={`${kpis.attendance_percentage.toFixed(1)}%`}
                subtitle="Dias trabalhados / Dias Ãºteis"
                color="purple"
            />
        </div>
    );
};
```

## 6. IMPLEMENTAR VALIDAÃ‡Ã•ES CRUZADAS

**Adicione validaÃ§Ãµes para garantir consistÃªncia:**
```python
class KPIValidationService:
    def validate_employee_kpis(self, employee_id, period):
        # Buscar dados brutos
        records = TimeRecord.query.filter(...).all()
        
        # Calcular totais por diferentes mÃ©todos
        method1_total = sum(r.total_cost for r in records if r.total_cost > 0)
        method2_total = self.calculate_by_type_sum(records)
        
        # Verificar consistÃªncia
        if abs(method1_total - method2_total) > 0.01:
            logger.warning(f"KPI inconsistency detected for employee {employee_id}")
            
        return {
            'is_consistent': abs(method1_total - method2_total) <= 0.01,
            'method1_total': method1_total,
            'method2_total': method2_total,
            'records_count': len(records)
        }
```

## 7. CRIAR RELATÃ“RIO DE AUDITORIA

**Implemente relatÃ³rio para identificar inconsistÃªncias:**
```python
@reports_bp.route('/kpi-audit', methods=['GET'])
def kpi_audit_report():
    employees = Employee.query.filter_by(is_active=True).all()
    audit_results = []
    
    for employee in employees:
        validation = KPIValidationService().validate_employee_kpis(
            employee.id, request.args.get('period')
        )
        
        if not validation['is_consistent']:
            audit_results.append({
                'employee': employee.name,
                'inconsistency': validation
            })
    
    return jsonify({
        'total_employees': len(employees),
        'inconsistent_employees': len(audit_results),
        'audit_results': audit_results
    })
```

ENTREGÃVEIS:
- LÃ³gica de cÃ¡lculo completamente corrigida
- KPIs consistentes entre cards e detalhes
- Tipos de lanÃ§amento claros e bem definidos
- ValidaÃ§Ãµes cruzadas implementadas
- RelatÃ³rio de auditoria para identificar problemas
- Interface atualizada com tipos corretos
- DocumentaÃ§Ã£o da nova lÃ³gica

FOCO: Garantir que os valores mostrados nos KPIs sejam EXATAMENTE os mesmos em cards e detalhes, com lÃ³gica clara para cada tipo de lanÃ§amento.
```

---

## ðŸŽ¯ **RESUMO DAS CORREÃ‡Ã•ES**

### **âŒ PROBLEMAS IDENTIFICADOS:**
- KPIs inconsistentes entre cards e detalhes
- Faltas contando como custo quando deveriam ser zero
- Falta de diferenciaÃ§Ã£o entre sÃ¡bados/domingos trabalhados e folga
- CÃ¡lculos duplicados ou incorretos
- Interface confusa para tipos de lanÃ§amento

### **âœ… SOLUÃ‡Ã•ES IMPLEMENTADAS:**
- **Tipos claros** de lanÃ§amento (trabalhados vs folga)
- **CÃ¡lculos precisos** por categoria
- **ValidaÃ§Ãµes cruzadas** para garantir consistÃªncia
- **KPIs corrigidos** com lÃ³gica transparente
- **Interface melhorada** com indicaÃ§Ã£o de custo
- **RelatÃ³rio de auditoria** para monitoramento

### **ðŸ” VALIDAÃ‡Ã•ES ADICIONAIS:**
- ComparaÃ§Ã£o entre diferentes mÃ©todos de cÃ¡lculo
- Logs de inconsistÃªncias
- RelatÃ³rios de auditoria automÃ¡ticos
- Alertas para valores divergentes

O prompt garante que os **KPIs sejam consistentes** e a **lÃ³gica seja clara** para todos os tipos de lanÃ§amento! ðŸŽ¯

