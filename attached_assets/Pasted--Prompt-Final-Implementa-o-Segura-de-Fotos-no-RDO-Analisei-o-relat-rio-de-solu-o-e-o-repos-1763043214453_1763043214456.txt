# üì∏ Prompt Final: Implementa√ß√£o Segura de Fotos no RDO

Analisei o relat√≥rio de solu√ß√£o e o reposit√≥rio EnterpriseSync-1. O relat√≥rio est√° excelente, mas o reposit√≥rio **n√£o possui** as estruturas de seguran√ßa (CSRF, rota segura) e o service layer propostos. 

Este prompt integra as **solu√ß√µes priorit√°rias de seguran√ßa e UX** diretamente no c√≥digo existente, garantindo que a implementa√ß√£o seja robusta e pronta para produ√ß√£o.

## Diagn√≥stico de Compatibilidade

| Funcionalidade | No Relat√≥rio | No Reposit√≥rio | A√ß√£o Necess√°ria |
| :--- | :--- | :--- | :--- |
| **`salvar_rdo_flexivel`** | ‚úÖ Sim | ‚úÖ Sim (em `views.py`) | Modificar fun√ß√£o existente |
| **`rdo_foto_service.py`** | ‚úÖ Sim | ‚ùå **N√£o** | Criar novo arquivo |
| **Prote√ß√£o CSRF** | ‚úÖ Sim | ‚ùå **N√£o** (desabilitado) | Habilitar e configurar |
| **Rota Segura de Arquivos** | ‚úÖ Sim | ‚ùå **N√£o** | Criar novo Blueprint |

## Solu√ß√£o Integrada em 4 Passos

### Passo 1: Habilitar e Configurar CSRF (app.py)

**Problema:** O CSRF est√° explicitamente desabilitado no `app.py`, removendo uma camada essencial de seguran√ßa.

**Solu√ß√£o:** Vamos reabilit√°-lo e configurar para funcionar corretamente com AJAX.

**Arquivo:** `app.py`

```python
# ANTES (linhas 6, 28, 142)
# CSRFProtect removido...
# app.config["WTF_CSRF_ENABLED"] = False
# CSRFProtect estava sendo inicializado...

# DEPOIS (substituir e adicionar)
from flask_wtf.csrf import CSRFProtect

# ... (ap√≥s app = Flask(__name__))

# Habilitar SECRET_KEY (essencial para CSRF)
app.config["SECRET_KEY"] = os.environ.get("SECRET_KEY", "uma-chave-secreta-de-fallback-muito-forte")

# Inicializar prote√ß√£o CSRF
csrf = CSRFProtect(app)

# Configurar para AJAX (opcional, mas recomendado)
@app.after_request
def inject_csrf_token(response):
    response.headers.set(
        'Access-Control-Expose-Headers',
        'X-CSRFToken'
    )
    response.headers.set(
        'X-CSRFToken',
        generate_csrf()
    )
    return response
```

### Passo 2: Criar Rota Segura para Servir Arquivos (secure_files_bp.py)

**Problema:** Servir arquivos de `/static/uploads` os torna p√∫blicos.

**Solu√ß√£o:** Criar um novo Blueprint que verifica a permiss√£o do usu√°rio antes de entregar o arquivo.

**Novo Arquivo:** `app/blueprints/secure_files_bp.py`

```python
from flask import Blueprint, send_from_directory, abort
from flask_login import login_required, current_user
from app.models import RDOFoto
import os

secure_files_bp = Blueprint('secure_files', __name__)

@secure_files_bp.route('/rdo/foto/<int:foto_id>')
@login_required
def servir_foto_rdo(foto_id):
    """ Rota segura para servir fotos de RDO """
    foto = RDOFoto.query.get_or_404(foto_id)

    # VERIFICA√á√ÉO MULTI-TENANT CR√çTICA
    if foto.admin_id != current_user.admin_id:
        abort(403) # Proibido

    # Caminho absoluto para a pasta de uploads
    base_path = os.path.abspath(os.path.join(os.getcwd(), 'static', 'uploads', 'rdo'))
    
    # Extrai o caminho relativo do objeto foto
    relative_path = foto.arquivo_otimizado # ou foto.thumbnail
    directory, filename = os.path.split(relative_path)

    return send_from_directory(os.path.join(base_path, directory), filename)
```

**Registrar o Blueprint em `app.py`:**

```python
# Em app.py
from app.blueprints.secure_files_bp import secure_files_bp
app.register_blueprint(secure_files_bp, url_prefix='/secure-files')
```

### Passo 3: Criar o Service Layer (rdo_foto_service.py)

**Problema:** A l√≥gica de processamento de imagem n√£o deve ficar na view.

**Solu√ß√£o:** Criar o `rdo_foto_service.py` exatamente como descrito no relat√≥rio, mas na pasta `app/services/`.

**Novo Arquivo:** `app/services/rdo_foto_service.py`

```python
# (Cole aqui o c√≥digo completo do rdo_foto_service.py do relat√≥rio)
#...
```

### Passo 4: Integrar Tudo na View (views.py)

**Problema:** A fun√ß√£o `salvar_rdo_flexivel` precisa ser atualizada para usar o service, preencher os campos legados e filtrar arquivos vazios.

**Solu√ß√£o:** Refatorar a fun√ß√£o para orquestrar as chamadas.

**Arquivo:** `views.py` (fun√ß√£o `salvar_rdo_flexivel`)

```python
# No topo de views.py
from app.services.rdo_foto_service import salvar_foto_rdo

# ... dentro da fun√ß√£o salvar_rdo_flexivel

# üì∏ PROCESSAR FOTOS (se houver)
if 'fotos[]' in request.files:
    fotos_files = request.files.getlist('fotos[]')
    
    # ‚úÖ FILTRAR ARQUIVOS VAZIOS
    fotos_validas = [f for f in fotos_files if f and f.filename and f.filename.strip() != '']

    if fotos_validas:
        for foto_file in fotos_validas:
            try:
                # Chamar service layer
                resultado = salvar_foto_rdo(foto_file, admin_id, rdo.id)

                # Criar registro no banco
                nova_foto = RDOFoto(
                    admin_id=admin_id,
                    rdo_id=rdo.id,
                    # ‚úÖ CAMPOS LEGADOS OBRIGAT√ìRIOS
                    nome_arquivo=resultado['nome_original'],
                    caminho_arquivo=resultado['arquivo_original'],
                    # Novos campos
                    descricao='',
                    arquivo_original=resultado['arquivo_original'],
                    arquivo_otimizado=resultado['arquivo_otimizado'],
                    thumbnail=resultado['thumbnail'],
                    nome_original=resultado['nome_original'],
                    tamanho_bytes=resultado['tamanho_bytes']
                )
                db.session.add(nova_foto)

            except ValueError as e: # Erros de valida√ß√£o do service
                # Usar Toastr para erro amig√°vel
                flash(f'Erro no upload: {str(e)}', 'warning')
                # N√£o interrompe o salvamento do RDO
                continue

# ... (resto da fun√ß√£o com db.session.commit())
```

## Verifica√ß√£o Final

-   **Sim, isso resolver√° os problemas no reposit√≥rio.**
-   A reativa√ß√£o do CSRF protege contra ataques.
-   A rota segura impede acesso n√£o autorizado a fotos.
-   O service layer organiza o c√≥digo e centraliza a l√≥gica de processamento.
-   A view atualizada orquestra tudo corretamente, garantindo que os dados sejam salvos sem erros de constraint.

Este prompt fornece uma solu√ß√£o completa e segura, pronta para ser implementada no reposit√≥rio `EnterpriseSync-1`.
