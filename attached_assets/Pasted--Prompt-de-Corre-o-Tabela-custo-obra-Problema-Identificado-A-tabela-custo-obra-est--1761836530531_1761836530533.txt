# Prompt de Corre√ß√£o: Tabela `custo_obra`

## Problema Identificado

A tabela `custo_obra` est√° causando erro no **Dashboard de Custos** devido √† coluna `admin_id` estar ausente ou com valores NULL.

---

## Erro em Produ√ß√£o

### Origem do Erro

**Arquivo:** `/app/custos_views.py`, linha 57  
**Fun√ß√£o:** `dashboard_custos`  
**C√≥digo:**
```python
total_custos = query_base.with_entities(func.sum(CustoObra.valor)).scalar() or 0
```

### SQL que Falha

```sql
SELECT sum(custo_obra.valor) AS sum_1 
FROM custo_obra 
WHERE custo_obra.admin_id = 2
```

### Mensagem de Erro

```
psycopg2.errors.UndefinedColumn: column custo_obra.admin_id does not exist
LINE 3: WHERE custo_obra.admin_id = 2
              ^
```

### Impacto

‚ùå **Dashboard de custos completamente quebrado**  
‚ùå **Imposs√≠vel visualizar totais de custos**  
‚ùå **Relat√≥rios financeiros n√£o funcionam**  
‚ùå **An√°lise de custos por obra indispon√≠vel**

---

## An√°lise do Modelo

### Modelo SQLAlchemy (models.py linha 426-446)

```python
class CustoObra(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    obra_id = db.Column(db.Integer, db.ForeignKey('obra.id'), nullable=False)
    centro_custo_id = db.Column(db.Integer, db.ForeignKey('centro_custo.id'))
    tipo = db.Column(db.String(20), nullable=False)
    descricao = db.Column(db.String(200), nullable=False)
    valor = db.Column(db.Float, nullable=False)
    data = db.Column(db.Date, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Campos adicionados pela Migra√ß√£o 43
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    item_almoxarifado_id = db.Column(db.Integer, db.ForeignKey('almoxarifado_item.id'))
    veiculo_id = db.Column(db.Integer, db.ForeignKey('frota_veiculo.id'))
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))  # ‚úÖ DEFINIDO
    quantidade = db.Column(db.Numeric(10, 2), default=1)
    valor_unitario = db.Column(db.Numeric(10, 2), default=0)
    horas_trabalhadas = db.Column(db.Numeric(5, 2))
    horas_extras = db.Column(db.Numeric(5, 2))
    rdo_id = db.Column(db.Integer, db.ForeignKey('rdo.id'))
    categoria = db.Column(db.String(50))
```

**Observa√ß√£o:** O modelo define `admin_id` com foreign key para `usuario.id`.

---

## Dados Atuais no Banco

### Estat√≠sticas

- **Total de registros:** 622 custos
- **Per√≠odo:** 30/06/2025 a 29/07/2025
- **Obras afetadas:** 1, 2, 3, 5
- **Tipos de custo:**
  - `alimentacao` - Custos de alimenta√ß√£o de funcion√°rios
  - `veiculo` - Custos de combust√≠vel e manuten√ß√£o de ve√≠culos

### Exemplos de Registros

```json
{
  "id": 1,
  "obra_id": 1,
  "centro_custo_id": null,
  "tipo": "alimentacao",
  "descricao": "Alimenta√ß√£o - almoco - Frank Reinaldo Aguilar Pina",
  "valor": 18,
  "data": "2025-06-30",
  "created_at": "2025-07-28 11:54:09.956557"
  // ‚ùå SEM admin_id ou admin_id NULL
}

{
  "id": 622,
  "obra_id": 3,
  "centro_custo_id": null,
  "tipo": "veiculo",
  "descricao": "Ve√≠culo EEG1F21 - Combustivel: Sem descri√ß√£o",
  "valor": 218.96,
  "data": "2025-07-29",
  "created_at": "2025-08-06 14:07:06.539143"
  // ‚ùå SEM admin_id ou admin_id NULL
}
```

---

## Situa√ß√£o Prov√°vel

A tabela `custo_obra` pode estar em uma das seguintes situa√ß√µes:

### Situa√ß√£o 1: Coluna n√£o existe
- Migration 43 n√£o foi executada
- Coluna `admin_id` n√£o foi criada

### Situa√ß√£o 2: Coluna existe mas est√° NULL
- Migration 43 foi executada parcialmente
- Coluna foi criada mas backfill n√£o funcionou
- Todos os 622 registros t√™m `admin_id = NULL`

---

## Solu√ß√£o: Script SQL Completo

### Caracter√≠sticas do Script

‚úÖ **Inteligente** - Detecta se coluna existe ou n√£o  
‚úÖ **Idempotente** - Pode ser executado m√∫ltiplas vezes  
‚úÖ **Seguro** - Usa transa√ß√µes e trata √≥rf√£os  
‚úÖ **Completo** - Coluna + backfill + constraints + FK + √≠ndice  
‚úÖ **Informativo** - Logs detalhados de cada passo

### Estrat√©gia de Backfill

```sql
-- Buscar admin_id via relacionamento com obra
UPDATE custo_obra co
SET admin_id = o.admin_id
FROM obra o
WHERE co.obra_id = o.id
  AND co.admin_id IS NULL
  AND o.admin_id IS NOT NULL
```

**L√≥gica:**
- Cada `custo_obra` tem uma `obra_id`
- Cada `obra` tem um `admin_id`
- Propagar `admin_id` da obra para o custo

---

## Script SQL: `fix_custo_obra.sql`

```sql
-- ============================================================================
-- FIX: custo_obra.admin_id
-- ============================================================================

BEGIN;

DO $$
DECLARE
    v_admin_id INTEGER := 2; -- Admin padr√£o
    v_orfaos INTEGER;
    v_atualizados INTEGER;
    v_coluna_existe BOOLEAN;
BEGIN
    -- Verificar se coluna j√° existe
    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'custo_obra' AND column_name = 'admin_id'
    ) INTO v_coluna_existe;
    
    IF NOT v_coluna_existe THEN
        RAISE NOTICE 'üîÑ Adicionando coluna admin_id na tabela custo_obra...';
        
        -- PASSO 1: Adicionar coluna
        ALTER TABLE custo_obra ADD COLUMN admin_id INTEGER;
        RAISE NOTICE '   ‚úÖ Coluna adicionada';
    ELSE
        RAISE NOTICE '‚è≠Ô∏è  Coluna admin_id j√° existe - verificando valores NULL...';
    END IF;
    
    -- PASSO 2: Backfill via obra_id
    RAISE NOTICE 'üîÑ Backfill via obra.admin_id...';
    
    UPDATE custo_obra co
    SET admin_id = o.admin_id
    FROM obra o
    WHERE co.obra_id = o.id
      AND co.admin_id IS NULL
      AND o.admin_id IS NOT NULL;
    
    GET DIAGNOSTICS v_atualizados = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ % registros atualizados via obra', v_atualizados;
    
    -- PASSO 3: Verificar registros √≥rf√£os
    SELECT COUNT(*) INTO v_orfaos 
    FROM custo_obra 
    WHERE admin_id IS NULL;
    
    IF v_orfaos > 0 THEN
        RAISE NOTICE '   ‚ö†Ô∏è  % custos sem admin_id', v_orfaos;
        RAISE NOTICE '   üîß Aplicando admin_id padr√£o (%)', v_admin_id;
        
        UPDATE custo_obra 
        SET admin_id = v_admin_id 
        WHERE admin_id IS NULL;
        
        RAISE NOTICE '   ‚úÖ Registros √≥rf√£os corrigidos';
    ELSE
        RAISE NOTICE '   ‚úÖ Nenhum registro √≥rf√£o';
    END IF;
    
    -- PASSO 4: Aplicar NOT NULL (se ainda n√£o estiver)
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'custo_obra' 
          AND column_name = 'admin_id' 
          AND is_nullable = 'NO'
    ) THEN
        RAISE NOTICE 'üîí Aplicando constraint NOT NULL...';
        ALTER TABLE custo_obra ALTER COLUMN admin_id SET NOT NULL;
        RAISE NOTICE '   ‚úÖ Constraint aplicada';
    END IF;
    
    -- PASSO 5: Adicionar foreign key (se n√£o existir)
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE table_name = 'custo_obra' 
          AND constraint_name = 'fk_custo_obra_admin_id'
    ) THEN
        RAISE NOTICE 'üîó Adicionando foreign key...';
        ALTER TABLE custo_obra
        ADD CONSTRAINT fk_custo_obra_admin_id
        FOREIGN KEY (admin_id) REFERENCES usuario(id) ON DELETE CASCADE;
        RAISE NOTICE '   ‚úÖ Foreign key criada';
    END IF;
    
    -- PASSO 6: Criar √≠ndice (se n√£o existir)
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes 
        WHERE tablename = 'custo_obra' 
          AND indexname = 'idx_custo_obra_admin_id'
    ) THEN
        RAISE NOTICE '‚ö° Criando √≠ndice...';
        CREATE INDEX idx_custo_obra_admin_id ON custo_obra(admin_id);
        RAISE NOTICE '   ‚úÖ √çndice criado';
    END IF;
    
    RAISE NOTICE '';
    RAISE NOTICE '‚úÖ custo_obra CORRIGIDA COM SUCESSO!';
    
END $$;

COMMIT;

-- ============================================================================
-- VALIDA√á√ÉO
-- ============================================================================

SELECT 
    'custo_obra' as tabela,
    COUNT(*) as total,
    COUNT(admin_id) as com_admin_id,
    COUNT(*) - COUNT(admin_id) as sem_admin_id,
    COUNT(DISTINCT admin_id) as admins_distintos
FROM custo_obra;

-- Distribui√ß√£o por admin
SELECT 
    admin_id,
    COUNT(*) as quantidade,
    SUM(valor) as valor_total,
    MIN(data) as data_inicio,
    MAX(data) as data_fim
FROM custo_obra
GROUP BY admin_id
ORDER BY admin_id;

-- Distribui√ß√£o por tipo
SELECT 
    tipo,
    COUNT(*) as quantidade,
    SUM(valor) as valor_total
FROM custo_obra
GROUP BY tipo
ORDER BY tipo;
```

---

## Como Executar

### Op√ß√£o 1: Via psql (Recomendado)

```bash
psql -U usuario -d nome_banco -f fix_custo_obra.sql
```

### Op√ß√£o 2: Via pgAdmin ou DBeaver

1. Abrir o arquivo `fix_custo_obra.sql`
2. Copiar todo o conte√∫do
3. Colar na janela de query
4. Executar

### Op√ß√£o 3: Via Python (Flask Shell)

```python
from app import app, db

with app.app_context():
    with open('fix_custo_obra.sql', 'r') as f:
        sql = f.read()
    
    connection = db.engine.raw_connection()
    cursor = connection.cursor()
    
    cursor.execute(sql)
    connection.commit()
    
    cursor.close()
    connection.close()
    
    print("‚úÖ Script executado com sucesso!")
```

---

## Resultado Esperado

### Sa√≠da do Script

```
üîÑ Adicionando coluna admin_id na tabela custo_obra...
   ‚úÖ Coluna adicionada
üîÑ Backfill via obra.admin_id...
   ‚úÖ 622 registros atualizados via obra
   ‚úÖ Nenhum registro √≥rf√£o
üîí Aplicando constraint NOT NULL...
   ‚úÖ Constraint aplicada
üîó Adicionando foreign key...
   ‚úÖ Foreign key criada
‚ö° Criando √≠ndice...
   ‚úÖ √çndice criado

‚úÖ custo_obra CORRIGIDA COM SUCESSO!

  tabela   | total | com_admin_id | sem_admin_id | admins_distintos
-----------+-------+--------------+--------------+------------------
 custo_obra|   622 |          622 |            0 |                1

 admin_id | quantidade | valor_total | data_inicio | data_fim
----------+------------+-------------+-------------+------------
        2 |        622 |    15234.56 | 2025-06-30  | 2025-07-29

    tipo     | quantidade | valor_total
-------------+------------+-------------
 alimentacao |        450 |     8100.00
 veiculo     |        172 |     7134.56
```

---

## Valida√ß√£o P√≥s-Execu√ß√£o

### 1. Verificar Estrutura da Tabela

```sql
SELECT 
    column_name, 
    data_type, 
    is_nullable
FROM information_schema.columns 
WHERE table_name = 'custo_obra' 
ORDER BY ordinal_position;
```

**Resultado esperado:**
```
     column_name       | data_type | is_nullable
-----------------------+-----------+-------------
 id                    | integer   | NO
 obra_id               | integer   | NO
 centro_custo_id       | integer   | YES
 tipo                  | varchar   | NO
 descricao             | varchar   | NO
 valor                 | double    | NO
 data                  | date      | NO
 created_at            | timestamp | YES
 funcionario_id        | integer   | YES
 item_almoxarifado_id  | integer   | YES
 veiculo_id            | integer   | YES
 admin_id              | integer   | NO  ‚úÖ
 quantidade            | numeric   | YES
 valor_unitario        | numeric   | YES
 horas_trabalhadas     | numeric   | YES
 horas_extras          | numeric   | YES
 rdo_id                | integer   | YES
 categoria             | varchar   | YES
```

### 2. Verificar Constraints

```sql
SELECT 
    constraint_name,
    constraint_type
FROM information_schema.table_constraints
WHERE table_name = 'custo_obra'
ORDER BY constraint_type, constraint_name;
```

**Resultado esperado:**
```
      constraint_name       | constraint_type
----------------------------+-----------------
 fk_custo_obra_admin_id     | FOREIGN KEY  ‚úÖ
 fk_custo_obra_obra_id      | FOREIGN KEY
 custo_obra_pkey            | PRIMARY KEY
```

### 3. Testar Query que Estava Falhando

```sql
-- Query do dashboard de custos
SELECT SUM(valor) 
FROM custo_obra 
WHERE admin_id = 2;
```

**Resultado esperado:**
```
   sum    
----------
 15234.56
```

‚úÖ **Query funciona!**

### 4. Testar Agrega√ß√µes por Tipo

```sql
SELECT 
    tipo,
    COUNT(*) as quantidade,
    SUM(valor) as total,
    AVG(valor) as media
FROM custo_obra
WHERE admin_id = 2
GROUP BY tipo
ORDER BY total DESC;
```

**Resultado esperado:**
```
    tipo     | quantidade |  total  | media
-------------+------------+---------+-------
 alimentacao |        450 | 8100.00 | 18.00
 veiculo     |        172 | 7134.56 | 41.48
```

---

## Testes Funcionais

Ap√≥s executar o script, testar:

### ‚úÖ Teste 1: Dashboard de Custos

1. Acessar `/custos/dashboard`
2. Verificar que a p√°gina carrega sem erros
3. Verificar que o total de custos √© exibido
4. Verificar gr√°ficos e estat√≠sticas

### ‚úÖ Teste 2: Filtros de Custos

1. Filtrar custos por obra
2. Filtrar custos por tipo
3. Filtrar custos por per√≠odo
4. Verificar que todos os filtros funcionam

### ‚úÖ Teste 3: Relat√≥rios de Custos

1. Gerar relat√≥rio de custos por obra
2. Gerar relat√≥rio de custos por tipo
3. Exportar relat√≥rio em PDF/Excel
4. Verificar que dados est√£o corretos

### ‚úÖ Teste 4: Criar Novo Custo

1. Acessar p√°gina de cadastro de custo
2. Preencher dados e salvar
3. Verificar que `admin_id` √© preenchido automaticamente
4. Verificar que custo aparece no dashboard

---

## Troubleshooting

### Problema: Erro "column already exists"

**Causa:** Coluna j√° existe mas est√° com valores NULL

**Solu√ß√£o:**
- ‚úÖ O script detecta isso automaticamente
- Pula a cria√ß√£o da coluna
- Faz apenas o backfill dos valores NULL

### Problema: Erro "violates not-null constraint"

**Causa:** H√° registros √≥rf√£os que n√£o conseguiram ser preenchidos via backfill

**Solu√ß√£o:**
```sql
-- Verificar registros √≥rf√£os
SELECT * FROM custo_obra WHERE admin_id IS NULL;

-- Aplicar admin_id padr√£o manualmente
UPDATE custo_obra SET admin_id = 2 WHERE admin_id IS NULL;
```

### Problema: Erro "violates foreign key constraint"

**Causa:** O admin_id padr√£o (2) n√£o existe na tabela `usuario`

**Solu√ß√£o:**
```sql
-- Verificar admins dispon√≠veis
SELECT id, email, tipo_usuario FROM usuario WHERE tipo_usuario = 'admin';

-- Usar um admin_id v√°lido
UPDATE custo_obra SET admin_id = <id_valido> WHERE admin_id IS NULL;
```

### Problema: Dashboard ainda n√£o funciona

**Causa:** Cache do SQLAlchemy ou sess√£o n√£o atualizada

**Solu√ß√£o:**
```bash
# Reiniciar aplica√ß√£o Flask
sudo systemctl restart nome_servico

# Ou limpar cache
flask shell
>>> from app import db
>>> db.session.remove()
>>> exit()
```

---

## Resumo

### Problema
- Tabela `custo_obra` sem `admin_id` ou com valores NULL
- Dashboard de custos completamente quebrado
- 622 registros afetados

### Solu√ß√£o
- Script SQL inteligente: `fix_custo_obra.sql`
- Detecta situa√ß√£o (coluna existe ou n√£o)
- Backfill via relacionamento com `obra`
- Trata registros √≥rf√£os automaticamente

### Execu√ß√£o
```bash
psql -U usuario -d nome_banco -f fix_custo_obra.sql
```

### Valida√ß√£o
- Verificar estrutura da tabela
- Testar queries de agrega√ß√£o
- Testar dashboard de custos
- Criar novo custo de teste

### Resultado
‚úÖ **Dashboard de custos funcionando**  
‚úÖ **Todos os 622 registros com admin_id**  
‚úÖ **Relat√≥rios financeiros operacionais**  
‚úÖ **Sistema multi-tenant preservado**

---

## Resumo de Todas as Tabelas com Problema

At√© agora foram identificadas **6 tabelas** sem `admin_id`:

| # | Tabela | Status | Script |
|---|--------|--------|--------|
| 1 | `funcao` | ‚ùå | `fix_funcao.sql` |
| 2 | `rdo_mao_obra` | ‚ùå | `fix_rdo_mao_obra.sql` |
| 3 | `registro_alimentacao` | ‚ùå | `fix_registro_alimentacao.sql` |
| 4 | `departamento` | ‚ùå | `fix_departamento.sql` |
| 5 | `horario_trabalho` | ‚ùå | `fix_horario_trabalho.sql` |
| 6 | **`custo_obra`** | ‚ùå | **`fix_custo_obra.sql`** ‚¨ÜÔ∏è |

### Ordem de Execu√ß√£o Recomendada

```bash
# 1. Tabelas base
psql -U usuario -d nome_banco -f fix_departamento.sql
psql -U usuario -d nome_banco -f fix_horario_trabalho.sql
psql -U usuario -d nome_banco -f fix_funcao.sql

# 2. Tabelas relacionadas a obras e custos
psql -U usuario -d nome_banco -f fix_custo_obra.sql
psql -U usuario -d nome_banco -f fix_rdo_mao_obra.sql
psql -U usuario -d nome_banco -f fix_registro_alimentacao.sql
```

---

## Conclus√£o

Com este script, o **dashboard de custos voltar√° a funcionar** e todos os **622 registros** de custos ter√£o `admin_id` corretamente preenchido, preservando o isolamento multi-tenant do sistema.
