# üéØ PROMPT: Melhorar Precis√£o do Reconhecimento Facial

## ‚ùå Problema Atual

O sistema est√° confundindo pessoas diferentes, especialmente quem usa √≥culos. Pessoas distintas est√£o sendo identificadas como a mesma pessoa.

## ‚úÖ Solu√ß√£o

Implementar melhorias no sistema de reconhecimento facial:
1. Ajustar threshold de confian√ßa (mais rigoroso)
2. Melhorar qualidade das fotos de cadastro
3. Permitir m√∫ltiplas fotos por funcion√°rio
4. Validar contra todas as fotos cadastradas

---

## üìã FASE 1: Modificar o Modelo para M√∫ltiplas Fotos

No arquivo `models.py`, modifique a classe `Funcionario`:

```python
class Funcionario(db.Model):
    # ... campos existentes ...
    
    # MODIFICAR: Tornar foto_facial_base64 opcional (ser√° substitu√≠do por m√∫ltiplas fotos)
    foto_facial_base64 = db.Column(db.Text, nullable=True)  # Manter por compatibilidade
    
    # ADICIONAR: Relacionamento com m√∫ltiplas fotos
    fotos_faciais = db.relationship('FotoFacialFuncionario', backref='funcionario', lazy=True, cascade='all, delete-orphan')
```

**Criar novo modelo para m√∫ltiplas fotos:**

```python
class FotoFacialFuncionario(db.Model):
    """Modelo para armazenar m√∫ltiplas fotos faciais de cada funcion√°rio"""
    __tablename__ = 'foto_facial_funcionario'
    
    id = db.Column(db.Integer, primary_key=True)
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'), nullable=False)
    foto_base64 = db.Column(db.Text, nullable=False)
    descricao = db.Column(db.String(100))  # Ex: "Com √≥culos", "Sem √≥culos", "Perfil esquerdo"
    ordem = db.Column(db.Integer, default=1)  # Ordem de prioridade
    ativa = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    admin_id = db.Column(db.Integer, db.ForeignKey('admin.id'), nullable=False)
    
    def __repr__(self):
        return f'<FotoFacial {self.funcionario_id} - {self.descricao}>'
```

---

## üìã FASE 2: Criar Migra√ß√£o para Nova Tabela

Crie um arquivo `migrate_multiplas_fotos.py`:

```python
"""
Migra√ß√£o: Criar tabela para m√∫ltiplas fotos faciais
"""
from app import app, db

@app.cli.command('migrate-multiplas-fotos')
def migrate_multiplas_fotos():
    """Cria a tabela foto_facial_funcionario"""
    
    print("=" * 60)
    print("CRIANDO TABELA DE M√öLTIPLAS FOTOS FACIAIS")
    print("=" * 60)
    
    try:
        connection = db.engine.raw_connection()
        cursor = connection.cursor()
        
        # Verificar se a tabela j√° existe
        cursor.execute("""
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'foto_facial_funcionario'
            )
        """)
        
        exists = cursor.fetchone()[0]
        
        if not exists:
            print("\n‚Üí Criando tabela foto_facial_funcionario...")
            
            cursor.execute("""
                CREATE TABLE foto_facial_funcionario (
                    id SERIAL PRIMARY KEY,
                    funcionario_id INTEGER NOT NULL REFERENCES funcionario(id) ON DELETE CASCADE,
                    foto_base64 TEXT NOT NULL,
                    descricao VARCHAR(100),
                    ordem INTEGER DEFAULT 1,
                    ativa BOOLEAN DEFAULT TRUE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    admin_id INTEGER NOT NULL REFERENCES admin(id)
                )
            """)
            
            print("‚úÖ Tabela criada com sucesso!")
            
            # Migrar fotos existentes
            print("\n‚Üí Migrando fotos existentes...")
            cursor.execute("""
                INSERT INTO foto_facial_funcionario (funcionario_id, foto_base64, descricao, ordem, admin_id)
                SELECT id, foto_facial_base64, 'Foto principal', 1, admin_id
                FROM funcionario
                WHERE foto_facial_base64 IS NOT NULL
            """)
            
            rows_migrated = cursor.rowcount
            print(f"‚úÖ {rows_migrated} fotos migradas com sucesso!")
            
        else:
            print("‚ö†Ô∏è  Tabela foto_facial_funcionario j√° existe, pulando...")
        
        connection.commit()
        
        print("\n" + "=" * 60)
        print("‚úÖ MIGRA√á√ÉO CONCLU√çDA!")
        print("=" * 60)
        
    except Exception as e:
        connection.rollback()
        print(f"\n‚ùå ERRO: {e}")
        raise
    
    finally:
        cursor.close()
        connection.close()

if __name__ == '__main__':
    with app.app_context():
        migrate_multiplas_fotos()
```

---

## üìã FASE 3: Ajustar Threshold e Melhorar Valida√ß√£o

Modifique o arquivo que faz o reconhecimento facial (provavelmente em `views.py` ou arquivo espec√≠fico):

**Localize a fun√ß√£o de reconhecimento e ajuste:**

```python
from deepface import DeepFace
import numpy as np

# CONFIGURA√á√ïES DE RECONHECIMENTO FACIAL
THRESHOLD_CONFIANCA = 0.40  # AJUSTAR: Era 0.60, agora mais rigoroso (menor = mais rigoroso)
MODELO_RECONHECIMENTO = 'VGG-Face'  # Ou 'Facenet512' para mais precis√£o
QUALIDADE_MINIMA_FOTO = 100  # Largura/altura m√≠nima em pixels

def validar_qualidade_foto(foto_base64):
    """Valida se a foto tem qualidade m√≠nima"""
    try:
        import base64
        from PIL import Image
        from io import BytesIO
        
        # Remover prefixo data:image
        if ',' in foto_base64:
            foto_base64 = foto_base64.split(',')[1]
        
        # Decodificar
        img_data = base64.b64decode(foto_base64)
        img = Image.open(BytesIO(img_data))
        
        largura, altura = img.size
        
        # Valida√ß√µes
        if largura < QUALIDADE_MINIMA_FOTO or altura < QUALIDADE_MINIMA_FOTO:
            return False, f"Foto muito pequena ({largura}x{altura}px). M√≠nimo: {QUALIDADE_MINIMA_FOTO}x{QUALIDADE_MINIMA_FOTO}px"
        
        # Verificar se n√£o est√° muito escura
        img_array = np.array(img.convert('L'))  # Converter para escala de cinza
        brilho_medio = np.mean(img_array)
        
        if brilho_medio < 30:
            return False, "Foto muito escura. Use melhor ilumina√ß√£o"
        
        if brilho_medio > 225:
            return False, "Foto muito clara. Reduza a ilumina√ß√£o"
        
        return True, "Foto com qualidade adequada"
        
    except Exception as e:
        return False, f"Erro ao validar foto: {str(e)}"

def reconhecer_funcionario_multiplas_fotos(foto_capturada_base64):
    """
    Reconhece funcion√°rio comparando com TODAS as fotos cadastradas
    Retorna o funcion√°rio com MAIOR confian√ßa (menor dist√¢ncia)
    """
    
    # Validar qualidade da foto capturada
    valido, mensagem = validar_qualidade_foto(foto_capturada_base64)
    if not valido:
        return None, 0, mensagem
    
    # Salvar foto temporariamente
    import tempfile
    import base64
    
    with tempfile.NamedTemporaryFile(delete=False, suffix='.jpg') as temp_captura:
        if ',' in foto_capturada_base64:
            foto_capturada_base64 = foto_capturada_base64.split(',')[1]
        temp_captura.write(base64.b64decode(foto_capturada_base64))
        caminho_captura = temp_captura.name
    
    melhor_match = None
    melhor_confianca = 0
    melhor_distancia = float('inf')
    
    try:
        # Buscar todos os funcion√°rios ativos
        funcionarios = Funcionario.query.filter_by(ativo=True, admin_id=current_user.id).all()
        
        for funcionario in funcionarios:
            # Buscar todas as fotos ativas deste funcion√°rio
            fotos = FotoFacialFuncionario.query.filter_by(
                funcionario_id=funcionario.id,
                ativa=True
            ).order_by(FotoFacialFuncionario.ordem).all()
            
            # Se n√£o tem fotos na nova tabela, usar foto antiga
            if not fotos and funcionario.foto_facial_base64:
                fotos = [type('obj', (object,), {
                    'foto_base64': funcionario.foto_facial_base64,
                    'descricao': 'Foto principal'
                })]
            
            # Comparar com cada foto do funcion√°rio
            for foto in fotos:
                try:
                    # Salvar foto cadastrada temporariamente
                    with tempfile.NamedTemporaryFile(delete=False, suffix='.jpg') as temp_cadastro:
                        foto_base64_limpa = foto.foto_base64
                        if ',' in foto_base64_limpa:
                            foto_base64_limpa = foto_base64_limpa.split(',')[1]
                        temp_cadastro.write(base64.b64decode(foto_base64_limpa))
                        caminho_cadastro = temp_cadastro.name
                    
                    # Realizar compara√ß√£o
                    resultado = DeepFace.verify(
                        img1_path=caminho_captura,
                        img2_path=caminho_cadastro,
                        model_name=MODELO_RECONHECIMENTO,
                        enforce_detection=False
                    )
                    
                    distancia = resultado['distance']
                    confianca = 1 - distancia  # Converter dist√¢ncia em confian√ßa
                    
                    # Se esta foto tem melhor match que as anteriores
                    if distancia < melhor_distancia and distancia < THRESHOLD_CONFIANCA:
                        melhor_distancia = distancia
                        melhor_confianca = confianca
                        melhor_match = funcionario
                    
                    # Limpar arquivo tempor√°rio
                    import os
                    os.unlink(caminho_cadastro)
                    
                except Exception as e:
                    print(f"Erro ao comparar com foto de {funcionario.nome}: {e}")
                    continue
        
        # Limpar arquivo tempor√°rio da captura
        import os
        os.unlink(caminho_captura)
        
        if melhor_match:
            return melhor_match, melhor_confianca, f"Reconhecido com {melhor_confianca*100:.1f}% de confian√ßa"
        else:
            return None, 0, f"Nenhum funcion√°rio reconhecido (confian√ßa abaixo de {(1-THRESHOLD_CONFIANCA)*100:.0f}%)"
    
    except Exception as e:
        return None, 0, f"Erro no reconhecimento: {str(e)}"
```

---

## üìã FASE 4: Criar Interface para Cadastrar M√∫ltiplas Fotos

Modifique o formul√°rio de cadastro/edi√ß√£o de funcion√°rio:

**No template `funcionario_form.html`:**

```html
<div class="card mt-3">
    <div class="card-header">
        <h5>üì∏ Fotos para Reconhecimento Facial</h5>
        <small class="text-muted">Cadastre m√∫ltiplas fotos para melhorar a precis√£o (recomendado: 3 a 5 fotos)</small>
    </div>
    <div class="card-body">
        <!-- Fotos existentes -->
        <div id="fotos-existentes" class="row mb-3">
            {% for foto in funcionario.fotos_faciais %}
            <div class="col-md-3 mb-2">
                <div class="card">
                    <img src="{{ foto.foto_base64 }}" class="card-img-top" alt="Foto {{ foto.descricao }}">
                    <div class="card-body p-2">
                        <small>{{ foto.descricao }}</small>
                        <button type="button" class="btn btn-sm btn-danger btn-block" onclick="removerFoto({{ foto.id }})">
                            <i class="fas fa-trash"></i> Remover
                        </button>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
        
        <!-- Adicionar nova foto -->
        <div class="form-group">
            <label>Adicionar Nova Foto</label>
            <div class="row">
                <div class="col-md-6">
                    <video id="video-cadastro" width="100%" autoplay></video>
                    <button type="button" class="btn btn-primary btn-block mt-2" onclick="iniciarCamera()">
                        <i class="fas fa-camera"></i> Iniciar C√¢mera
                    </button>
                </div>
                <div class="col-md-6">
                    <canvas id="canvas-cadastro" width="640" height="480" style="display:none;"></canvas>
                    <img id="preview-foto" style="width:100%; display:none;">
                    <button type="button" class="btn btn-success btn-block mt-2" onclick="capturarFoto()" disabled id="btn-capturar">
                        <i class="fas fa-camera"></i> Capturar Foto
                    </button>
                </div>
            </div>
            
            <div class="form-group mt-3">
                <label for="descricao-foto">Descri√ß√£o da Foto</label>
                <select class="form-control" id="descricao-foto">
                    <option value="Frente sem √≥culos">Frente sem √≥culos</option>
                    <option value="Frente com √≥culos">Frente com √≥culos</option>
                    <option value="Perfil esquerdo">Perfil esquerdo</option>
                    <option value="Perfil direito">Perfil direito</option>
                    <option value="Sorrindo">Sorrindo</option>
                    <option value="S√©rio">S√©rio</option>
                </select>
            </div>
            
            <button type="button" class="btn btn-info btn-block" onclick="salvarFoto()" disabled id="btn-salvar-foto">
                <i class="fas fa-save"></i> Salvar Foto
            </button>
        </div>
        
        <!-- Orienta√ß√µes -->
        <div class="alert alert-info mt-3">
            <strong>üìã Dicas para Fotos de Qualidade:</strong>
            <ul class="mb-0">
                <li>‚úÖ Tire fotos em local bem iluminado (luz natural √© melhor)</li>
                <li>‚úÖ Rosto centralizado e olhando para a c√¢mera</li>
                <li>‚úÖ Cadastre pelo menos 3 fotos: sem √≥culos, com √≥culos, e de perfil</li>
                <li>‚úÖ Evite sombras no rosto</li>
                <li>‚úÖ N√£o use chap√©u, bon√© ou acess√≥rios que cubram o rosto</li>
                <li>‚úÖ Express√µes variadas ajudam (sorrindo e s√©rio)</li>
            </ul>
        </div>
    </div>
</div>

<script>
let stream = null;
let fotoCapturada = null;

async function iniciarCamera() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: 640, 
                height: 480,
                facingMode: 'user'
            } 
        });
        document.getElementById('video-cadastro').srcObject = stream;
        document.getElementById('btn-capturar').disabled = false;
    } catch (error) {
        alert('Erro ao acessar c√¢mera: ' + error.message);
    }
}

function capturarFoto() {
    const video = document.getElementById('video-cadastro');
    const canvas = document.getElementById('canvas-cadastro');
    const context = canvas.getContext('2d');
    
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    context.drawImage(video, 0, 0);
    
    fotoCapturada = canvas.toDataURL('image/jpeg', 0.9);
    
    // Mostrar preview
    document.getElementById('preview-foto').src = fotoCapturada;
    document.getElementById('preview-foto').style.display = 'block';
    document.getElementById('btn-salvar-foto').disabled = false;
}

function salvarFoto() {
    if (!fotoCapturada) {
        alert('Capture uma foto primeiro!');
        return;
    }
    
    const descricao = document.getElementById('descricao-foto').value;
    const funcionarioId = {{ funcionario.id if funcionario else 'null' }};
    
    // Enviar para o servidor
    fetch('/funcionario/adicionar-foto', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            funcionario_id: funcionarioId,
            foto_base64: fotoCapturada,
            descricao: descricao
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('‚úÖ Foto adicionada com sucesso!');
            location.reload();
        } else {
            alert('‚ùå Erro: ' + data.message);
        }
    });
}

function removerFoto(fotoId) {
    if (!confirm('Tem certeza que deseja remover esta foto?')) return;
    
    fetch(`/funcionario/remover-foto/${fotoId}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('‚úÖ Foto removida!');
            location.reload();
        } else {
            alert('‚ùå Erro: ' + data.message);
        }
    });
}
</script>
```

---

## üìã FASE 5: Criar Rotas para Gerenciar Fotos

No arquivo `views.py`, adicione as rotas:

```python
@app.route('/funcionario/adicionar-foto', methods=['POST'])
@login_required
def adicionar_foto_funcionario():
    """Adiciona uma nova foto facial ao funcion√°rio"""
    try:
        data = request.get_json()
        funcionario_id = data.get('funcionario_id')
        foto_base64 = data.get('foto_base64')
        descricao = data.get('descricao', 'Foto adicional')
        
        # Validar qualidade da foto
        valido, mensagem = validar_qualidade_foto(foto_base64)
        if not valido:
            return jsonify({'success': False, 'message': mensagem}), 400
        
        # Contar fotos existentes para definir ordem
        ordem = FotoFacialFuncionario.query.filter_by(funcionario_id=funcionario_id).count() + 1
        
        # Criar nova foto
        nova_foto = FotoFacialFuncionario(
            funcionario_id=funcionario_id,
            foto_base64=foto_base64,
            descricao=descricao,
            ordem=ordem,
            admin_id=current_user.id
        )
        
        db.session.add(nova_foto)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Foto adicionada com sucesso!'})
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/funcionario/remover-foto/<int:foto_id>', methods=['DELETE'])
@login_required
def remover_foto_funcionario(foto_id):
    """Remove uma foto facial do funcion√°rio"""
    try:
        foto = FotoFacialFuncionario.query.get_or_404(foto_id)
        
        # Verificar permiss√£o
        if foto.admin_id != current_user.id:
            return jsonify({'success': False, 'message': 'Sem permiss√£o'}), 403
        
        db.session.delete(foto)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Foto removida com sucesso!'})
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
```

---

## üéØ Resumo das Melhorias

1. ‚úÖ **Threshold ajustado**: De 0.60 para 0.40 (mais rigoroso)
2. ‚úÖ **Valida√ß√£o de qualidade**: Verifica tamanho, brilho e nitidez
3. ‚úÖ **M√∫ltiplas fotos**: 3 a 5 fotos por funcion√°rio
4. ‚úÖ **Compara√ß√£o completa**: Valida contra TODAS as fotos cadastradas
5. ‚úÖ **Orienta√ß√µes claras**: Dicas de como tirar boas fotos
6. ‚úÖ **Melhor modelo**: VGG-Face ou Facenet512 (mais preciso)

---

## üìã Ordem de Execu√ß√£o

1. Criar modelo `FotoFacialFuncionario`
2. Executar migra√ß√£o: `flask migrate-multiplas-fotos`
3. Modificar fun√ß√£o de reconhecimento
4. Atualizar interface de cadastro
5. Criar rotas de gerenciamento de fotos
6. Testar com funcion√°rios reais

---

## ‚úÖ Resultado Esperado

Ap√≥s implementar:
- ‚ùå Pessoas com √≥culos N√ÉO ser√£o mais confundidas
- ‚úÖ Reconhecimento mais preciso (threshold rigoroso)
- ‚úÖ Fotos de melhor qualidade (valida√ß√£o autom√°tica)
- ‚úÖ M√∫ltiplas varia√ß√µes (com/sem √≥culos, perfis)
- ‚úÖ Confian√ßa maior no sistema

üöÄ Sistema de reconhecimento facial profissional e preciso!
