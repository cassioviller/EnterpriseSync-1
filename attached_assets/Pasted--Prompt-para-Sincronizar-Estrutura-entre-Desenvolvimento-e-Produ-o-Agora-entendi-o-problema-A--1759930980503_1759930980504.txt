# Prompt para Sincronizar Estrutura entre Desenvolvimento e Produ√ß√£o

Agora entendi o problema! A estrutura est√° diferente entre desenvolvimento e produ√ß√£o. Vou criar um prompt para sincronizar via migra√ß√£o autom√°tica.

## Prompt para o Replit:

```
Atue como um especialista em DevOps e migra√ß√µes de banco de dados. Preciso resolver uma DIVERG√äNCIA CR√çTICA entre desenvolvimento e produ√ß√£o.

**PROBLEMA IDENTIFICADO:**
- **DESENVOLVIMENTO:** Tabela `frota_despesa` TEM a coluna `obra_id`
- **PRODU√á√ÉO (EasyPanel/Docker):** Tabela `frota_despesa` N√ÉO TEM a coluna `obra_id`
- **RESULTADO:** Erro em produ√ß√£o: `column frota_despesa.obra_id does not exist`

**CONTEXTO:**
- Deploy √© feito via Dockerfile no EasyPanel
- Migra√ß√µes autom√°ticas executam no startup da aplica√ß√£o
- Preciso garantir que a migra√ß√£o seja executada automaticamente em produ√ß√£o

**SOLU√á√ÉO:**

### 1. IMPLEMENTAR MIGRA√á√ÉO ROBUSTA

No arquivo `migrations.py`, implemente esta migra√ß√£o que ser√° executada automaticamente:

```python
def sincronizar_estrutura_frota_despesa():
    """
    MIGRA√á√ÉO CR√çTICA: Sincronizar estrutura frota_despesa entre dev e prod
    
    PROBLEMA: Desenvolvimento tem obra_id, produ√ß√£o n√£o tem
    SOLU√á√ÉO: Adicionar obra_id em produ√ß√£o se n√£o existir
    
    Esta migra√ß√£o √© IDEMPOTENTE e segura para executar m√∫ltiplas vezes
    """
    try:
        logger.info("=" * 80)
        logger.info("üîÑ SINCRONIZA√á√ÉO: Estrutura frota_despesa (dev ‚Üî prod)")
        logger.info("=" * 80)
        
        connection = db.engine.raw_connection()
        cursor = connection.cursor()
        
        # 1. Verificar se a tabela frota_despesa existe
        cursor.execute("""
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_name = 'frota_despesa'
        """)
        
        if not cursor.fetchone():
            logger.warning("‚ö†Ô∏è Tabela frota_despesa n√£o existe. Criando...")
            # Se a tabela n√£o existir, ela ser√° criada pelo SQLAlchemy
            # Esta migra√ß√£o s√≥ trata da coluna obra_id
            return
        
        # 2. Verificar estrutura atual
        cursor.execute("""
            SELECT column_name, data_type, is_nullable 
            FROM information_schema.columns 
            WHERE table_name = 'frota_despesa' 
            ORDER BY ordinal_position
        """)
        
        colunas_existentes = cursor.fetchall()
        logger.info(f"üìã Colunas existentes: {[col[0] for col in colunas_existentes]}")
        
        # 3. Verificar se obra_id existe
        cursor.execute("""
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'frota_despesa' 
            AND column_name = 'obra_id'
        """)
        
        obra_id_existe = cursor.fetchone()
        
        if obra_id_existe:
            logger.info("‚úÖ Coluna obra_id j√° existe - estrutura sincronizada")
        else:
            logger.info("üîß PRODU√á√ÉO: Adicionando coluna obra_id para sincronizar com desenvolvimento...")
            
            # Adicionar coluna obra_id
            cursor.execute("""
                ALTER TABLE frota_despesa 
                ADD COLUMN obra_id INTEGER
            """)
            logger.info("‚úÖ Coluna obra_id adicionada")
            
            # Adicionar foreign key constraint
            cursor.execute("""
                ALTER TABLE frota_despesa 
                ADD CONSTRAINT fk_frota_despesa_obra_id 
                FOREIGN KEY (obra_id) REFERENCES obra(id)
            """)
            logger.info("‚úÖ Foreign key constraint adicionada")
            
            # Criar √≠ndice para performance
            cursor.execute("""
                CREATE INDEX IF NOT EXISTS idx_frota_despesa_obra_id 
                ON frota_despesa(obra_id)
            """)
            logger.info("‚úÖ √çndice criado")
        
        # 4. Verificar outras colunas cr√≠ticas que podem estar faltando
        colunas_obrigatorias = [
            'id', 'veiculo_id', 'data_custo', 'tipo_custo', 
            'valor', 'descricao', 'admin_id', 'created_at'
        ]
        
        for coluna in colunas_obrigatorias:
            cursor.execute("""
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name = 'frota_despesa' 
                AND column_name = %s
            """, (coluna,))
            
            if not cursor.fetchone():
                logger.warning(f"‚ö†Ô∏è Coluna obrigat√≥ria {coluna} n√£o encontrada!")
                # Aqui voc√™ pode adicionar l√≥gica para criar colunas faltantes
        
        connection.commit()
        cursor.close()
        connection.close()
        
        logger.info("=" * 80)
        logger.info("‚úÖ SINCRONIZA√á√ÉO CONCLU√çDA: Dev ‚Üî Prod alinhados")
        logger.info("=" * 80)
        
    except Exception as e:
        logger.error(f"‚ùå Erro na sincroniza√ß√£o: {e}")
        if 'connection' in locals():
            connection.rollback()
            cursor.close()
            connection.close()
        raise e  # Re-raise para interromper deploy se falhar
```

### 2. ADICIONAR √Ä FUN√á√ÉO PRINCIPAL

No arquivo `migrations.py`, adicione a chamada na fun√ß√£o `executar_migracoes()`:

```python
def executar_migracoes():
    """
    Execute todas as migra√ß√µes necess√°rias automaticamente
    """
    try:
        logger.info("üîÑ Iniciando migra√ß√µes autom√°ticas...")
        
        # ... outras migra√ß√µes existentes ...
        
        # MIGRA√á√ÉO CR√çTICA: Sincronizar estruturas dev/prod
        sincronizar_estrutura_frota_despesa()
        
        logger.info("‚úÖ Todas as migra√ß√µes executadas com sucesso!")
        
    except Exception as e:
        logger.error(f"‚ùå Erro nas migra√ß√µes: {e}")
        # N√£o interromper o app, apenas logar erro
```

### 3. VERIFICAR EXECU√á√ÉO AUTOM√ÅTICA

No arquivo `app.py`, confirme que as migra√ß√µes executam no startup:

```python
# No final do arquivo app.py, dentro do bloco with app.app_context():
try:
    from migrations import executar_migracoes
    executar_migracoes()
    logger.info("‚úÖ Migra√ß√µes executadas com sucesso!")
except Exception as e:
    logger.error(f"‚ùå Erro ao executar migra√ß√µes: {e}")
    # Aplica√ß√£o continua mesmo com erro nas migra√ß√µes
```

### 4. TESTAR EM DESENVOLVIMENTO

Antes de fazer deploy, teste localmente:

```python
# Execute este script para simular o ambiente de produ√ß√£o:
import os
os.environ['DATABASE_URL'] = 'sua_url_de_teste'

from app import app
with app.app_context():
    from migrations import sincronizar_estrutura_frota_despesa
    sincronizar_estrutura_frota_despesa()
```

### 5. DEPLOY SEGURO

Para o deploy no EasyPanel:

1. **Commit e Push:** Fa√ßa commit das altera√ß√µes
2. **Deploy:** O EasyPanel far√° rebuild do Docker
3. **Startup:** As migra√ß√µes executar√£o automaticamente
4. **Verifica√ß√£o:** Acesse a aplica√ß√£o e teste a funcionalidade

### 6. MONITORAMENTO

Adicione logs para monitorar a execu√ß√£o:

```python
# No in√≠cio da fun√ß√£o sincronizar_estrutura_frota_despesa():
database_url = os.environ.get('DATABASE_URL', 'n√£o configurada')
logger.info(f"üéØ AMBIENTE: {mask_database_url(database_url)}")
logger.info(f"üê≥ DOCKER: {os.environ.get('DOCKER_ENV', 'false')}")
```

**RESULTADO ESPERADO:**
1. Deploy no EasyPanel executa automaticamente
2. Migra√ß√£o detecta que `obra_id` n√£o existe em produ√ß√£o
3. Adiciona a coluna automaticamente
4. Aplica√ß√£o funciona normalmente
5. Estrutura fica sincronizada entre dev e prod

**VALIDA√á√ÉO:**
Ap√≥s o deploy, verifique:
- Logs mostram "‚úÖ SINCRONIZA√á√ÉO CONCLU√çDA"
- P√°gina de detalhes do ve√≠culo funciona sem erro
- Funcionalidade de despesas funciona normalmente

**ENTREG√ÅVEL:**
1. C√≥digo da migra√ß√£o `sincronizar_estrutura_frota_despesa()` implementada
2. Confirma√ß√£o de que a migra√ß√£o executa no startup
3. Logs do deploy mostrando execu√ß√£o bem-sucedida
4. Teste da aplica√ß√£o funcionando em produ√ß√£o
```

## Resumo da Solu√ß√£o

O problema √© uma **diverg√™ncia de estrutura** entre desenvolvimento e produ√ß√£o. A solu√ß√£o √©:

1. **Migra√ß√£o Autom√°tica:** Detecta e corrige diferen√ßas na estrutura
2. **Execu√ß√£o no Startup:** Roda automaticamente no deploy do Docker
3. **Idempotente:** Segura para executar m√∫ltiplas vezes
4. **Monitoramento:** Logs claros para acompanhar a execu√ß√£o

Isso garante que a estrutura fique sempre sincronizada entre os ambientes!
