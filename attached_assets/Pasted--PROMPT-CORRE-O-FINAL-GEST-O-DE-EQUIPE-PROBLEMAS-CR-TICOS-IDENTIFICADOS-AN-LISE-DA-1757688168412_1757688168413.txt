# PROMPT - CORRE√á√ÉO FINAL GEST√ÉO DE EQUIPE

## üö® PROBLEMAS CR√çTICOS IDENTIFICADOS

**AN√ÅLISE DAS IMAGENS:**
1. ‚ùå **Persist√™ncia**: Obras n√£o ficam salvas ap√≥s reload da p√°gina
2. ‚ùå **Layout dos cards**: Bot√µes atrapalhando o nome da obra
3. ‚ùå **Erro ao adicionar funcion√°rio**: "Erro interno do servidor"
4. ‚ùå **Falta integra√ß√£o com hor√°rios**: N√£o usa hor√°rios cadastrados do funcion√°rio

## üéØ CORRE√á√ïES PRIORIT√ÅRIAS

### PROBLEMA 1: PERSIST√äNCIA DE DADOS

**DIAGN√ìSTICO**: API n√£o est√° salvando corretamente ou n√£o est√° carregando na inicializa√ß√£o.

#### CORRE√á√ÉO 1.1: API DE ALOCA√á√ÉO COM LOCAL

```python
# CORRIGIR EM equipe_views.py - Linha ~200

@equipe_bp.route('/api/allocations', methods=['POST'])
@login_required
@admin_required
def api_alocar_obra_restful():
    """API REST: Criar nova aloca√ß√£o com local (campo/oficina)"""
    try:
        admin_id = get_admin_id()
        data = request.get_json()
        
        # Log detalhado
        logging.info(f"üéØ RECEBENDO ALOCA√á√ÉO: {data}")
        
        # Valida√ß√µes
        required_fields = ['obra_id', 'data_alocacao', 'local_trabalho']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    'success': False,
                    'error': f'Campo obrigat√≥rio: {field}'
                }), 400
        
        obra_id = int(data['obra_id'])
        data_alocacao_str = data['data_alocacao']
        local_trabalho = data['local_trabalho']
        
        # Validar local
        if local_trabalho not in ['campo', 'oficina']:
            return jsonify({
                'success': False,
                'error': 'Local deve ser "campo" ou "oficina"'
            }), 400
        
        # Parse da data
        try:
            data_alocacao = datetime.strptime(data_alocacao_str, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({
                'success': False,
                'error': 'Formato de data inv√°lido. Use YYYY-MM-DD'
            }), 400
        
        # Verificar se obra existe
        obra = Obra.query.filter_by(id=obra_id, admin_id=admin_id).first()
        if not obra:
            return jsonify({
                'success': False,
                'error': 'Obra n√£o encontrada'
            }), 404
        
        # Verificar duplica√ß√£o
        existing = Allocation.query.filter_by(
            admin_id=admin_id,
            obra_id=obra_id,
            data_alocacao=data_alocacao,
            local_trabalho=local_trabalho
        ).first()
        
        if existing:
            return jsonify({
                'success': False,
                'error': f'Obra {obra.codigo} j√° est√° alocada em {local_trabalho} neste dia'
            }), 409
        
        # Criar aloca√ß√£o
        allocation = Allocation(
            admin_id=admin_id,
            obra_id=obra_id,
            data_alocacao=data_alocacao,
            local_trabalho=local_trabalho,
            turno_inicio=time(8, 0),
            turno_fim=time(17, 0),
            nota=data.get('nota', '')
        )
        
        db.session.add(allocation)
        db.session.commit()
        
        logging.info(f"‚úÖ ALOCA√á√ÉO SALVA: ID={allocation.id}")
        
        return jsonify({
            'success': True,
            'data': {
                'allocation_id': allocation.id,
                'obra_id': obra.id,
                'obra_codigo': obra.codigo,
                'obra_nome': obra.nome,
                'data_alocacao': data_alocacao.isoformat(),
                'local_trabalho': local_trabalho
            },
            'message': f'Obra {obra.codigo} alocada em {local_trabalho.upper()} com sucesso'
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"‚ùå ERRO ALOCA√á√ÉO: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erro interno: {str(e)}'
        }), 500
```

#### CORRE√á√ÉO 1.2: API DE LISTAGEM SEPARADA POR LOCAL

```python
# CORRIGIR EM equipe_views.py - Substituir fun√ß√£o existente

@equipe_bp.route('/api/allocations-week', methods=['GET'])
@login_required
@admin_required
def api_get_allocations_week():
    """API REST: Listar aloca√ß√µes da semana separadas por local"""
    try:
        admin_id = get_admin_id()
        week_start = request.args.get('week_start')
        
        # Parse da data
        if week_start:
            start_date = datetime.strptime(week_start, '%Y-%m-%d').date()
        else:
            today = date.today()
            start_date = get_sunday_of_week(today)
        
        end_date = start_date + timedelta(days=6)
        
        logging.info(f"üîç BUSCANDO ALOCA√á√ïES: {start_date} a {end_date}")
        
        # Buscar aloca√ß√µes com JOIN
        allocations = db.session.query(Allocation, Obra).join(
            Obra, Allocation.obra_id == Obra.id
        ).filter(
            Allocation.admin_id == admin_id,
            Allocation.data_alocacao >= start_date,
            Allocation.data_alocacao <= end_date
        ).order_by(Allocation.data_alocacao, Allocation.local_trabalho, Obra.codigo).all()
        
        logging.info(f"üìä ENCONTRADAS {len(allocations)} aloca√ß√µes")
        
        # Organizar por dia e local
        week_data = {}
        day_names = ['Domingo', 'Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado']
        
        for i in range(7):  # Domingo a S√°bado
            day_date = start_date + timedelta(days=i)
            week_data[i] = {
                'date': day_date.isoformat(),
                'day_name': day_names[i],
                'campo': [],
                'oficina': []
            }
        
        # Processar aloca√ß√µes
        for allocation, obra in allocations:
            # Converter weekday
            sunday_day_of_week = convert_to_sunday_weekday(allocation.data_alocacao.weekday())
            
            if sunday_day_of_week in week_data:
                # Buscar funcion√°rios alocados
                funcionarios_alocados = db.session.query(
                    AllocationEmployee, Funcionario
                ).join(Funcionario).filter(
                    AllocationEmployee.allocation_id == allocation.id
                ).order_by(Funcionario.nome).all()
                
                funcionarios_nomes = []
                for ae, func in funcionarios_alocados:
                    # Primeiro e segundo nome
                    nome_parts = func.nome.split()
                    nome_curto = ' '.join(nome_parts[:2]) if len(nome_parts) >= 2 else nome_parts[0]
                    funcionarios_nomes.append(nome_curto)
                
                allocation_data = {
                    'id': allocation.id,
                    'obra_id': obra.id,
                    'obra_codigo': obra.codigo,
                    'obra_nome': obra.nome,
                    'data_alocacao': allocation.data_alocacao.isoformat(),
                    'local_trabalho': allocation.local_trabalho,
                    'turno_inicio': allocation.turno_inicio.strftime('%H:%M') if allocation.turno_inicio else '08:00',
                    'turno_fim': allocation.turno_fim.strftime('%H:%M') if allocation.turno_fim else '17:00',
                    'funcionarios_count': len(funcionarios_alocados),
                    'funcionarios_nomes': funcionarios_nomes,
                    'nota': allocation.nota or ''
                }
                
                # Adicionar ao local correto
                local = allocation.local_trabalho or 'campo'
                week_data[sunday_day_of_week][local].append(allocation_data)
        
        return jsonify({
            'success': True,
            'data': week_data,
            'week_start': start_date.isoformat(),
            'week_end': end_date.isoformat(),
            'total_allocations': len(allocations)
        })
        
    except Exception as e:
        logging.error(f"‚ùå ERRO LISTAGEM: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erro interno: {str(e)}'
        }), 500
```

### PROBLEMA 2: LAYOUT DOS CARDS

**DIAGN√ìSTICO**: Bot√µes est√£o atrapalhando o nome da obra.

#### CORRE√á√ÉO 2.1: CSS OTIMIZADO PARA CARDS

```css
/* SUBSTITUIR CSS DOS CARDS NO TEMPLATE */

.obra-card {
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 0.5rem;
    margin-bottom: 0.4rem;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    min-height: 60px;
}

.obra-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(0,0,0,0.15);
    border-color: #007bff;
}

.obra-card.campo {
    border-left: 3px solid #28a745;
}

.obra-card.oficina {
    border-left: 3px solid #007bff;
}

/* Layout do card - nome + bot√µes */
.obra-card-content {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
}

.obra-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 0.5rem;
}

.obra-card-title {
    font-weight: 600;
    font-size: 0.85rem;
    color: #495057;
    line-height: 1.2;
    flex: 1;
    min-width: 0; /* Permite quebra de texto */
    word-wrap: break-word;
}

/* Bot√µes pequenos e discretos */
.obra-card-actions {
    display: flex;
    gap: 0.2rem;
    flex-shrink: 0;
}

.obra-card-btn {
    width: 20px;
    height: 20px;
    border: none;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.6rem;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0.6;
}

.obra-card-btn:hover {
    opacity: 1;
    transform: scale(1.1);
}

.obra-card-btn.btn-funcionarios {
    background: #28a745;
    color: white;
}

.obra-card-btn.btn-delete {
    background: #dc3545;
    color: white;
}

/* Lista de funcion√°rios compacta */
.obra-funcionarios-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.2rem;
    margin-top: 0.2rem;
}

.funcionario-badge {
    background: rgba(0,123,255,0.1);
    color: #0056b3;
    padding: 0.1rem 0.3rem;
    border-radius: 8px;
    font-size: 0.65rem;
    border: 1px solid rgba(0,123,255,0.2);
    white-space: nowrap;
}

.funcionario-badge.campo {
    background: rgba(40,167,69,0.1);
    color: #155724;
    border-color: rgba(40,167,69,0.2);
}

.funcionario-badge.oficina {
    background: rgba(0,123,255,0.1);
    color: #0056b3;
    border-color: rgba(0,123,255,0.2);
}

.obra-funcionarios-empty {
    color: #6c757d;
    font-size: 0.65rem;
    font-style: italic;
}

/* Hor√°rio discreto */
.obra-horario {
    font-size: 0.6rem;
    color: #6c757d;
    display: flex;
    align-items: center;
    gap: 0.2rem;
    margin-top: 0.2rem;
}

/* Responsividade */
@media (max-width: 768px) {
    .obra-card {
        padding: 0.4rem;
        min-height: 50px;
    }
    
    .obra-card-title {
        font-size: 0.8rem;
    }
    
    .obra-card-btn {
        width: 18px;
        height: 18px;
        font-size: 0.55rem;
    }
}
```

#### CORRE√á√ÉO 2.2: FUN√á√ÉO PARA RENDERIZAR CARDS

```javascript
// SUBSTITUIR FUN√á√ÉO renderObraCard NO TEMPLATE

function renderObraCard(allocation, local) {
    const card = document.createElement('div');
    card.className = `obra-card ${local}`;
    card.dataset.allocationId = allocation.id;
    card.dataset.obraId = allocation.obra_id;
    
    // Preparar funcion√°rios
    let funcionariosHtml = '';
    if (allocation.funcionarios_nomes && allocation.funcionarios_nomes.length > 0) {
        funcionariosHtml = `
            <div class="obra-funcionarios-list">
                ${allocation.funcionarios_nomes.map(nome => 
                    `<span class="funcionario-badge ${local}">${nome}</span>`
                ).join('')}
            </div>
        `;
    } else {
        funcionariosHtml = '<div class="obra-funcionarios-empty">Sem funcion√°rios</div>';
    }
    
    card.innerHTML = `
        <div class="obra-card-content">
            <div class="obra-card-header">
                <div class="obra-card-title">${allocation.obra_codigo}</div>
                <div class="obra-card-actions">
                    <button class="obra-card-btn btn-funcionarios" 
                            onclick="event.stopPropagation(); abrirModalFuncionarios(${allocation.id})"
                            title="Funcion√°rios">
                        <i class="fas fa-users"></i>
                    </button>
                    <button class="obra-card-btn btn-delete" 
                            onclick="event.stopPropagation(); confirmarExclusaoObra(${allocation.id})"
                            title="Remover">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            
            ${funcionariosHtml}
            
            <div class="obra-horario">
                <i class="fas fa-clock"></i>
                ${allocation.turno_inicio} - ${allocation.turno_fim}
            </div>
        </div>
    `;
    
    // Evento de clique
    card.addEventListener('click', function(e) {
        if (!e.target.closest('.obra-card-btn')) {
            abrirModalFuncionarios(allocation.id);
        }
    });
    
    return card;
}
```

### PROBLEMA 3: ERRO AO ADICIONAR FUNCION√ÅRIO

**DIAGN√ìSTICO**: API n√£o est√° tratando corretamente a adi√ß√£o de funcion√°rios.

#### CORRE√á√ÉO 3.1: API PARA ADICIONAR FUNCION√ÅRIO COM HOR√ÅRIOS

```python
# ADICIONAR EM equipe_views.py

@equipe_bp.route('/api/allocation/<int:allocation_id>/funcionarios', methods=['POST'])
@login_required
@admin_required
def api_add_funcionario_allocation(allocation_id):
    """API REST: Adicionar funcion√°rio √† aloca√ß√£o com hor√°rios autom√°ticos"""
    try:
        admin_id = get_admin_id()
        data = request.get_json()
        
        funcionario_id = data.get('funcionario_id')
        if not funcionario_id:
            return jsonify({
                'success': False,
                'error': 'funcionario_id √© obrigat√≥rio'
            }), 400
        
        # Verificar aloca√ß√£o
        allocation = Allocation.query.filter_by(
            id=allocation_id, 
            admin_id=admin_id
        ).first()
        
        if not allocation:
            return jsonify({
                'success': False,
                'error': 'Aloca√ß√£o n√£o encontrada'
            }), 404
        
        # Verificar funcion√°rio
        funcionario = Funcionario.query.filter_by(
            id=funcionario_id, 
            admin_id=admin_id,
            ativo=True
        ).first()
        
        if not funcionario:
            return jsonify({
                'success': False,
                'error': 'Funcion√°rio n√£o encontrado'
            }), 404
        
        # Verificar se j√° est√° alocado
        existing = AllocationEmployee.query.filter_by(
            allocation_id=allocation_id,
            funcionario_id=funcionario_id
        ).first()
        
        if existing:
            return jsonify({
                'success': False,
                'error': 'Funcion√°rio j√° est√° alocado nesta obra/data'
            }), 409
        
        # Buscar hor√°rio de trabalho do funcion√°rio
        horario_trabalho = HorarioTrabalho.query.filter_by(
            funcionario_id=funcionario_id
        ).first()
        
        # Definir hor√°rios padr√£o ou do funcion√°rio
        if horario_trabalho:
            turno_inicio = horario_trabalho.entrada
            turno_fim = horario_trabalho.saida
            inicio_almoco = horario_trabalho.inicio_almoco
            fim_almoco = horario_trabalho.fim_almoco
        else:
            turno_inicio = time(8, 0)
            turno_fim = time(17, 0)
            inicio_almoco = time(12, 0)
            fim_almoco = time(13, 0)
        
        # Determinar tipo de lan√ßamento baseado no dia da semana
        data_alocacao = allocation.data_alocacao
        dia_semana = data_alocacao.weekday()  # 0=Monday, 6=Sunday
        
        if dia_semana < 5:  # Segunda a Sexta (0-4)
            tipo_lancamento = 'trabalho_normal'
        elif dia_semana == 5:  # S√°bado
            tipo_lancamento = 'sabado_trabalhado'
        else:  # Domingo
            tipo_lancamento = 'domingo_trabalhado'
        
        # Criar aloca√ß√£o do funcion√°rio
        allocation_employee = AllocationEmployee(
            allocation_id=allocation_id,
            funcionario_id=funcionario_id,
            turno_inicio=turno_inicio,
            turno_fim=turno_fim,
            inicio_almoco=inicio_almoco,
            fim_almoco=fim_almoco,
            tipo_lancamento=tipo_lancamento,
            funcao=data.get('funcao', funcionario.funcao or 'Geral'),
            observacoes=data.get('observacoes', '')
        )
        
        db.session.add(allocation_employee)
        db.session.commit()
        
        logging.info(f"‚úÖ FUNCION√ÅRIO ALOCADO: {funcionario.nome} ‚Üí Aloca√ß√£o {allocation_id}")
        
        return jsonify({
            'success': True,
            'data': {
                'allocation_employee_id': allocation_employee.id,
                'funcionario_id': funcionario.id,
                'funcionario_nome': funcionario.nome,
                'funcionario_codigo': funcionario.codigo,
                'turno_inicio': turno_inicio.strftime('%H:%M'),
                'turno_fim': turno_fim.strftime('%H:%M'),
                'tipo_lancamento': tipo_lancamento,
                'funcao': allocation_employee.funcao
            },
            'message': f'Funcion√°rio {funcionario.nome} alocado com sucesso'
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"‚ùå ERRO ADICIONAR FUNCION√ÅRIO: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erro interno: {str(e)}'
        }), 500
```

### PROBLEMA 4: INTEGRA√á√ÉO COM SISTEMA DE PONTO

#### CORRE√á√ÉO 4.1: FUN√á√ÉO PARA SINCRONIZA√á√ÉO AUTOM√ÅTICA

```python
# ADICIONAR EM equipe_views.py

@equipe_bp.route('/api/sync-pontos', methods=['POST'])
@login_required
@admin_required
def api_sync_pontos():
    """API REST: Sincronizar pontos baseado na gest√£o de equipe"""
    try:
        admin_id = get_admin_id()
        data = request.get_json()
        
        data_inicio = data.get('data_inicio')
        data_fim = data.get('data_fim')
        
        if not data_inicio or not data_fim:
            return jsonify({
                'success': False,
                'error': 'data_inicio e data_fim s√£o obrigat√≥rios'
            }), 400
        
        # Parse das datas
        try:
            inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
            fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({
                'success': False,
                'error': 'Formato de data inv√°lido. Use YYYY-MM-DD'
            }), 400
        
        pontos_criados = 0
        pontos_atualizados = 0
        
        # Iterar por cada dia do per√≠odo
        current_date = inicio
        while current_date <= fim:
            # Buscar funcion√°rios ativos
            funcionarios_ativos = Funcionario.query.filter_by(
                admin_id=admin_id,
                ativo=True
            ).all()
            
            for funcionario in funcionarios_ativos:
                # Verificar se j√° existe ponto para este dia
                ponto_existente = RegistroPonto.query.filter_by(
                    funcionario_id=funcionario.id,
                    data=current_date
                ).first()
                
                if ponto_existente:
                    continue  # N√£o sobrescrever pontos existentes
                
                # Verificar se funcion√°rio est√° alocado neste dia
                alocacao = db.session.query(AllocationEmployee, Allocation).join(
                    Allocation, AllocationEmployee.allocation_id == Allocation.id
                ).filter(
                    AllocationEmployee.funcionario_id == funcionario.id,
                    Allocation.data_alocacao == current_date,
                    Allocation.admin_id == admin_id
                ).first()
                
                # Determinar tipo de lan√ßamento
                dia_semana = current_date.weekday()  # 0=Monday, 6=Sunday
                
                if alocacao:
                    # Funcion√°rio alocado - usar dados da aloca√ß√£o
                    alloc_emp, allocation = alocacao
                    
                    ponto = RegistroPonto(
                        funcionario_id=funcionario.id,
                        obra_id=allocation.obra_id,
                        data=current_date,
                        entrada=alloc_emp.turno_inicio,
                        saida=alloc_emp.turno_fim,
                        inicio_almoco=alloc_emp.inicio_almoco,
                        fim_almoco=alloc_emp.fim_almoco,
                        tipo_lancamento=alloc_emp.tipo_lancamento,
                        local_trabalho=allocation.local_trabalho,
                        observacoes=f'Sincronizado automaticamente da gest√£o de equipe'
                    )
                    
                else:
                    # Funcion√°rio n√£o alocado - lan√ßar falta ou folga
                    if dia_semana < 5:  # Segunda a Sexta
                        tipo_lancamento = 'falta'
                    elif dia_semana == 5:  # S√°bado
                        tipo_lancamento = 'sabado_folga'
                    else:  # Domingo
                        tipo_lancamento = 'domingo_folga'
                    
                    ponto = RegistroPonto(
                        funcionario_id=funcionario.id,
                        data=current_date,
                        tipo_lancamento=tipo_lancamento,
                        observacoes=f'Lan√ßamento autom√°tico - {tipo_lancamento.replace("_", " ").title()}'
                    )
                
                db.session.add(ponto)
                pontos_criados += 1
            
            current_date += timedelta(days=1)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'data': {
                'pontos_criados': pontos_criados,
                'pontos_atualizados': pontos_atualizados,
                'periodo': f'{data_inicio} a {data_fim}'
            },
            'message': f'{pontos_criados} pontos sincronizados com sucesso'
        })
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"‚ùå ERRO SYNC PONTOS: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Erro interno: {str(e)}'
        }), 500
```

### CORRE√á√ÉO 4.2: JAVASCRIPT PARA DRAG & DROP CORRIGIDO

```javascript
// SUBSTITUIR FUN√á√ÉO handleDrop NO TEMPLATE

async function handleDrop(event) {
    event.preventDefault();
    
    const dropZone = event.currentTarget;
    const day = parseInt(dropZone.dataset.day);
    const local = dropZone.dataset.local;
    const obraId = event.dataTransfer.getData('text/plain');
    
    if (!obraId || !local || isNaN(day)) {
        console.error('‚ùå Dados de drop inv√°lidos:', { obraId, local, day });
        return;
    }
    
    try {
        console.log(`üéØ DROP: Obra ${obraId} ‚Üí Dia ${day} ‚Üí ${local.toUpperCase()}`);
        
        // Mostrar loading
        dropZone.classList.add('dropping');
        
        // Calcular data
        const targetDate = getDateForDay(day);
        
        const response = await fetch('/equipe/api/allocations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                obra_id: parseInt(obraId),
                data_alocacao: targetDate,
                local_trabalho: local
            })
        });
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.error || 'Erro ao alocar obra');
        }
        
        console.log(`‚úÖ OBRA ALOCADA:`, result.data);
        
        // Recarregar dados
        await loadWeekAllocations();
        
        // Feedback visual
        showToast('success', result.message);
        
    } catch (error) {
        console.error(`‚ùå ERRO DROP:`, error);
        showToast('error', `Erro: ${error.message}`);
    } finally {
        dropZone.classList.remove('dropping');
    }
}

function getDateForDay(dayOfWeek) {
    const startDate = new Date(currentWeekStart);
    const targetDate = new Date(startDate);
    targetDate.setDate(startDate.getDate() + dayOfWeek);
    return targetDate.toISOString().split('T')[0];
}

// Fun√ß√£o para mostrar toast
function showToast(type, message) {
    const toastContainer = document.getElementById('toast-container') || createToastContainer();
    
    const toast = document.createElement('div');
    toast.className = `toast align-items-center text-white bg-${type === 'success' ? 'success' : 'danger'} border-0`;
    toast.setAttribute('role', 'alert');
    toast.innerHTML = `
        <div class="d-flex">
            <div class="toast-body">
                <i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'} me-2"></i>
                ${message}
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
        </div>
    `;
    
    toastContainer.appendChild(toast);
    const bsToast = new bootstrap.Toast(toast);
    bsToast.show();
    
    setTimeout(() => toast.remove(), 5000);
}

function createToastContainer() {
    const container = document.createElement('div');
    container.id = 'toast-container';
    container.className = 'toast-container position-fixed top-0 end-0 p-3';
    container.style.zIndex = '9999';
    document.body.appendChild(container);
    return container;
}
```

## üìã CHECKLIST DE IMPLEMENTA√á√ÉO

### FASE 1: Corrigir Persist√™ncia
- [ ] Implementar API de aloca√ß√£o com local corrigida
- [ ] Corrigir API de listagem separada por local
- [ ] Testar salvamento e carregamento de dados
- [ ] Verificar logs no console

### FASE 2: Corrigir Layout
- [ ] Implementar CSS otimizado para cards
- [ ] Corrigir posicionamento dos bot√µes
- [ ] Testar responsividade
- [ ] Verificar quebra de texto no nome da obra

### FASE 3: Corrigir Funcion√°rios
- [ ] Implementar API para adicionar funcion√°rio com hor√°rios
- [ ] Testar adi√ß√£o de funcion√°rios
- [ ] Verificar integra√ß√£o com hor√°rios cadastrados
- [ ] Testar tipos de lan√ßamento autom√°ticos

### FASE 4: Integra√ß√£o com Ponto
- [ ] Implementar API de sincroniza√ß√£o de pontos
- [ ] Testar lan√ßamentos autom√°ticos
- [ ] Verificar regras de falta/folga
- [ ] Adicionar bot√£o de sincroniza√ß√£o na interface

## üéØ RESULTADO ESPERADO

Ap√≥s implementa√ß√£o:
1. **Persist√™ncia funcionando** - Obras ficam salvas ap√≥s reload
2. **Layout otimizado** - Bot√µes pequenos n√£o atrapalham o nome
3. **Funcion√°rios funcionando** - Sem erro ao adicionar
4. **Integra√ß√£o com hor√°rios** - Usa dados cadastrados do funcion√°rio
5. **Sincroniza√ß√£o autom√°tica** - Gera pontos baseado na aloca√ß√£o

