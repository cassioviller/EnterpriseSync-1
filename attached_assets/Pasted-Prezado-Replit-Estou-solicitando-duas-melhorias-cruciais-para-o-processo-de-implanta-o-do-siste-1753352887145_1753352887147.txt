Prezado Replit,

Estou solicitando duas melhorias cruciais para o processo de implanta√ß√£o do sistema SIGE v8.0, focando na usabilidade inicial e na robustez em ambiente de produ√ß√£o. Por favor, implemente as seguintes funcionalidades e forne√ßa as explica√ß√µes t√©cnicas necess√°rias para cada uma.

---

### **1. Usu√°rio Superadmin Pr√©-cadastrado na Primeira Inicializa√ß√£o**

**Contexto e Necessidade:**

Ao implantar o sistema em um novo ambiente de produ√ß√£o, √© fundamental ter um usu√°rio administrador inicial para configurar perfis, permiss√µes e outros dados mestres. Atualmente, o processo exige a cria√ß√£o manual, o que pode ser um gargalo ou um ponto de falha. Precisamos que um usu√°rio superadmin seja criado automaticamente na primeira inicializa√ß√£o do banco de dados, garantindo que eu possa acessar o sistema imediatamente para gerenciar os acessos.

**Solu√ß√£o Proposta (Implementa√ß√£o no `docker-entrypoint.sh`):**

Para resolver isso, sugiro adicionar uma l√≥gica ao `docker-entrypoint.sh` que verifique a exist√™ncia de um usu√°rio superadmin e o crie apenas se ele n√£o existir. Isso garante que a opera√ß√£o seja idempotente e n√£o cause problemas em reinicializa√ß√µes subsequentes do cont√™iner.

**Conte√∫do Sugerido para `docker-entrypoint.sh` (Adicionar ap√≥s `db.create_all()`):**

```bash
# Criar usu√°rio superadmin padr√£o se n√£o existir
echo "üë§ Verificando/Criando usu√°rio superadmin..."
python -c "
from app import app, db
from models import User # Assumindo que seu modelo de usu√°rio se chama User

with app.app_context():
    try:
        # Substitua 'admin@sige.com' e 'admin123' pelos dados desejados
        # Certifique-se de que a senha seja hashada corretamente, se necess√°rio
        admin_email = os.environ.get("SUPERADMIN_EMAIL", "admin@sige.com")
        admin_password = os.environ.get("SUPERADMIN_PASSWORD", "admin123")
        admin_name = os.environ.get("SUPERADMIN_NAME", "Super Admin")

        existing_admin = User.query.filter_by(email=admin_email).first()
        if not existing_admin:
            # Crie o usu√°rio. Adapte isso ao seu modelo de usu√°rio (e.g., hash de senha)
            new_admin = User(email=admin_email, name=admin_name, password=admin_password, is_superadmin=True)
            db.session.add(new_admin)
            db.session.commit()
            print(f'‚úÖ Usu√°rio superadmin {admin_email} criado com sucesso!')
        else:
            print(f'‚òëÔ∏è Usu√°rio superadmin {admin_email} j√° existe.')
    except Exception as e:
        print(f'‚ùå Erro ao criar/verificar superadmin: {e}')
        # N√£o sair com erro fatal aqui, pois pode ser um problema tempor√°rio
" || echo "‚ö†Ô∏è Problema na cria√ß√£o do superadmin, continuando..."
```

**Explica√ß√£o:**

*   **Verifica√ß√£o de Exist√™ncia:** O script Python verifica se um usu√°rio com o email `admin@sige.com` j√° existe no banco de dados. Isso evita a cria√ß√£o duplicada em reinicializa√ß√µes.
*   **Cria√ß√£o Condicional:** Se o usu√°rio n√£o for encontrado, ele √© criado com os dados padr√£o. **√â crucial que voc√™ adapte a l√≥gica de cria√ß√£o do usu√°rio (`User(...)`) para o seu modelo de usu√°rio espec√≠fico, incluindo o hashing de senha se aplic√°vel.**
*   **Vari√°veis de Ambiente:** Utiliza `os.environ.get` para permitir que o email, senha e nome do superadmin sejam configurados via vari√°veis de ambiente (`SUPERADMIN_EMAIL`, `SUPERADMIN_PASSWORD`, `SUPERADMIN_NAME`) no EasyPanel, tornando a solu√ß√£o mais flex√≠vel e segura para produ√ß√£o.
*   **Idempot√™ncia:** A opera√ß√£o √© idempotente, ou seja, pode ser executada m√∫ltiplas vezes sem efeitos colaterais indesejados.

---

### **2. Preserva√ß√£o de Dados em Novas Implanta√ß√µes (Atualiza√ß√µes de Funcionalidades)**

**Contexto e Necessidade:**

Ao implantar novas funcionalidades ou corre√ß√µes de bugs, √© comum que o esquema do banco de dados precise ser atualizado (adicionar colunas, tabelas, etc.). Se o processo de deploy n√£o for cuidadoso, pode haver perda de dados existentes. Precisamos garantir que as atualiza√ß√µes do sistema n√£o afetem a integridade dos dados j√° armazenados.

**Solu√ß√£o Proposta (Uso de Migra√ß√µes de Banco de Dados):**

A linha `db.create_all()` no `docker-entrypoint.sh` √© √∫til para criar tabelas que n√£o existem, mas **n√£o √© adequada para gerenciar altera√ß√µes de esquema (migra√ß√µes)**. Para isso, √© essencial usar uma ferramenta de migra√ß√£o de banco de dados como **Flask-Migrate** (que usa Alembic por baixo dos panos).

**Passos para Implementa√ß√£o (Recomendado):**

1.  **Instalar Flask-Migrate:**
    Adicione `Flask-Migrate` ao seu `pyproject.toml` ou `requirements.txt`.

2.  **Configurar Flask-Migrate na Aplica√ß√£o:**
    No seu arquivo `app.py` (ou onde voc√™ inicializa o Flask e SQLAlchemy):
    ```python
    from flask_migrate import Migrate

    # ... (inicializa√ß√£o do app e db)

    migrate = Migrate(app, db)
    ```

3.  **Gerar Migra√ß√µes:**
    Em ambiente de desenvolvimento, voc√™ usaria comandos como:
    ```bash
    flask db init
    flask db migrate -m "Initial migration"
    flask db upgrade
    ```
    Isso criaria scripts de migra√ß√£o no seu projeto.

4.  **Atualizar `docker-entrypoint.sh` para Aplicar Migra√ß√µes:**
    Substitua ou adicione ao seu `docker-entrypoint.sh` a execu√ß√£o das migra√ß√µes. O comando `flask db upgrade` aplicar√° todas as migra√ß√µes pendentes, preservando os dados existentes.

    **Conte√∫do Sugerido para `docker-entrypoint.sh` (Substituir `db.create_all()`):**

    ```bash
    # Aplicar migra√ß√µes de banco de dados
    echo "üóÑÔ∏è Aplicando migra√ß√µes de banco de dados..."
    flask db upgrade || echo "‚ö†Ô∏è Erro ao aplicar migra√ß√µes, continuando..."
    echo "‚úÖ Migra√ß√µes aplicadas/verificadas com sucesso"
    ```

**Explica√ß√£o:**

*   **`flask db upgrade`**: Este comando √© a chave para a preserva√ß√£o de dados. Ele l√™ os scripts de migra√ß√£o gerados e aplica apenas as altera√ß√µes de esquema necess√°rias, sem apagar ou sobrescrever dados existentes. Isso permite que voc√™ evolua o esquema do seu banco de dados de forma segura e controlada.
*   **Controle de Vers√£o do Esquema:** As migra√ß√µes s√£o versionadas, o que significa que voc√™ pode reverter altera√ß√µes ou aplicar migra√ß√µes em ambientes diferentes de forma consistente.

**Observa√ß√£o Importante:**

Para que `flask db upgrade` funcione, voc√™ precisar√° ter os scripts de migra√ß√£o gerados (`migrations/` pasta) no seu reposit√≥rio. Certifique-se de que eles estejam inclu√≠dos no seu build Docker.

---

Por favor, implemente essas melhorias e me informe o resultado. Se precisar de mais detalhes sobre como configurar o Flask-Migrate ou adaptar seu modelo de usu√°rio, me avise.