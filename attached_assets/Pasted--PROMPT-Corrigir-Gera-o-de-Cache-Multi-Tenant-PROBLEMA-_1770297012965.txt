# üéØ PROMPT: Corrigir Gera√ß√£o de Cache Multi-Tenant

## üö® PROBLEMA IDENTIFICADO:

Pelos logs:
```
‚ùå Cache lookup: 0.00s (erro: Nenhum embedding no cache para este tenant)
```

**O cache N√ÉO TEM embeddings para o tenant `admin_id=2`!**

---

## üéØ OBJETIVO:

Corrigir a gera√ß√£o de cache para:
1. Gerar embeddings para **TODOS os tenants**
2. Salvar em estrutura **multi-tenant** correta
3. Carregar embeddings **filtrados por tenant**
4. Funcionar via comando Flask CLI

---

## üìã TAREFAS:

### **TAREFA 1: Corrigir Estrutura do Cache Multi-Tenant**

O cache precisa ter uma estrutura que separe embeddings por tenant:

```json
{
  "model": "SFace",
  "generated_at": "2026-02-05T10:30:00",
  "tenants": {
    "1": {
      "embeddings": {
        "123": [
          {
            "embedding": [0.123, 0.456, ...],
            "foto_id": 1,
            "descricao": "Frente sem √≥culos"
          }
        ]
      },
      "total_funcionarios": 10,
      "total_embeddings": 50
    },
    "2": {
      "embeddings": {
        "456": [
          {
            "embedding": [0.789, 0.012, ...],
            "foto_id": 2,
            "descricao": "Frente com √≥culos"
          }
        ]
      },
      "total_funcionarios": 15,
      "total_embeddings": 75
    }
  }
}
```

---

### **TAREFA 2: Corrigir Fun√ß√£o de Gera√ß√£o do Cache**

No arquivo `gerar_cache_facial.py`, localizar a fun√ß√£o `gerar_cache_embeddings()`.

**SUBSTITUIR TODA A FUN√á√ÉO POR:**

```python
import os
import json
import tempfile
import base64
from datetime import datetime
from app import app, db
from models import Administrador, Funcionario, FotoFacialFuncionario
from ponto_views import gerar_embedding_otimizado
import logging

logger = logging.getLogger(__name__)

def gerar_cache_embeddings():
    """
    Gera cache de embeddings faciais para TODOS os tenants.
    Estrutura multi-tenant com isolamento correto.
    """
    print("üöÄ Iniciando gera√ß√£o de cache multi-tenant...")
    
    cache_path = '/tmp/cache_facial_embeddings.json'
    
    # Estrutura do cache
    cache_data = {
        'model': 'SFace',
        'generated_at': datetime.now().isoformat(),
        'tenants': {}
    }
    
    # Buscar TODOS os administradores (tenants)
    admins = Administrador.query.all()
    
    if not admins:
        print("‚ùå Nenhum administrador encontrado!")
        return
    
    print(f"üìä Encontrados {len(admins)} tenants")
    
    total_funcionarios_geral = 0
    total_embeddings_geral = 0
    
    # Processar cada tenant
    for admin in admins:
        admin_id = admin.id
        print(f"\n{'='*60}")
        print(f"üè¢ Processando tenant: {admin.nome} (ID: {admin_id})")
        print(f"{'='*60}")
        
        # Inicializar estrutura do tenant
        cache_data['tenants'][str(admin_id)] = {
            'embeddings': {},
            'total_funcionarios': 0,
            'total_embeddings': 0
        }
        
        # Buscar funcion√°rios ativos deste tenant
        funcionarios = Funcionario.query.filter_by(
            admin_id=admin_id,
            ativo=True
        ).all()
        
        if not funcionarios:
            print(f"‚ö†Ô∏è Nenhum funcion√°rio ativo para tenant {admin_id}")
            continue
        
        print(f"üë• Encontrados {len(funcionarios)} funcion√°rios ativos")
        
        funcionarios_processados = 0
        embeddings_processados = 0
        erros = 0
        
        # Processar cada funcion√°rio
        for funcionario in funcionarios:
            try:
                print(f"\nüì∏ Processando: {funcionario.nome} (ID: {funcionario.id})")
                
                # Buscar TODAS as fotos do funcion√°rio
                fotos = FotoFacialFuncionario.query.filter_by(
                    funcionario_id=funcionario.id,
                    ativa=True
                ).all()
                
                # Se n√£o tiver fotos na tabela de m√∫ltiplas fotos, usar foto principal
                if not fotos and funcionario.foto_base64:
                    print(f"   ‚ÑπÔ∏è Usando foto principal")
                    fotos = [{'base64': funcionario.foto_base64, 'descricao': 'Foto principal', 'id': 0}]
                elif fotos:
                    print(f"   ‚ÑπÔ∏è Encontradas {len(fotos)} fotos")
                    fotos = [{'base64': f.foto_base64, 'descricao': f.descricao, 'id': f.id} for f in fotos]
                else:
                    print(f"   ‚ö†Ô∏è Sem fotos cadastradas")
                    erros += 1
                    continue
                
                # Inicializar lista de embeddings do funcion√°rio
                func_embeddings = []
                
                # Processar cada foto
                for idx, foto_data in enumerate(fotos):
                    try:
                        foto_base64 = foto_data['base64']
                        foto_desc = foto_data['descricao']
                        foto_id = foto_data['id']
                        
                        # Remover prefixo data:image se existir
                        if ',' in foto_base64:
                            foto_base64 = foto_base64.split(',')[1]
                        
                        # Decodificar base64
                        foto_bytes = base64.b64decode(foto_base64)
                        
                        # Salvar em arquivo tempor√°rio
                        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
                            tmp.write(foto_bytes)
                            tmp_path = tmp.name
                        
                        # Gerar embedding usando fun√ß√£o otimizada
                        embedding = gerar_embedding_otimizado(tmp_path)
                        
                        # Remover arquivo tempor√°rio
                        os.unlink(tmp_path)
                        
                        if embedding is None or len(embedding) == 0:
                            print(f"   ‚ùå Falha ao gerar embedding para foto {idx+1}")
                            continue
                        
                        # Adicionar √† lista
                        func_embeddings.append({
                            'embedding': embedding,
                            'foto_id': foto_id,
                            'descricao': foto_desc
                        })
                        
                        print(f"   ‚úÖ Foto {idx+1}/{len(fotos)}: {foto_desc} ({len(embedding)} dim)")
                        
                    except Exception as e:
                        print(f"   ‚ùå Erro ao processar foto {idx+1}: {e}")
                        continue
                
                # Se conseguiu gerar pelo menos 1 embedding, salvar
                if func_embeddings:
                    cache_data['tenants'][str(admin_id)]['embeddings'][str(funcionario.id)] = func_embeddings
                    funcionarios_processados += 1
                    embeddings_processados += len(func_embeddings)
                    print(f"   ‚úÖ {funcionario.nome}: {len(func_embeddings)} embeddings salvos")
                else:
                    print(f"   ‚ùå {funcionario.nome}: Nenhum embedding gerado")
                    erros += 1
                    
            except Exception as e:
                print(f"   ‚ùå Erro ao processar {funcionario.nome}: {e}")
                erros += 1
                continue
        
        # Atualizar estat√≠sticas do tenant
        cache_data['tenants'][str(admin_id)]['total_funcionarios'] = funcionarios_processados
        cache_data['tenants'][str(admin_id)]['total_embeddings'] = embeddings_processados
        
        total_funcionarios_geral += funcionarios_processados
        total_embeddings_geral += embeddings_processados
        
        print(f"\nüìä Tenant {admin_id} - Resumo:")
        print(f"   ‚úÖ Funcion√°rios: {funcionarios_processados}/{len(funcionarios)}")
        print(f"   ‚úÖ Embeddings: {embeddings_processados}")
        print(f"   ‚ùå Erros: {erros}")
    
    # Salvar cache em arquivo
    try:
        with open(cache_path, 'w') as f:
            json.dump(cache_data, f)
        
        print(f"\n{'='*60}")
        print(f"‚úÖ CACHE GERADO COM SUCESSO!")
        print(f"{'='*60}")
        print(f"üìä Estat√≠sticas Gerais:")
        print(f"   üè¢ Tenants processados: {len(cache_data['tenants'])}")
        print(f"   üë• Total de funcion√°rios: {total_funcionarios_geral}")
        print(f"   üì∏ Total de embeddings: {total_embeddings_geral}")
        print(f"   üíæ Arquivo: {cache_path}")
        print(f"   üìè Tamanho: {os.path.getsize(cache_path) / 1024:.2f} KB")
        print(f"{'='*60}")
        
    except Exception as e:
        print(f"‚ùå Erro ao salvar cache: {e}")
        return
```

---

### **TAREFA 3: Corrigir Fun√ß√£o de Carregar Cache**

No arquivo `ponto_views.py`, localizar a fun√ß√£o `carregar_cache_facial()`.

**SUBSTITUIR POR:**

```python
def carregar_cache_facial():
    """
    Carrega cache de embeddings do arquivo.
    Retorna estrutura multi-tenant completa.
    """
    global _cache_facial
    
    cache_path = '/tmp/cache_facial_embeddings.json'
    
    if not os.path.exists(cache_path):
        logger.warning(f"‚ö†Ô∏è Arquivo de cache n√£o existe: {cache_path}")
        return None
    
    try:
        with open(cache_path, 'r') as f:
            cache = json.load(f)
        
        _cache_facial = cache
        
        # Estat√≠sticas
        total_tenants = len(cache.get('tenants', {}))
        total_func = sum(t.get('total_funcionarios', 0) for t in cache.get('tenants', {}).values())
        total_emb = sum(t.get('total_embeddings', 0) for t in cache.get('tenants', {}).values())
        
        logger.info(f"‚úÖ Cache carregado: {total_tenants} tenants, {total_func} func., {total_emb} embeddings")
        logger.info(f"üìÖ Gerado em: {cache.get('generated_at', 'desconhecido')}")
        
        return cache
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao carregar cache: {e}")
        return None
```

---

### **TAREFA 4: Corrigir Fun√ß√£o de Identifica√ß√£o por Cache**

No arquivo `ponto_views.py`, localizar a fun√ß√£o `identificar_por_cache()`.

**LOCALIZAR a parte que carrega o cache:**

```python
cache = carregar_cache_facial()
if not cache:
    return None, None, "Cache n√£o dispon√≠vel"
```

**SUBSTITUIR POR:**

```python
cache = carregar_cache_facial()
if not cache:
    return None, None, "Cache n√£o dispon√≠vel"

# Filtrar embeddings do tenant correto
tenant_cache = cache.get('tenants', {}).get(str(admin_id))

if not tenant_cache:
    logger.warning(f"‚ö†Ô∏è Nenhum embedding no cache para tenant {admin_id}")
    return None, None, f"Nenhum embedding no cache para este tenant"

embeddings_tenant = tenant_cache.get('embeddings', {})

if not embeddings_tenant:
    logger.warning(f"‚ö†Ô∏è Cache vazio para tenant {admin_id}")
    return None, None, f"Cache vazio para este tenant"

logger.info(f"‚úÖ Cache: {len(embeddings_tenant)} funcion√°rios para tenant {admin_id}")
```

**LOCALIZAR o loop de compara√ß√£o:**

```python
for func_id, fotos_data in cache.items():
```

**SUBSTITUIR POR:**

```python
for func_id, fotos_data in embeddings_tenant.items():
```

---

### **TAREFA 5: Adicionar Comando Flask CLI**

No arquivo `app.py` ou onde est√£o os comandos Flask:

**ADICIONAR:**

```python
@app.cli.command('gerar-cache-embeddings')
def gerar_cache_cli():
    """Gera cache de embeddings faciais para todos os tenants"""
    from gerar_cache_facial import gerar_cache_embeddings
    
    with app.app_context():
        gerar_cache_embeddings()

@app.cli.command('limpar-cache-embeddings')
def limpar_cache_cli():
    """Limpa o cache de embeddings faciais"""
    cache_path = '/tmp/cache_facial_embeddings.json'
    
    if os.path.exists(cache_path):
        os.remove(cache_path)
        print("‚úÖ Cache limpo com sucesso!")
    else:
        print("‚ö†Ô∏è Cache n√£o existe")

@app.cli.command('status-cache-embeddings')
def status_cache_cli():
    """Mostra status do cache de embeddings"""
    cache_path = '/tmp/cache_facial_embeddings.json'
    
    if not os.path.exists(cache_path):
        print("‚ùå Cache n√£o existe!")
        return
    
    try:
        with open(cache_path, 'r') as f:
            cache = json.load(f)
        
        print(f"\n{'='*60}")
        print(f"üìä STATUS DO CACHE")
        print(f"{'='*60}")
        print(f"üìÖ Gerado em: {cache.get('generated_at', 'desconhecido')}")
        print(f"ü§ñ Modelo: {cache.get('model', 'desconhecido')}")
        print(f"üè¢ Tenants: {len(cache.get('tenants', {}))}")
        print(f"\n{'='*60}")
        
        for tenant_id, tenant_data in cache.get('tenants', {}).items():
            print(f"Tenant {tenant_id}:")
            print(f"   üë• Funcion√°rios: {tenant_data.get('total_funcionarios', 0)}")
            print(f"   üì∏ Embeddings: {tenant_data.get('total_embeddings', 0)}")
        
        print(f"{'='*60}\n")
        
    except Exception as e:
        print(f"‚ùå Erro ao ler cache: {e}")
```

---

## üìä RESULTADO ESPERADO:

### **Gerar Cache:**

```bash
$ flask gerar-cache-embeddings

üöÄ Iniciando gera√ß√£o de cache multi-tenant...
üìä Encontrados 2 tenants

============================================================
üè¢ Processando tenant: Empresa A (ID: 1)
============================================================
üë• Encontrados 10 funcion√°rios ativos
üì∏ Processando: Jo√£o Silva (ID: 123)
   ‚úÖ Foto 1/3: Frente sem √≥culos (128 dim)
   ‚úÖ Foto 2/3: Frente com √≥culos (128 dim)
   ‚úÖ Foto 3/3: Perfil esquerdo (128 dim)
   ‚úÖ Jo√£o Silva: 3 embeddings salvos
...

============================================================
üè¢ Processando tenant: Empresa B (ID: 2)
============================================================
üë• Encontrados 15 funcion√°rios ativos
üì∏ Processando: Maria Santos (ID: 456)
   ‚úÖ Foto 1/5: Frente sem √≥culos (128 dim)
   ‚úÖ Foto 2/5: Frente com √≥culos (128 dim)
   ...
   ‚úÖ Maria Santos: 5 embeddings salvos
...

============================================================
‚úÖ CACHE GERADO COM SUCESSO!
============================================================
üìä Estat√≠sticas Gerais:
   üè¢ Tenants processados: 2
   üë• Total de funcion√°rios: 25
   üì∏ Total de embeddings: 125
   üíæ Arquivo: /tmp/cache_facial_embeddings.json
   üìè Tamanho: 245.67 KB
============================================================
```

### **Verificar Status:**

```bash
$ flask status-cache-embeddings

============================================================
üìä STATUS DO CACHE
============================================================
üìÖ Gerado em: 2026-02-05T10:30:00
ü§ñ Modelo: SFace
üè¢ Tenants: 2

============================================================
Tenant 1:
   üë• Funcion√°rios: 10
   üì∏ Embeddings: 50
Tenant 2:
   üë• Funcion√°rios: 15
   üì∏ Embeddings: 75
============================================================
```

### **Reconhecimento (ap√≥s gerar cache):**

```
‚úÖ Cache: 15 funcion√°rios para tenant 2
‚úÖ Match: func=456, dist=0.2513 < 0.4
‚è±Ô∏è TEMPO TOTAL: 0.5s ‚ö°
```

---

## üöÄ COMO USAR:

### **PASSO 1: Implementar**
```
Cole o prompt no Replit Agent
‚Üí Ele vai corrigir toda a estrutura multi-tenant
```

### **PASSO 2: Deploy**
```
Commit + Push + Deploy no Easypanel
Restart do servi√ßo
```

### **PASSO 3: Gerar Cache**
```bash
flask limpar-cache-embeddings  # Limpar cache antigo
flask gerar-cache-embeddings   # Gerar cache novo
flask status-cache-embeddings  # Verificar
```

### **PASSO 4: Testar**
```
Acesse o ponto facial
Registre um ponto
Deve reconhecer em < 1 segundo! ‚ö°
```

---

## üí° DIFEREN√áA PRINCIPAL:

### **ANTES (errado):**
```json
{
  "embeddings": {
    "123": [...],  // Sem separa√ß√£o por tenant!
    "456": [...]
  }
}
```

### **DEPOIS (correto):**
```json
{
  "tenants": {
    "1": {
      "embeddings": {"123": [...]}
    },
    "2": {
      "embeddings": {"456": [...]}
    }
  }
}
```

**Agora cada tenant tem seus embeddings isolados!** üîí

---

**Cole o prompt no Replit Agent e depois execute os comandos Flask!** üöÄ
