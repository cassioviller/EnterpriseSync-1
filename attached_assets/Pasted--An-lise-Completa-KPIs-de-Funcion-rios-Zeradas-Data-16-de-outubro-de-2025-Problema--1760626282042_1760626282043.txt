# An√°lise Completa - KPIs de Funcion√°rios Zeradas

**Data:** 16 de outubro de 2025  
**Problema:** KPIs mostram R$ 0.00 e 0.0h apesar de ter 21 funcion√°rios ativos  
**Causa Raiz:** Incompatibilidade entre lan√ßamentos manuais e sistema de ponto automatizado

---

## üîç PROBLEMA IDENTIFICADO

### Sintomas:
- ‚úÖ **Funcion√°rios Ativos:** 21 (OK - est√° contando corretamente)
- ‚ùå **Custo Total:** R$ 0.00 (ERRADO - deveria mostrar soma dos custos)
- ‚ùå **Total de Horas:** 0.0h (ERRADO - deveria mostrar horas trabalhadas)
- ‚ùå **Faltas Justificadas:** 0 dias / R$ 0.00 (ERRADO)
- ‚ùå **Faltas Normais:** 0 dias (ERRADO)
- ‚ùå **Taxa de Absente√≠smo:** 0.0% (ERRADO)
- ‚ùå **Total de Faltas:** 0 dias (ERRADO)

---

## üéØ CAUSA RAIZ IDENTIFICADA

### An√°lise do C√≥digo (views.py, linhas 1305-1324):

```python
# Linha 1305-1309: Busca registros de ponto
registros = RegistroPonto.query.filter(
    RegistroPonto.funcionario_id == func.id,
    RegistroPonto.data >= data_inicio,
    RegistroPonto.data <= data_fim
).all()

# Linha 1311-1314: Calcula KPIs baseado nos registros
total_horas = sum(r.horas_trabalhadas or 0 for r in registros)  # ‚ùå PROBLEMA 1
total_extras = sum(r.horas_extras or 0 for r in registros)
total_faltas = len([r for r in registros if r.tipo_registro == 'falta'])  # ‚ùå PROBLEMA 2
total_faltas_justificadas = len([r for r in registros if r.tipo_registro == 'falta_justificada'])

# Linha 1323: Calcula custo total
'custo_total': (total_horas + total_extras * 1.5) * (func.salario / 220 if func.salario else 0)  # ‚ùå PROBLEMA 3
```

---

## üö® 3 PROBLEMAS CR√çTICOS IDENTIFICADOS

### PROBLEMA 1: Campo `horas_trabalhadas` Vazio

**O que acontece:**
- O c√≥digo soma `r.horas_trabalhadas` dos registros
- Se voc√™ fez lan√ßamentos manuais, provavelmente preencheu apenas `hora_entrada` e `hora_saida`
- O campo `horas_trabalhadas` n√£o foi calculado automaticamente nos lan√ßamentos antigos
- Resultado: `sum(r.horas_trabalhadas or 0 for r in registros)` = 0

**Evid√™ncia:**
```python
# Estrutura do modelo RegistroPonto
hora_entrada = db.Column(db.Time)
hora_saida = db.Column(db.Time)
horas_trabalhadas = db.Column(db.Float, default=0.0)  # ‚ùå Pode estar vazio!
```

---

### PROBLEMA 2: Campo `tipo_registro` Incorreto

**O que acontece:**
- O c√≥digo filtra faltas por `r.tipo_registro == 'falta'`
- Lan√ßamentos manuais podem ter `tipo_registro = 'trabalhado'` (padr√£o)
- Ou podem ter `tipo_registro = None` se n√£o foi preenchido
- Resultado: Faltas n√£o s√£o contadas

**Valores poss√≠veis:**
- `'trabalhado'` (padr√£o)
- `'falta'`
- `'falta_justificada'`
- `'feriado'`
- `'feriado_trabalhado'`
- `'sabado_horas_extras'`
- `'domingo_horas_extras'`

---

### PROBLEMA 3: Valor/Hora Fixo (220h) - J√Å IDENTIFICADO

**O que acontece:**
- Mesmo que as horas fossem calculadas, o custo estaria errado
- Usa divisor fixo de 220h ao inv√©s de calcular corretamente

```python
# ‚ùå ERRADO
func.salario / 220

# ‚úÖ CORRETO
calcular_valor_hora(func.salario, func.jornada_semanal)
```

---

## üí° SOLU√á√ïES

### SOLU√á√ÉO 1: Recalcular `horas_trabalhadas` dos Registros Existentes

**Op√ß√£o A: Script de Migra√ß√£o (Recomendado)**

Criar um script que recalcula `horas_trabalhadas` para todos os registros que t√™m `hora_entrada` e `hora_saida` mas `horas_trabalhadas = 0`:

```python
# migration_recalcular_horas.py
from app import create_app, db
from models import RegistroPonto
from datetime import datetime, timedelta

app = create_app()

def calcular_horas_trabalhadas(entrada, saida, almoco_saida=None, almoco_retorno=None):
    """Calcula horas trabalhadas considerando intervalo de almo√ßo"""
    if not entrada or not saida:
        return 0.0
    
    # Converte time para datetime para fazer c√°lculos
    hoje = datetime.today().date()
    dt_entrada = datetime.combine(hoje, entrada)
    dt_saida = datetime.combine(hoje, saida)
    
    # Se sa√≠da √© antes da entrada, assumir que passou da meia-noite
    if dt_saida < dt_entrada:
        dt_saida += timedelta(days=1)
    
    # Calcula total de horas
    total = (dt_saida - dt_entrada).total_seconds() / 3600
    
    # Desconta intervalo de almo√ßo se houver
    if almoco_saida and almoco_retorno:
        dt_almoco_saida = datetime.combine(hoje, almoco_saida)
        dt_almoco_retorno = datetime.combine(hoje, almoco_retorno)
        
        if dt_almoco_retorno < dt_almoco_saida:
            dt_almoco_retorno += timedelta(days=1)
        
        intervalo_almoco = (dt_almoco_retorno - dt_almoco_saida).total_seconds() / 3600
        total -= intervalo_almoco
    else:
        # Desconta 1h de almo√ßo padr√£o se trabalhou mais de 6h
        if total > 6:
            total -= 1
    
    return round(total, 2)

with app.app_context():
    # Busca todos os registros com horas_trabalhadas = 0 mas que t√™m entrada/sa√≠da
    registros = RegistroPonto.query.filter(
        RegistroPonto.horas_trabalhadas == 0,
        RegistroPonto.hora_entrada.isnot(None),
        RegistroPonto.hora_saida.isnot(None)
    ).all()
    
    print(f"Encontrados {len(registros)} registros para recalcular")
    
    contador = 0
    for registro in registros:
        horas = calcular_horas_trabalhadas(
            registro.hora_entrada,
            registro.hora_saida,
            registro.hora_almoco_saida,
            registro.hora_almoco_retorno
        )
        
        registro.horas_trabalhadas = horas
        contador += 1
        
        if contador % 100 == 0:
            print(f"Processados {contador} registros...")
    
    db.session.commit()
    print(f"‚úÖ {contador} registros atualizados com sucesso!")
```

**Como executar:**
1. Salvar o script como `migration_recalcular_horas.py`
2. Executar: `python3.11 migration_recalcular_horas.py`
3. Verificar logs
4. Recarregar p√°gina de funcion√°rios

---

**Op√ß√£o B: Calcular em Tempo Real (Alternativa)**

Modificar a fun√ß√£o `funcionarios()` para calcular horas mesmo se o campo estiver vazio:

```python
# views.py, linha 1311
# ANTES (INCORRETO):
total_horas = sum(r.horas_trabalhadas or 0 for r in registros)

# DEPOIS (CORRETO):
total_horas = 0
for r in registros:
    if r.horas_trabalhadas and r.horas_trabalhadas > 0:
        # Usa o valor j√° calculado
        total_horas += r.horas_trabalhadas
    elif r.hora_entrada and r.hora_saida:
        # Calcula em tempo real se n√£o tiver valor
        horas = calcular_horas_trabalhadas(
            r.hora_entrada,
            r.hora_saida,
            r.hora_almoco_saida,
            r.hora_almoco_retorno
        )
        total_horas += horas
```

---

### SOLU√á√ÉO 2: Corrigir Detec√ß√£o de Faltas

**Problema:** Faltas podem n√£o ter `tipo_registro` correto

**Solu√ß√£o:** Detectar faltas de m√∫ltiplas formas:

```python
# views.py, linha 1313-1314
# ANTES (INCORRETO):
total_faltas = len([r for r in registros if r.tipo_registro == 'falta'])
total_faltas_justificadas = len([r for r in registros if r.tipo_registro == 'falta_justificada'])

# DEPOIS (CORRETO):
total_faltas = 0
total_faltas_justificadas = 0

for r in registros:
    # Detecta falta de 3 formas:
    # 1. tipo_registro expl√≠cito
    # 2. horas_trabalhadas = 0 e n√£o √© feriado
    # 3. sem entrada/sa√≠da em dia √∫til
    
    if r.tipo_registro == 'falta':
        total_faltas += 1
    elif r.tipo_registro == 'falta_justificada':
        total_faltas_justificadas += 1
    elif (r.horas_trabalhadas == 0 and 
          not r.hora_entrada and 
          not r.hora_saida and
          r.data.weekday() < 5 and  # Segunda a sexta
          r.tipo_registro not in ['feriado', 'feriado_trabalhado']):
        # Provavelmente √© falta n√£o marcada
        # Verificar se √© justificada pela observa√ß√£o
        if r.observacoes and 'justificad' in r.observacoes.lower():
            total_faltas_justificadas += 1
        else:
            total_faltas += 1
```

---

### SOLU√á√ÉO 3: Corrigir C√°lculo de Valor/Hora (J√Å IDENTIFICADO)

```python
# views.py, linha 1323
# ANTES (INCORRETO):
'custo_total': (total_horas + total_extras * 1.5) * (func.salario / 220 if func.salario else 0)

# DEPOIS (CORRETO):
from utils import calcular_valor_hora

valor_hora = calcular_valor_hora(
    salario=func.salario,
    jornada_semanal=func.jornada_semanal
) if func.salario else 0

'custo_total': (total_horas + total_extras * 1.5) * valor_hora
```

---

### SOLU√á√ÉO 4: Adicionar Fallback para Per√≠odo sem Registros

**Problema:** Se n√£o h√° registros de ponto, as KPIs ficam zeradas mesmo tendo funcion√°rios

**Solu√ß√£o:** Mostrar custo estimado baseado no sal√°rio:

```python
# views.py, ap√≥s linha 1324
if len(registros) == 0 and func.salario:
    # Se n√£o h√° registros, estimar baseado no sal√°rio mensal
    from utils import calcular_dias_uteis_mes
    
    dias_uteis = calcular_dias_uteis_mes(
        data_inicio.year,
        data_inicio.month
    )
    
    horas_estimadas = dias_uteis * (func.jornada_semanal / 5)  # Horas por dia
    
    funcionarios_kpis.append({
        'funcionario': func,
        'horas_trabalhadas': horas_estimadas,
        'total_horas': horas_estimadas,
        'total_extras': 0,
        'total_faltas': 0,
        'total_faltas_justificadas': 0,
        'custo_total': func.salario,  # Custo = sal√°rio mensal
        'estimado': True  # Flag para mostrar que √© estimativa
    })
else:
    # C√≥digo existente...
```

---

## üéØ PROMPT PARA REPLIT AGENT

```markdown
**CONTEXTO:**

Sistema SIGE v8.0 - P√°gina de Funcion√°rios mostrando KPIs zeradas (R$ 0.00, 0.0h) apesar de ter 21 funcion√°rios ativos.

**CAUSA RAIZ IDENTIFICADA:**

1. **Campo `horas_trabalhadas` vazio:** Lan√ßamentos manuais antigos t√™m `hora_entrada` e `hora_saida`, mas `horas_trabalhadas = 0`
2. **Campo `tipo_registro` incorreto:** Faltas n√£o s√£o detectadas porque `tipo_registro` n√£o foi preenchido
3. **Valor/hora fixo:** Usa divisor 220h ao inv√©s de calcular corretamente

**ARQUIVOS A MODIFICAR:**

1. `views.py` - Fun√ß√£o `funcionarios()` (linhas 1305-1350)
2. Criar novo arquivo: `migration_recalcular_horas.py`

---

## CORRE√á√ÉO 1: Criar Script de Migra√ß√£o

**Criar arquivo:** `migration_recalcular_horas.py`

```python
from app import create_app, db
from models import RegistroPonto
from datetime import datetime, timedelta

app = create_app()

def calcular_horas_trabalhadas(entrada, saida, almoco_saida=None, almoco_retorno=None):
    """Calcula horas trabalhadas considerando intervalo de almo√ßo"""
    if not entrada or not saida:
        return 0.0
    
    # Converte time para datetime para fazer c√°lculos
    hoje = datetime.today().date()
    dt_entrada = datetime.combine(hoje, entrada)
    dt_saida = datetime.combine(hoje, saida)
    
    # Se sa√≠da √© antes da entrada, assumir que passou da meia-noite
    if dt_saida < dt_entrada:
        dt_saida += timedelta(days=1)
    
    # Calcula total de horas
    total = (dt_saida - dt_entrada).total_seconds() / 3600
    
    # Desconta intervalo de almo√ßo se houver
    if almoco_saida and almoco_retorno:
        dt_almoco_saida = datetime.combine(hoje, almoco_saida)
        dt_almoco_retorno = datetime.combine(hoje, almoco_retorno)
        
        if dt_almoco_retorno < dt_almoco_saida:
            dt_almoco_retorno += timedelta(days=1)
        
        intervalo_almoco = (dt_almoco_retorno - dt_almoco_saida).total_seconds() / 3600
        total -= intervalo_almoco
    else:
        # Desconta 1h de almo√ßo padr√£o se trabalhou mais de 6h
        if total > 6:
            total -= 1
    
    return round(total, 2)

with app.app_context():
    # Busca todos os registros com horas_trabalhadas = 0 mas que t√™m entrada/sa√≠da
    registros = RegistroPonto.query.filter(
        RegistroPonto.horas_trabalhadas == 0,
        RegistroPonto.hora_entrada.isnot(None),
        RegistroPonto.hora_saida.isnot(None)
    ).all()
    
    print(f"Encontrados {len(registros)} registros para recalcular")
    
    contador = 0
    for registro in registros:
        horas = calcular_horas_trabalhadas(
            registro.hora_entrada,
            registro.hora_saida,
            registro.hora_almoco_saida,
            registro.hora_almoco_retorno
        )
        
        registro.horas_trabalhadas = horas
        contador += 1
        
        if contador % 100 == 0:
            print(f"Processados {contador} registros...")
    
    db.session.commit()
    print(f"‚úÖ {contador} registros atualizados com sucesso!")
```

---

## CORRE√á√ÉO 2: Modificar Fun√ß√£o funcionarios() em views.py

**Localiza√ß√£o:** `views.py`, linhas 1305-1350

**MODIFICA√á√ÉO 1 - Calcular horas em tempo real se necess√°rio:**

**ANTES (linha 1311):**
```python
total_horas = sum(r.horas_trabalhadas or 0 for r in registros)
```

**DEPOIS:**
```python
# Importar fun√ß√£o auxiliar no topo do arquivo
from utils import calcular_valor_hora, calcular_dias_uteis_mes

# Calcular horas (usa valor salvo ou calcula em tempo real)
total_horas = 0
for r in registros:
    if r.horas_trabalhadas and r.horas_trabalhadas > 0:
        total_horas += r.horas_trabalhadas
    elif r.hora_entrada and r.hora_saida:
        # Calcula em tempo real se n√£o tiver valor
        hoje = datetime.today().date()
        dt_entrada = datetime.combine(hoje, r.hora_entrada)
        dt_saida = datetime.combine(hoje, r.hora_saida)
        
        if dt_saida < dt_entrada:
            dt_saida += timedelta(days=1)
        
        horas = (dt_saida - dt_entrada).total_seconds() / 3600
        
        # Desconta 1h de almo√ßo se trabalhou mais de 6h
        if horas > 6:
            horas -= 1
        
        total_horas += horas
```

---

**MODIFICA√á√ÉO 2 - Detectar faltas de m√∫ltiplas formas:**

**ANTES (linhas 1313-1314):**
```python
total_faltas = len([r for r in registros if r.tipo_registro == 'falta'])
total_faltas_justificadas = len([r for r in registros if r.tipo_registro == 'falta_justificada'])
```

**DEPOIS:**
```python
total_faltas = 0
total_faltas_justificadas = 0

for r in registros:
    if r.tipo_registro == 'falta':
        total_faltas += 1
    elif r.tipo_registro == 'falta_justificada':
        total_faltas_justificadas += 1
    elif (r.horas_trabalhadas == 0 and 
          not r.hora_entrada and 
          not r.hora_saida and
          r.data.weekday() < 5 and
          r.tipo_registro not in ['feriado', 'feriado_trabalhado']):
        # Falta n√£o marcada explicitamente
        if r.observacoes and 'justificad' in r.observacoes.lower():
            total_faltas_justificadas += 1
        else:
            total_faltas += 1
```

---

**MODIFICA√á√ÉO 3 - Corrigir c√°lculo de valor/hora:**

**ANTES (linha 1323):**
```python
'custo_total': (total_horas + total_extras * 1.5) * (func.salario / 220 if func.salario else 0)
```

**DEPOIS:**
```python
# Calcula valor/hora correto baseado na jornada
valor_hora = calcular_valor_hora(
    salario=func.salario,
    jornada_semanal=func.jornada_semanal
) if func.salario else 0

'custo_total': (total_horas + total_extras * 1.5) * valor_hora
```

---

**MODIFICA√á√ÉO 4 - Adicionar fallback para per√≠odo sem registros:**

**ADICIONAR ap√≥s linha 1335 (dentro do except):**

```python
# Se n√£o h√° registros mas funcion√°rio tem sal√°rio, estimar custo
if len(registros) == 0 and func.salario:
    dias_uteis = calcular_dias_uteis_mes(
        data_inicio.year,
        data_inicio.month
    )
    
    horas_estimadas = dias_uteis * (func.jornada_semanal / 5) if func.jornada_semanal else dias_uteis * 8
    
    funcionarios_kpis.append({
        'funcionario': func,
        'horas_trabalhadas': horas_estimadas,
        'total_horas': horas_estimadas,
        'total_extras': 0,
        'total_faltas': 0,
        'total_faltas_justificadas': 0,
        'custo_total': func.salario,
        'estimado': True
    })
else:
    # C√≥digo existente (linhas 1316-1335)
    ...
```

---

## VALIDA√á√ÉO

Ap√≥s implementar as corre√ß√µes:

1. **Executar script de migra√ß√£o:**
   ```bash
   python3.11 migration_recalcular_horas.py
   ```

2. **Verificar logs:**
   - Deve mostrar quantos registros foram atualizados
   - Ex: "‚úÖ 1.523 registros atualizados com sucesso!"

3. **Recarregar p√°gina de funcion√°rios:**
   - Custo Total deve mostrar valor > R$ 0.00
   - Total de Horas deve mostrar valor > 0.0h
   - Faltas devem ser contadas corretamente

4. **Testar com diferentes per√≠odos:**
   - M√™s Atual
   - √öltimo M√™s
   - 3 Meses
   - Ano Atual

5. **Verificar KPIs individuais:**
   - Clicar em um funcion√°rio
   - Verificar se horas e custos aparecem

---

## RESULTADO ESPERADO

**ANTES:**
```
Funcion√°rios Ativos: 21
Custo Total: R$ 0.00          ‚ùå
Total de Horas: 0.0h          ‚ùå
Faltas Justificadas: 0 dias   ‚ùå
Taxa de Absente√≠smo: 0.0%     ‚ùå
```

**DEPOIS:**
```
Funcion√°rios Ativos: 21
Custo Total: R$ 45.320,00     ‚úÖ
Total de Horas: 3.528h        ‚úÖ
Faltas Justificadas: 12 dias  ‚úÖ
Taxa de Absente√≠smo: 2.3%     ‚úÖ
```

---

## PRIORIDADE

üî¥ **ALTA** - Funcionalidade cr√≠tica para gest√£o de RH

**Tempo Estimado:** 1-2 horas (incluindo testes)
```

---

## üìä RESUMO T√âCNICO

### Problemas:
1. ‚úÖ Campo `horas_trabalhadas` vazio em lan√ßamentos antigos
2. ‚úÖ Campo `tipo_registro` n√£o preenchido corretamente
3. ‚úÖ Valor/hora fixo 220h (erro sist√™mico)
4. ‚úÖ Sem fallback para per√≠odos sem registros

### Solu√ß√µes:
1. ‚úÖ Script de migra√ß√£o para recalcular horas
2. ‚úÖ C√°lculo em tempo real como fallback
3. ‚úÖ Detec√ß√£o inteligente de faltas
4. ‚úÖ Uso de `calcular_valor_hora()` correto
5. ‚úÖ Estimativa baseada em sal√°rio quando n√£o h√° registros

### Impacto:
- üéØ KPIs voltam a funcionar corretamente
- üìä Dados hist√≥ricos s√£o preservados e recalculados
- ‚úÖ Sistema fica robusto para lan√ßamentos futuros

