
## Prompt para Replit Agent: Implementar Sistema de Relatórios Funcionais

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask para o backend, SQLAlchemy para ORM e interação com PostgreSQL, Bootstrap 5 para o frontend e utiliza Docker/EasyPanel para deploy. O sistema já possui uma estrutura de relatórios em `templates/relatorios.html`, mas os links para os relatórios específicos não estão funcionais e não há integração com o backend para exibição dos dados.

**Papel do Replit Agent:**
Como um engenheiro de frontend e backend, sua tarefa é tornar os links dos relatórios funcionais e integrar a exibição dos dados com as rotas de backend.

**Tarefa específica:**
Implementar a funcionalidade completa para o "Sistema de Relatórios Dinâmicos" conforme descrito no `pasted_content.txt`. Isso inclui:
1.  **Ativar os links** presentes em `templates/relatorios.html` para os relatórios pendentes (Lista de Funcionários, Relatório de Ponto, Horas Extras, Relatório de Alimentação, Relatórios de Obras, Relatórios Financeiros).
2.  **Criar ou ajustar as rotas de backend** (Flask) necessárias para cada um desses relatórios, garantindo que elas busquem os dados apropriados do banco de dados PostgreSQL via SQLAlchemy.
3.  **Renderizar os dados** na interface do usuário de forma tabular ou gráfica, utilizando o Bootstrap 5 para a estilização.
4.  Garantir que a interface `templates/relatorios.html` exiba os dados corretamente ao clicar nos links.

**Critérios de aceitação:**
-   Os links para cada relatório em `templates/relatorios.html` devem ser clicáveis e levar a uma página que exiba os dados correspondentes.
-   Cada relatório deve exibir dados reais do banco de dados, conforme a descrição do relatório (ex: "Lista de Funcionários (filtrada)" deve listar funcionários, "Relatório de Ponto (consolidado)" deve mostrar dados de ponto).
-   As rotas de backend devem estar devidamente configuradas no Flask para servir os dados de cada relatório.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e Bootstrap 5.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao acessar os relatórios.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Acessar a página de relatórios no navegador (ex: `http://localhost:5000/relatorios`).
2.  Clicar em um dos links de relatório (ex: "Lista de Funcionários").
3.  Ver a página do relatório carregar com os dados relevantes exibidos na tela.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
# Ou, se usar gunicorn/waitress
gunicorn app:app
```

**Validação:**
Navegar até a página de relatórios e verificar se todos os links estão ativos e exibindo os dados corretos.



## Prompt para Replit Agent: Implementar Exportação de Relatórios em PDF/Excel

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema possui apenas exportação CSV no perfil do funcionário, mas é necessário implementar a exportação de relatórios em múltiplos formatos (PDF/Excel).

**Papel do Replit Agent:**
Como um engenheiro de backend e frontend, sua tarefa é adicionar a funcionalidade de exportação de relatórios para PDF e Excel para os relatórios existentes e futuros.

**Tarefa específica:**
Implementar a funcionalidade de exportação de dados para PDF e Excel para os relatórios do sistema. Isso inclui:
1.  **Adicionar botões de exportação** (PDF e Excel) nas páginas de relatórios onde a exportação é relevante.
2.  **Criar rotas de backend (Flask)** que, ao serem acessadas, gerem o arquivo PDF ou Excel com os dados do relatório correspondente.
3.  **Utilizar bibliotecas Python apropriadas** para a geração de PDF (ex: `ReportLab`, `fpdf2`) e Excel (ex: `openpyxl`, `pandas`).
4.  Garantir que os dados exportados correspondam exatamente aos dados exibidos no relatório.

**Critérios de aceitação:**
-   Botões de exportação para PDF e Excel devem estar visíveis e funcionais nas páginas de relatório.
-   Ao clicar nos botões, um arquivo PDF ou Excel deve ser gerado e baixado pelo navegador, contendo os dados do relatório.
-   O formato dos arquivos gerados (PDF e Excel) deve ser legível e bem estruturado.
-   O código deve seguir as melhores práticas de Flask e das bibliotecas de exportação utilizadas.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor durante a exportação.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Acessar uma página de relatório (ex: `http://localhost:5000/relatorios/funcionarios`).
2.  Clicar no botão "Exportar para PDF" ou "Exportar para Excel".
3.  O navegador deve iniciar o download do arquivo gerado.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para instalar bibliotecas necessárias (se ainda não estiverem instaladas)
pip install fpdf2 openpyxl pandas
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Navegar até as páginas de relatório, clicar nos botões de exportação e verificar se os arquivos são gerados corretamente e contêm os dados esperados.



## Prompt para Replit Agent: Implementar Modal de Ocorrências em Funcionário

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. O módulo de funcionários possui um modal de ocorrências (`templates/funcionario_perfil.html`) que está incompleto, com estrutura parcial e falta de integração completa.

**Papel do Replit Agent:**
Como um engenheiro de frontend e backend, sua tarefa é completar a implementação do modal de ocorrências para funcionários, garantindo sua funcionalidade e integração com o sistema.

**Tarefa específica:**
Completar a implementação do "Modal de Ocorrências em Funcionário" em `templates/funcionario_perfil.html`. Isso inclui:
1.  **Finalizar a estrutura do formulário** dentro do modal, garantindo que todos os campos necessários para registrar uma ocorrência estejam presentes (ex: tipo de ocorrência, descrição, data, funcionário relacionado).
2.  **Implementar a lógica de frontend** para abrir e fechar o modal, capturar os dados do formulário e enviá-los para o backend.
3.  **Criar ou ajustar a rota de backend (Flask)** para receber os dados da ocorrência, validá-los e persistir no banco de dados PostgreSQL via SQLAlchemy.
4.  **Associar a ocorrência ao funcionário** correto no banco de dados.
5.  **Exibir as ocorrências registradas** para o funcionário em questão na página de perfil, possivelmente em uma tabela ou lista dentro do próprio modal ou na página.

**Critérios de aceitação:**
-   O modal de ocorrências deve abrir e fechar corretamente na página de perfil do funcionário.
-   É possível preencher e submeter uma nova ocorrência através do modal.
-   A ocorrência submetida deve ser salva no banco de dados e associada ao funcionário correto.
-   As ocorrências existentes devem ser exibidas na página de perfil do funcionário.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e Bootstrap 5.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com o modal.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Acessar o perfil de um funcionário (ex: `http://localhost:5000/funcionarios/1`).
2.  Clicar em um botão para abrir o modal de ocorrências.
3.  Preencher o formulário de ocorrência e clicar em salvar.
4.  Ver a nova ocorrência listada no perfil do funcionário.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Navegar até o perfil de um funcionário, testar a abertura e submissão do modal de ocorrências, e verificar se a ocorrência é persistida e exibida corretamente.



## Prompt para Replit Agent: Implementar KPIs de Alta Prioridade

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. O sistema de KPIs está bem estruturado, mas alguns KPIs de alta prioridade, como "Taxa de Pontualidade" e "Eficiência de Trabalho", ainda não estão completamente implementados ou exibidos.

**Papel do Replit Agent:**
Como um engenheiro de backend e cientista de dados, sua tarefa é implementar e exibir os KPIs de alta prioridade, garantindo que os cálculos estejam corretos e que os dados sejam apresentados de forma clara na interface.

**Tarefa específica:**
Implementar os seguintes KPIs de alta prioridade, conforme descrito no `pasted_content.txt`:
1.  **Taxa de Pontualidade**: Calcular o percentual de dias sem atraso para cada funcionário ou para a equipe.
2.  **Eficiência de Trabalho**: Calcular as horas produtivas vs. horas pagas para cada funcionário.
3.  **Custo por Hora Produtiva**: Calcular o custo total dividido pelas horas efetivamente trabalhadas.

Para cada KPI:
-   **Criar ou ajustar a lógica de cálculo** no backend (Python/Flask), utilizando os dados existentes no banco de dados PostgreSQL via SQLAlchemy.
-   **Integrar os cálculos** com o módulo de KPIs existente (`relatorio_kpis_funcionarios.py` ou similar).
-   **Exibir os resultados** desses KPIs em dashboards ou relatórios relevantes no frontend, utilizando Bootstrap 5 para a apresentação.

**Critérios de aceitação:**
-   Os KPIs de Taxa de Pontualidade, Eficiência de Trabalho e Custo por Hora Produtiva devem ser calculados corretamente com base nos dados do sistema.
-   Os valores dos KPIs devem ser exibidos em uma seção apropriada do dashboard principal ou em relatórios específicos.
-   A apresentação dos KPIs deve ser clara e fácil de entender para o usuário.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e Python para análise de dados.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao acessar as páginas com os KPIs.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Acessar o dashboard principal ou a página de relatórios de KPIs (ex: `http://localhost:5000/dashboard` ou `http://localhost:5000/kpis`).
2.  Visualizar os valores atualizados da Taxa de Pontualidade, Eficiência de Trabalho e Custo por Hora Produtiva.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Verificar os cálculos dos KPIs manualmente com alguns dados de teste e comparar com os valores exibidos no sistema. Acessar as páginas onde os KPIs são exibidos e garantir que os dados estão corretos e formatados adequadamente.



## Prompt para Replit Agent: Implementar Sistema de Aprovação de Ocorrências

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, as ocorrências possuem um status, mas não há um workflow de aprovação hierárquica implementado.

**Papel do Replit Agent:**
Como um engenheiro de backend, sua tarefa é desenvolver um sistema de aprovação para as ocorrências, permitindo que diferentes níveis de usuários possam aprovar ou rejeitar ocorrências.

**Tarefa específica:**
Implementar um sistema de aprovação hierárquica para as ocorrências. Isso inclui:
1.  **Definir um modelo de dados** para o workflow de aprovação (ex: status de aprovação, aprovador, data de aprovação/rejeição, comentários).
2.  **Modificar o modelo de Ocorrências** para incluir campos relacionados ao status de aprovação.
3.  **Criar rotas de backend (Flask)** para que usuários com permissão possam alterar o status de uma ocorrência (aprovar/rejeitar) e adicionar comentários.
4.  **Implementar lógica de negócio** para definir a hierarquia de aprovação (ex: um gerente aprova, um diretor finaliza).
5.  **Atualizar a interface do usuário** (frontend) para exibir o status de aprovação e permitir que usuários autorizados interajam com o workflow (ex: botões de aprovar/rejeitar).

**Critérios de aceitação:**
-   Ocorrências devem ter um status de aprovação claro (ex: Pendente, Aprovado, Rejeitado).
-   Apenas usuários com as permissões corretas devem ser capazes de alterar o status de aprovação de uma ocorrência.
-   O workflow de aprovação deve seguir a hierarquia definida.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e Bootstrap 5.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com o sistema de aprovação.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Acessar uma ocorrência específica (ex: `http://localhost:5000/ocorrencias/1`).
2.  Se tiver permissão, ver botões para "Aprovar" ou "Rejeitar" a ocorrência.
3.  Ao aprovar/rejeitar, o status da ocorrência deve ser atualizado e registrado no histórico.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar o fluxo de aprovação com diferentes perfis de usuário para garantir que as permissões e a hierarquia estão funcionando corretamente. Verificar se o status das ocorrências é atualizado no banco de dados.



## Prompt para Replit Agent: Implementar Controle de Acesso e Permissões

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema não possui um controle de acesso baseado em níveis de permissão (roles).

**Papel do Replit Agent:**
Como um engenheiro de backend e segurança, sua tarefa é implementar um sistema robusto de controle de acesso baseado em roles e permissões por módulo, garantindo que apenas usuários autorizados possam acessar determinadas funcionalidades ou dados.

**Tarefa específica:**
Implementar um sistema de controle de acesso (RBAC - Role-Based Access Control) para o SIGE v3.0. Isso inclui:
1.  **Definir modelos de dados** para `Roles` (cargos/perfis de usuário) e `Permissões` (ações específicas ou acesso a módulos).
2.  **Associar usuários a roles** e roles a permissões no banco de dados PostgreSQL via SQLAlchemy.
3.  **Implementar a lógica de verificação de permissões** no backend (Flask) para proteger rotas e funcionalidades específicas (ex: `@login_required`, `@permission_required`).
4.  **Atualizar a interface do usuário** (frontend) para exibir ou ocultar elementos (botões, links, seções) com base nas permissões do usuário logado.
5.  **Criar uma interface de administração** para gerenciar roles e permissões (opcional, mas desejável para um sistema completo).

**Critérios de aceitação:**
-   Usuários com diferentes roles devem ter acesso a diferentes conjuntos de funcionalidades e dados, conforme as permissões definidas.
-   Tentativas de acesso não autorizado a rotas protegidas devem ser bloqueadas e, idealmente, redirecionar para uma página de erro ou login.
-   O sistema deve ser flexível o suficiente para adicionar novas roles e permissões no futuro.
-   O código deve seguir as melhores práticas de segurança em Flask e SQLAlchemy.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao testar as permissões.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Fazer login como um "Administrador" e ter acesso a todas as funcionalidades.
2.  Fazer login como um "Funcionário Comum" e ter acesso apenas às funcionalidades permitidas para seu perfil (ex: ver seu próprio perfil, mas não editar outros funcionários).
3.  Tentar acessar uma rota restrita sem permissão e ser impedido.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Criar diferentes usuários com diferentes roles e testar o acesso a diversas partes do sistema para garantir que as permissões estão sendo aplicadas corretamente. Verificar os logs do servidor para tentativas de acesso não autorizado.



## Prompt para Replit Agent: Implementar Gestão Financeira Avançada

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema possui apenas custos básicos implementados, mas falta um controle financeiro mais abrangente, incluindo receitas, fluxo de caixa, orçamentos vs. realizados e centros de custo.

**Papel do Replit Agent:**
Como um engenheiro de backend e especialista em sistemas financeiros, sua tarefa é expandir o módulo financeiro do SIGE v3.0 para incluir funcionalidades avançadas de gestão financeira.

**Tarefa específica:**
Implementar as seguintes funcionalidades de gestão financeira avançada:
1.  **Controle de Receitas**: Criar um módulo para registrar e gerenciar receitas, incluindo CRUD completo.
2.  **Fluxo de Caixa**: Desenvolver uma funcionalidade para visualizar o fluxo de caixa (entradas e saídas) por período.
3.  **Orçamentos vs. Realizados**: Implementar a capacidade de definir orçamentos e comparar com os valores realizados, gerando relatórios de desvio.
4.  **Centros de Custo**: Adicionar a funcionalidade de associar despesas e receitas a centros de custo específicos para análise gerencial.

Para cada funcionalidade:
-   **Definir ou ajustar modelos de dados** no PostgreSQL via SQLAlchemy.
-   **Criar rotas de backend (Flask)** para as operações de CRUD e para a geração de dados para relatórios financeiros.
-   **Desenvolver interfaces de usuário (frontend)** com Bootstrap 5 para entrada de dados e visualização de relatórios (tabelas, gráficos).

**Critérios de aceitação:**
-   É possível registrar receitas e despesas com seus respectivos centros de custo.
-   O fluxo de caixa pode ser visualizado de forma clara por diferentes períodos.
-   Relatórios de orçamento vs. realizado devem mostrar as diferenças e percentuais de desvio.
-   A associação de transações a centros de custo deve funcionar corretamente.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e Bootstrap 5.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com o módulo financeiro.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Registrar uma nova receita ou despesa, associando-a a um centro de custo.
2.  Acessar o relatório de fluxo de caixa e filtrar por mês ou ano.
3.  Criar um orçamento para um projeto e, posteriormente, comparar com os gastos reais.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar o registro de receitas e despesas, a visualização do fluxo de caixa e a criação/comparação de orçamentos. Verificar a consistência dos dados no banco de dados e a precisão dos relatórios financeiros gerados.



## Prompt para Replit Agent: Implementar Integrações Externas (APIs)

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema é standalone e não possui integrações com APIs externas para funcionalidades como validação de CEP, CPF/CNPJ ou sistemas de pagamento.

**Papel do Replit Agent:**
Como um engenheiro de backend, sua tarefa é implementar integrações com APIs externas para aprimorar a funcionalidade e a validação de dados no SIGE v3.0.

**Tarefa específica:**
Implementar integrações com APIs externas para as seguintes funcionalidades:
1.  **Validação de CEP**: Integrar com uma API de CEP (ex: ViaCEP) para preenchimento automático de endereços em formulários.
2.  **Validação de CPF/CNPJ**: Integrar com uma API de validação de documentos (ex: ReceitaWS para CNPJ, ou similar para CPF) para verificar a validade dos documentos.
3.  **Integração com Sistemas de Pagamento**: Preparar a base para futura integração com um gateway de pagamento (ex: Stripe, PagSeguro), focando inicialmente na estrutura de comunicação.

Para cada integração:
-   **Identificar e selecionar uma API** pública e gratuita (ou com plano gratuito para testes) para a funcionalidade.
-   **Criar rotas de backend (Flask)** que consumam essas APIs, tratando as requisições e respostas.
-   **Atualizar as interfaces de usuário (frontend)** com Bootstrap 5 para acionar as chamadas de API (ex: ao digitar o CEP, preencher o endereço automaticamente).
-   **Implementar tratamento de erros** para falhas nas chamadas de API.

**Critérios de aceitação:**
-   Ao digitar um CEP válido em um formulário, os campos de endereço (rua, bairro, cidade, estado) devem ser preenchidos automaticamente.
-   Ao informar um CPF/CNPJ, o sistema deve ser capaz de validar o documento através da API externa.
-   A estrutura para integração com sistemas de pagamento deve estar pronta para expansão futura.
-   O código deve seguir as melhores práticas de Flask para consumo de APIs externas.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com as integrações.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Em um formulário de cadastro, digitar um CEP e ver o endereço ser preenchido automaticamente.
2.  Em um formulário de cadastro de pessoa jurídica, digitar um CNPJ e o sistema indicar se é válido ou não.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para instalar bibliotecas necessárias (ex: requests para chamadas HTTP)
pip install requests
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar as integrações com dados válidos e inválidos (CEPs, CPFs/CNPJs) para garantir que as APIs estão sendo consumidas corretamente e que o tratamento de erros está funcionando. Verificar a resposta do sistema no frontend e nos logs do servidor.



## Prompt para Replit Agent: Melhorar Modal de Edição de Funcionário

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. O modal de edição de funcionário (`templates/funcionarios.html`) está presente e funcional, mas pode necessitar de melhorias de UX e validações mais completas.

**Papel do Replit Agent:**
Como um engenheiro de frontend e backend, sua tarefa é aprimorar o modal de edição de funcionário, focando na experiência do usuário e na robustez das validações.

**Tarefa específica:**
Melhorar o "Modal de Edição de Funcionário" em `templates/funcionarios.html`. Isso inclui:
1.  **Revisar e aprimorar as validações de formulário** (frontend e backend) para todos os campos do modal, garantindo que os dados inseridos sejam consistentes e corretos (ex: formato de e-mail, números de telefone, datas).
2.  **Implementar feedback visual** para o usuário em caso de erros de validação (ex: mensagens de erro claras, campos destacados).
3.  **Otimizar a experiência do usuário (UX)** no modal, considerando aspectos como a ordem dos campos, a clareza dos rótulos e a facilidade de navegação.
4.  **Garantir que a atualização dos dados** do funcionário no banco de dados ocorra de forma eficiente e sem erros.

**Critérios de aceitação:**
-   Todas as validações de campos do formulário de edição de funcionário devem funcionar corretamente, tanto no frontend quanto no backend.
-   Mensagens de erro claras e informativas devem ser exibidas ao usuário em caso de falha na validação.
-   A experiência de uso do modal deve ser intuitiva e eficiente.
-   A edição de um funcionário deve ser persistida no banco de dados sem problemas.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e Bootstrap 5.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com o modal.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Abrir o modal de edição de um funcionário.
2.  Tentar salvar o formulário com dados inválidos e ver as mensagens de erro apropriadas.
3.  Salvar o formulário com dados válidos e verificar se as informações foram atualizadas corretamente no perfil do funcionário.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar o modal de edição de funcionário com diversos cenários de entrada de dados (válidos, inválidos, incompletos) para verificar a eficácia das validações e a usabilidade do modal. Confirmar a persistência dos dados no banco de dados.



## Prompt para Replit Agent: Implementar Sistema de Notificações em Tempo Real

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema utiliza apenas flash messages básicas para notificações, e é necessário um sistema de notificações em tempo real para melhorar a experiência do usuário.

**Papel do Replit Agent:**
Como um engenheiro de backend e frontend, sua tarefa é implementar um sistema de notificações em tempo real no SIGE v3.0, permitindo que os usuários recebam alertas instantâneos sobre eventos importantes.

**Tarefa específica:**
Implementar um sistema de notificações em tempo real. Isso inclui:
1.  **Escolher e integrar uma tecnologia de comunicação em tempo real** (ex: WebSockets com Flask-SocketIO, ou Server-Sent Events).
2.  **Criar um modelo de dados** para armazenar as notificações no banco de dados (ex: mensagem, tipo, usuário-alvo, lida/não lida, data).
3.  **Implementar a lógica de backend (Flask)** para gerar e enviar notificações para usuários específicos ou grupos, com base em eventos do sistema (ex: nova ocorrência, aprovação de solicitação, atualização de status).
4.  **Desenvolver a interface de usuário (frontend)** com Bootstrap 5 para exibir as notificações de forma não intrusiva (ex: um ícone de sino com contador, pop-ups temporários) e permitir que o usuário as marque como lidas.

**Critérios de aceitação:**
-   Notificações devem ser entregues aos usuários em tempo real, sem a necessidade de recarregar a página.
-   As notificações devem ser persistidas no banco de dados e exibidas corretamente na interface do usuário.
-   O usuário deve ser capaz de marcar as notificações como lidas.
-   O sistema deve ser escalável para lidar com um volume crescente de notificações.
-   O código deve seguir as melhores práticas de Flask e da tecnologia de tempo real escolhida.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor durante o envio ou recebimento de notificações.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Receber uma notificação instantânea no navegador quando uma nova ocorrência for registrada ou uma solicitação for aprovada.
2.  Ver um contador de notificações não lidas no ícone de sino.
3.  Clicar no ícone para ver a lista de notificações e marcá-las como lidas.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para instalar bibliotecas necessárias (ex: Flask-SocketIO)
pip install Flask-SocketIO
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Simular eventos que geram notificações (ex: criar uma nova ocorrência, aprovar uma solicitação) e verificar se as notificações são recebidas em tempo real pelo usuário correto. Testar a persistência e o gerenciamento das notificações na interface.



## Prompt para Replit Agent: Implementar Auditoria e Logs

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema não possui um rastreamento de alterações ou um log de ações dos usuários, o que é crucial para auditoria e segurança.

**Papel do Replit Agent:**
Como um engenheiro de backend e segurança, sua tarefa é implementar um sistema de auditoria e log de ações dos usuários no SIGE v3.0, registrando eventos importantes para rastreabilidade e conformidade.

**Tarefa específica:**
Implementar um sistema de auditoria e log de ações dos usuários. Isso inclui:
1.  **Criar um modelo de dados** para registrar eventos de auditoria (ex: usuário, ação, data/hora, módulo afetado, dados antes/depois da alteração, IP).
2.  **Integrar a lógica de log** em operações críticas do sistema (CRUD de usuários, funcionários, obras, alterações financeiras, etc.).
3.  **Registrar informações detalhadas** sobre cada ação, incluindo quem fez, o que foi feito, quando e quais dados foram afetados.
4.  **Desenvolver uma interface de usuário (frontend)** com Bootstrap 5 para visualizar os logs de auditoria, permitindo filtros por usuário, data, tipo de ação, etc.

**Critérios de aceitação:**
-   Todas as ações críticas do sistema devem ser registradas no log de auditoria.
-   O log deve conter informações suficientes para rastrear a origem e o impacto de cada ação.
-   A interface de visualização de logs deve ser funcional e permitir a busca e filtragem de registros.
-   O sistema de log deve ter um impacto mínimo no desempenho do sistema.
-   O código deve seguir as melhores práticas de Flask e SQLAlchemy para logging e auditoria.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor durante o registro ou visualização de logs.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Acessar a página de logs de auditoria (ex: `http://localhost:5000/auditoria`).
2.  Filtrar os logs para ver todas as ações realizadas por um usuário específico em um determinado período.
3.  Ver detalhes de uma alteração, como os valores antigos e novos de um registro.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Realizar diversas ações no sistema (criar, editar, excluir registros) e verificar se elas são devidamente registradas no log de auditoria. Acessar a interface de logs e testar as funcionalidades de busca e filtro para garantir que os dados estão sendo exibidos corretamente.



## Prompt para Replit Agent: Implementar Backup Automatizado

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, não há um sistema automatizado de backup para o banco de dados, o que é crítico para a recuperação de desastres.

**Papel do Replit Agent:**
Como um engenheiro de DevOps e backend, sua tarefa é implementar rotinas de backup automatizado para o banco de dados PostgreSQL do SIGE v3.0, garantindo a segurança e a capacidade de recuperação dos dados.

**Tarefa específica:**
Implementar um sistema de backup automatizado para o banco de dados PostgreSQL. Isso inclui:
1.  **Configurar rotinas de backup** que possam ser executadas de forma programada (ex: diariamente, semanalmente).
2.  **Utilizar ferramentas apropriadas** para backup de PostgreSQL (ex: `pg_dump`).
3.  **Definir um local de armazenamento** para os backups (ex: um diretório específico no sistema de arquivos, ou integração com um serviço de armazenamento em nuvem se aplicável no ambiente Replit/EasyPanel).
4.  **Implementar um mecanismo de recuperação** simples para restaurar o banco de dados a partir de um backup (ex: `pg_restore`).
5.  **Adicionar logs** para monitorar o sucesso ou falha dos backups.

**Critérios de aceitação:**
-   Os backups do banco de dados devem ser gerados automaticamente em intervalos definidos.
-   Os arquivos de backup devem ser armazenados em um local seguro e acessível.
-   É possível restaurar o banco de dados a partir de um backup gerado, sem perda de dados.
-   O processo de backup deve ser robusto e registrar logs de sua execução.
-   O código/scripts devem seguir as melhores práticas de segurança e automação.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Verificar os logs do sistema para confirmar que os backups estão sendo executados regularmente.
2.  Em caso de necessidade, executar um comando ou script para restaurar o banco de dados a partir do backup mais recente.

**Comandos de build/test (no ambiente Replit):**
```bash
# Exemplo de comando para backup (ajustar conforme o ambiente Replit)
pg_dump -Fc -h localhost -U <seu_usuario_postgres> <seu_banco_de_dados> > /caminho/para/backup/sige_backup_$(date +%Y%m%d%H%M%S).dump

# Exemplo de comando para restauração
pg_restore -Fc -h localhost -U <seu_usuario_postgres> -d <seu_banco_de_dados> /caminho/para/backup/sige_backup.dump

# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Executar um backup manual e tentar restaurá-lo em um ambiente de teste para garantir que o processo funciona. Verificar a existência dos arquivos de backup no local especificado e os logs de execução.



## Prompt para Replit Agent: Implementar Navegação e Filtros Persistentes

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, alguns filtros aplicados pelo usuário não persistem entre as páginas ou sessões, o que prejudica a experiência de uso.

**Papel do Replit Agent:**
Como um engenheiro de frontend e backend, sua tarefa é implementar a persistência de filtros e estados de navegação para melhorar a usabilidade do sistema.

**Tarefa específica:**
Implementar a persistência de filtros e estados de navegação. Isso inclui:
1.  **Identificar os filtros e estados de navegação** que devem ser persistidos (ex: filtros de busca, paginação, ordenação de tabelas).
2.  **Utilizar mecanismos de persistência** apropriados no frontend (ex: `localStorage`, `sessionStorage`) ou no backend (ex: variáveis de sessão do Flask, parâmetros de URL).
3.  **Garantir que, ao navegar entre páginas ou recarregar a página**, os filtros e estados previamente aplicados sejam restaurados.
4.  **Aplicar essa persistência** em módulos onde a filtragem é comum (ex: listagem de funcionários, relatórios).

**Critérios de aceitação:**
-   Os filtros aplicados em listagens e relatórios devem ser mantidos ao navegar para outras páginas e retornar, ou ao recarregar a página.
-   A persistência deve ser transparente para o usuário e não deve causar lentidão no sistema.
-   O código deve seguir as melhores práticas de Flask e JavaScript para manipulação de estado.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com os filtros.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Na página de listagem de funcionários, aplicar um filtro por departamento.
2.  Navegar para o perfil de um funcionário e, ao retornar para a listagem, o filtro por departamento ainda deve estar ativo.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar a aplicação de filtros em diferentes módulos e verificar se eles persistem ao navegar e recarregar as páginas. Confirmar que a experiência do usuário é aprimorada.



## Prompt para Replit Agent: Otimizar Responsividade Mobile

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Embora o Bootstrap 5 seja utilizado, a responsividade mobile pode necessitar de otimizações para garantir uma usabilidade ideal em dispositivos móveis.

**Papel do Replit Agent:**
Como um engenheiro de frontend, sua tarefa é otimizar a responsividade mobile do SIGE v3.0, garantindo que a interface seja totalmente funcional e visualmente agradável em diferentes tamanhos de tela.

**Tarefa específica:**
Otimizar a responsividade mobile do sistema. Isso inclui:
1.  **Revisar as páginas principais** do sistema (dashboard, listagens, formulários) para identificar problemas de layout e usabilidade em dispositivos móveis.
2.  **Ajustar o CSS e o HTML** utilizando as classes e componentes responsivos do Bootstrap 5, ou adicionando CSS personalizado quando necessário.
3.  **Garantir que todos os elementos interativos** (botões, links, campos de formulário) sejam facilmente clicáveis e utilizáveis em telas pequenas.
4.  **Otimizar o carregamento de imagens e outros ativos** para dispositivos móveis, se aplicável.

**Critérios de aceitação:**
-   A interface do sistema deve se adaptar corretamente a diferentes tamanhos de tela (smartphones, tablets).
-   Todos os elementos da interface devem ser acessíveis e utilizáveis em dispositivos móveis, sem rolagem horizontal desnecessária.
-   A experiência do usuário em dispositivos móveis deve ser fluida e intuitiva.
-   O código deve seguir as melhores práticas de desenvolvimento frontend responsivo e Bootstrap 5.
-   Nenhum erro de layout ou funcionalidade deve ser apresentado em diferentes viewports.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Acessar o SIGE v3.0 em um navegador mobile ou redimensionar a janela do navegador para simular um dispositivo móvel.
2.  Navegar por todas as páginas e interagir com os elementos sem problemas de visualização ou usabilidade.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar o sistema em diferentes emuladores de dispositivos móveis ou diretamente em smartphones/tablets para verificar a responsividade e a usabilidade. Utilizar as ferramentas de desenvolvedor do navegador para inspecionar o layout em diferentes resoluções.



## Prompt para Replit Agent: Melhorar Busca e Autocomplete

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema possui uma busca básica, mas é necessário aprimorá-la com funcionalidades de busca avançada e autocomplete para melhorar a experiência do usuário.

**Papel do Replit Agent:**
Como um engenheiro de backend e frontend, sua tarefa é aprimorar o sistema de busca e adicionar funcionalidades de autocomplete para tornar a pesquisa de informações mais eficiente e intuitiva.

**Tarefa específica:**
Melhorar a busca e adicionar funcionalidades de autocomplete. Isso inclui:
1.  **Implementar busca avançada** com múltiplos filtros (ex: por nome, CPF, status, data) em módulos onde a busca é relevante (ex: funcionários, obras).
2.  **Adicionar funcionalidade de autocomplete** em campos de busca, sugerindo resultados à medida que o usuário digita (ex: nomes de funcionários, nomes de obras).
3.  **Otimizar as queries de busca** no backend (Flask/SQLAlchemy) para garantir desempenho, mesmo com grandes volumes de dados.
4.  **Atualizar a interface do usuário (frontend)** com Bootstrap 5 para exibir os resultados da busca de forma clara e as sugestões de autocomplete.

**Critérios de aceitação:**
-   A busca avançada deve permitir a combinação de múltiplos filtros e retornar resultados precisos.
-   A funcionalidade de autocomplete deve sugerir resultados relevantes em tempo real, com base na entrada do usuário.
-   O desempenho da busca e do autocomplete deve ser rápido e responsivo.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e JavaScript para busca e autocomplete.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao utilizar as funcionalidades de busca.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Na página de funcionários, digitar parte de um nome no campo de busca e ver sugestões de nomes completos.
2.  Utilizar múltiplos filtros (ex: nome e departamento) para refinar a busca de funcionários.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar a busca avançada com diferentes combinações de filtros e verificar a precisão dos resultados. Testar a funcionalidade de autocomplete em campos relevantes, verificando a relevância e a velocidade das sugestões. Monitorar o desempenho das queries no backend.



## Prompt para Replit Agent: Implementar Gestão de Estoque

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, o sistema não possui um módulo de controle de estoque de materiais, o que é essencial para a gestão de recursos.

**Papel do Replit Agent:**
Como um engenheiro de backend e frontend, sua tarefa é implementar um módulo completo de gestão de estoque para materiais, incluindo operações CRUD e controle de movimentações.

**Tarefa específica:**
Implementar um módulo completo de gestão de estoque. Isso inclui:
1.  **Criar um modelo de dados** para `Materiais` (ex: nome, descrição, unidade de medida, quantidade em estoque, localização) e `Movimentações de Estoque` (ex: tipo de movimentação - entrada/saída, quantidade, data, motivo, usuário).
2.  **Desenvolver rotas de backend (Flask)** para as operações CRUD (Criar, Ler, Atualizar, Deletar) de materiais e para registrar as movimentações de estoque.
3.  **Implementar a lógica de negócio** para atualizar a quantidade em estoque automaticamente a cada movimentação.
4.  **Criar interfaces de usuário (frontend)** com Bootstrap 5 para:
    -   Listagem de materiais com filtros e busca.
    -   Formulários para adicionar/editar materiais.
    -   Funcionalidade para registrar entradas e saídas de estoque.
    -   Visualização do histórico de movimentações por material.

**Critérios de aceitação:**
-   É possível cadastrar, visualizar, editar e excluir materiais do estoque.
-   É possível registrar entradas e saídas de materiais, e a quantidade em estoque é atualizada corretamente.
-   O histórico de movimentações de cada material é rastreável.
-   A interface do usuário é intuitiva e fácil de usar para a gestão de estoque.
-   O código deve seguir as melhores práticas de Flask, SQLAlchemy e Bootstrap 5.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com o módulo de estoque.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Cadastrar um novo material no sistema (ex: "Cimento", "Tijolo").
2.  Registrar a entrada de 100 unidades de cimento no estoque.
3.  Registrar a saída de 10 unidades de cimento para uma obra específica.
4.  Verificar que a quantidade em estoque de cimento foi atualizada para 90 unidades.
5.  Consultar o histórico de movimentações do cimento.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar todas as operações CRUD para materiais e as funcionalidades de entrada/saída de estoque. Verificar a consistência dos dados no banco de dados e a precisão das quantidades em estoque. Testar a visualização do histórico de movimentações.



## Prompt para Replit Agent: Implementar Gestão de Documentos

**Contexto do projeto:**
O projeto SIGE v3.0 é um Sistema Integrado de Gestão Empresarial desenvolvido com Flask, SQLAlchemy, PostgreSQL, Bootstrap 5 e Docker/EasyPanel. Atualmente, a gestão de documentos é limitada a fotos de funcionários, e é necessário um sistema mais abrangente para upload e gestão de documentos por obra/funcionário.

**Papel do Replit Agent:**
Como um engenheiro de backend e frontend, sua tarefa é implementar um módulo completo de gestão de documentos, permitindo o upload, armazenamento e associação de documentos a obras e funcionários.

**Tarefa específica:**
Implementar um módulo completo de gestão de documentos. Isso inclui:
1.  **Criar um modelo de dados** para `Documentos` (ex: nome do arquivo, tipo, caminho de armazenamento, data de upload, associado a funcionário/obra).
2.  **Desenvolver rotas de backend (Flask)** para:
    -   Upload seguro de arquivos (tratamento de tipos de arquivo, tamanho, nomes).
    -   Associação de documentos a registros existentes (funcionários, obras).
    -   Download de documentos.
    -   Exclusão de documentos.
3.  **Implementar a lógica de armazenamento de arquivos** no servidor (ou em um serviço de armazenamento de objetos, se aplicável no ambiente Replit/EasyPanel).
4.  **Criar interfaces de usuário (frontend)** com Bootstrap 5 para:
    -   Botões de upload de documentos nas páginas de funcionários e obras.
    -   Listagem de documentos associados a um funcionário ou obra.
    -   Funcionalidade para visualizar/baixar documentos.

**Critérios de aceitação:**
-   É possível fazer upload de diferentes tipos de documentos (PDF, imagens, documentos de texto) e associá-los a funcionários ou obras.
-   Os documentos devem ser armazenados de forma segura e acessível.
-   É possível visualizar e baixar os documentos associados a um funcionário ou obra.
-   A exclusão de documentos deve funcionar corretamente.
-   O código deve seguir as melhores práticas de Flask para manipulação de arquivos e SQLAlchemy para persistência de dados.
-   Nenhum erro deve ser apresentado no console do navegador ou no log do servidor ao interagir com o módulo de documentos.

**Exemplo de uso:**
Após a implementação, o usuário deve ser capaz de:
1.  Na página de perfil de um funcionário, fazer upload de um contrato de trabalho.
2.  Na página de uma obra, fazer upload de plantas ou licenças.
3.  Acessar a lista de documentos de um funcionário/obra e baixar um documento específico.

**Comandos de build/test (no ambiente Replit):**
```bash
# Para iniciar o servidor Flask
python app.py
```

**Validação:**
Testar o upload de diferentes tipos de arquivos, a associação a funcionários e obras, e as funcionalidades de download e exclusão. Verificar a integridade dos arquivos armazenados e a correta exibição na interface.

