# Prompts de Corre√ß√£o - Bugs de Severidade ALTA do Almoxarifado

## PROMPT #5: Corre√ß√£o BUG #005 - N+1 Query Problem

```
**CORRE√á√ÉO DE BUG ALTO #005 - ALMOXARIFADO**

**üìã REFER√äNCIA DO BUG**

**BUG #005 - [SEVERIDADE: ALTO] - N+1 Query Problem em Dashboard e Listagens**

**Descri√ß√£o:**  
O dashboard e listagem de itens executam queries individuais dentro de loops, causando N+1 queries. Com 100 itens, s√£o executadas 100+ queries adicionais.

**Localiza√ß√£o:**  
- **Arquivo:** `almoxarifado_views.py`
- **Fun√ß√µes:** `dashboard()`, `itens()`, `alertas()`
- **Linhas:** 44-66, 296-315, 2668-2692

**C√≥digo Problem√°tico:**
```python
for item in itens:
    estoque_atual = AlmoxarifadoEstoque.query.filter_by(item_id=item.id, ...).count()
    # Executa 1 query por item!
```

**Impacto:**  
Performance degradada significativamente em ambientes com muitos dados. Tempo de resposta pode aumentar de 1s para 10s+ com 100 itens.

**Comportamento Esperado:**  
Dashboard e listagens devem executar o m√≠nimo de queries poss√≠vel, usando agrega√ß√µes e eager loading.

**Comportamento Atual:**  
Cada item na listagem dispara uma query adicional ao banco de dados.

**Recomenda√ß√£o de Corre√ß√£o:**  
Usar subquery ou agrega√ß√£o com GROUP BY:
```python
from sqlalchemy import func

# Calcular estoque de todos os itens de uma vez
estoque_por_item = db.session.query(
    AlmoxarifadoEstoque.item_id,
    func.sum(AlmoxarifadoEstoque.quantidade_disponivel).label('total_disponivel')
).filter_by(
    admin_id=admin_id, 
    status='DISPONIVEL'
).group_by(AlmoxarifadoEstoque.item_id).all()

# Criar dicion√°rio para lookup r√°pido
estoque_dict = {item_id: total for item_id, total in estoque_por_item}

# Usar no loop
for item in itens:
    estoque_atual = estoque_dict.get(item.id, 0)
```

**‚öôÔ∏è A√á√ÉO SOLICITADA**

1. Localize o arquivo `almoxarifado_views.py`.
2. Encontre as fun√ß√µes `dashboard()`, `itens()` e `alertas()`.
3. Identifique os loops onde queries s√£o executadas para cada item.
4. Refatore o c√≥digo para usar agrega√ß√£o com GROUP BY conforme a recomenda√ß√£o.
5. Teste as rotas para garantir que os dados exibidos est√£o corretos.
6. Se poss√≠vel, use uma ferramenta de profiling SQL para confirmar a redu√ß√£o de queries.
7. Forne√ßa um resumo das altera√ß√µes e o n√∫mero estimado de queries antes/depois.

**COMANDO INICIAL:** Inicie a corre√ß√£o do BUG #005 agora, otimizando as queries N+1.
```

---

## PROMPT #6: Corre√ß√£o BUG #006 - Missing Pagination

```
**CORRE√á√ÉO DE BUG ALTO #006 - ALMOXARIFADO**

**üìã REFER√äNCIA DO BUG**

**BUG #006 - [SEVERIDADE: ALTO] - Missing Pagination em Listagens Cr√≠ticas**

**Descri√ß√£o:**  
Rotas de listagem carregam TODOS os registros sem pagina√ß√£o, causando problemas de mem√≥ria e performance.

**Localiza√ß√£o:**  
- **Arquivo:** `almoxarifado_views.py`
- **Fun√ß√µes:** `movimentacoes()`, `itens_movimentacoes()`
- **Linhas:** 524, 2508, 2634

**C√≥digo Problem√°tico:**
```python
movimentos = query.order_by(...).all()  # Carrega TUDO na mem√≥ria
```

**Impacto:**  
- Memory overflow com muitos registros (milhares de movimenta√ß√µes)
- Tempo de resposta degradado (10s+ para carregar p√°gina)
- Browser travando ao renderizar tabela gigante com milhares de linhas

**Comportamento Esperado:**  
Listagens devem exibir 50-100 registros por p√°gina, com navega√ß√£o entre p√°ginas.

**Comportamento Atual:**  
Todas as movimenta√ß√µes s√£o carregadas de uma vez, independente da quantidade.

**Recomenda√ß√£o de Corre√ß√£o:**  
Implementar pagina√ß√£o usando Flask-SQLAlchemy:
```python
page = request.args.get('page', 1, type=int)
per_page = request.args.get('per_page', 50, type=int)
per_page = min(per_page, 100)  # Limitar m√°ximo

pagination = query.order_by(...).paginate(
    page=page, 
    per_page=per_page,
    error_out=False
)
movimentos = pagination.items
```

No template:
```html
<!-- Navega√ß√£o de p√°ginas -->
<nav>
    <ul class="pagination">
        {% if pagination.has_prev %}
        <li><a href="?page={{ pagination.prev_num }}">Anterior</a></li>
        {% endif %}
        
        <li>P√°gina {{ pagination.page }} de {{ pagination.pages }}</li>
        
        {% if pagination.has_next %}
        <li><a href="?page={{ pagination.next_num }}">Pr√≥xima</a></li>
        {% endif %}
    </ul>
</nav>
```

**‚öôÔ∏è A√á√ÉO SOLICITADA**

1. Localize o arquivo `almoxarifado_views.py`.
2. Encontre as fun√ß√µes `movimentacoes()` e `itens_movimentacoes()`.
3. Substitua `.all()` por `.paginate()` conforme a recomenda√ß√£o.
4. Passe o objeto `pagination` para o template no `render_template()`.
5. Modifique os templates correspondentes (`movimentacoes.html`, `itens_movimentacoes.html`) para incluir os controles de pagina√ß√£o.
6. Use Bootstrap para estilizar a pagina√ß√£o de forma consistente com o resto do sistema.
7. Teste as listagens com muitos registros para garantir que a pagina√ß√£o funciona.
8. Forne√ßa um resumo das altera√ß√µes em views e templates.

**COMANDO INICIAL:** Inicie a corre√ß√£o do BUG #006 agora, implementando pagina√ß√£o nas listagens.
```

---

## PROMPT #7: Corre√ß√£o BUG #007 - Race Condition em Sa√≠da M√∫ltipla

```
**CORRE√á√ÉO DE BUG ALTO #007 - ALMOXARIFADO**

**üìã REFER√äNCIA DO BUG**

**BUG #007 - [SEVERIDADE: ALTO] - Race Condition em Sa√≠da M√∫ltipla Permite Estoque Negativo**

**Descri√ß√£o:**  
A valida√ß√£o de estoque dispon√≠vel e a atualiza√ß√£o n√£o s√£o at√¥micas, permitindo condi√ß√£o de corrida onde dois usu√°rios podem retirar o mesmo item simultaneamente, resultando em estoque negativo.

**Localiza√ß√£o:**  
- **Arquivo:** `almoxarifado_views.py`
- **Fun√ß√£o:** `processar_saida_multipla_api()`
- **Linhas:** ~1450-1730

**Impacto:**  
Estoque pode ficar negativo se dois usu√°rios tentarem retirar o √∫ltimo item ao mesmo tempo. Isso quebra a integridade dos dados e pode causar problemas s√©rios no controle de estoque.

**Comportamento Esperado:**  
Apenas um usu√°rio consegue retirar o √∫ltimo item dispon√≠vel. O segundo usu√°rio recebe erro de "estoque insuficiente".

**Comportamento Atual:**  
Ambos os usu√°rios conseguem retirar o item, resultando em estoque negativo.

**Recomenda√ß√£o de Corre√ß√£o:**  
Usar lock pessimista com `SELECT FOR UPDATE`:
```python
# Lock pessimista - bloqueia o registro durante a transa√ß√£o
estoque = AlmoxarifadoEstoque.query.filter_by(
    id=estoque_id,
    admin_id=admin_id
).with_for_update().first()

if not estoque:
    raise ValueError("Estoque n√£o encontrado")

if estoque.quantidade_disponivel < quantidade_solicitada:
    raise ValueError("Estoque insuficiente")

# Atualizar estoque (ainda dentro da transa√ß√£o com lock)
estoque.quantidade_disponivel -= quantidade_solicitada
```

**‚öôÔ∏è A√á√ÉO SOLICITADA**

1. Localize o arquivo `almoxarifado_views.py`.
2. Encontre a fun√ß√£o `processar_saida_multipla_api()` (linha ~1450).
3. Identifique onde o estoque √© consultado e atualizado.
4. Adicione `.with_for_update()` na query que busca o estoque antes de atualizar.
5. Certifique-se de que a valida√ß√£o e atualiza√ß√£o est√£o dentro da mesma transa√ß√£o.
6. Verifique se h√° outras fun√ß√µes de sa√≠da que possam ter o mesmo problema (ex: `processar_saida()`, `processar_saida_simples()`).
7. Aplique a mesma corre√ß√£o em todas as fun√ß√µes identificadas.
8. Adicione coment√°rios no c√≥digo explicando o uso do lock pessimista.
9. Forne√ßa um resumo de todas as fun√ß√µes corrigidas.

**OBSERVA√á√ÉO IMPORTANTE:**  
O uso de `.with_for_update()` requer que o c√≥digo esteja dentro de uma transa√ß√£o. Certifique-se de que h√° um `db.session.commit()` ao final da opera√ß√£o bem-sucedida e um `db.session.rollback()` em caso de erro.

**COMANDO INICIAL:** Inicie a corre√ß√£o do BUG #007 agora, implementando lock pessimista nas opera√ß√µes de sa√≠da.
```

---

## PROMPT #8: Corre√ß√£o BUG #008 - Raw SQL DELETE Bypassa Cascade

```
**CORRE√á√ÉO DE BUG ALTO #008 - ALMOXARIFADO**

**üìã REFER√äNCIA DO BUG**

**BUG #008 - [SEVERIDADE: ALTO] - Raw SQL DELETE Bypassa Cascade do ORM**

**Descri√ß√£o:**  
O uso de SQL direto para deletar registros pode n√£o acionar CASCADE rules definidas no ORM, deixando registros √≥rf√£os se novas tabelas relacionadas forem adicionadas no futuro.

**Localiza√ß√£o:**  
- **Arquivo:** `almoxarifado_views.py`
- **Fun√ß√£o:** `itens_deletar()`
- **Linhas:** 604-613

**C√≥digo Problem√°tico:**
```python
db.session.execute(text("DELETE FROM almoxarifado_movimento WHERE ..."))
db.session.execute(text("DELETE FROM almoxarifado_estoque WHERE ..."))
db.session.execute(text("DELETE FROM almoxarifado_item WHERE ..."))
```

**Impacto:**  
Potenciais registros √≥rf√£os se novas tabelas relacionadas forem adicionadas no futuro. Manuten√ß√£o mais dif√≠cil, pois a ordem de exclus√£o precisa ser mantida manualmente.

**Comportamento Esperado:**  
Exclus√µes devem usar o ORM do SQLAlchemy, que respeita as regras de cascade definidas nos relacionamentos.

**Comportamento Atual:**  
Exclus√µes usam SQL raw, bypassando o ORM.

**Recomenda√ß√£o de Corre√ß√£o:**  
Op√ß√£o 1 - Usar ORM com cascade configurado:
```python
# Configurar cascade no modelo (models.py)
class AlmoxarifadoItem(db.Model):
    movimentos = db.relationship('AlmoxarifadoMovimento', 
                                 backref='item', 
                                 cascade='all, delete-orphan')
    estoques = db.relationship('AlmoxarifadoEstoque', 
                               backref='item', 
                               cascade='all, delete-orphan')

# Deletar usando ORM (almoxarifado_views.py)
item = AlmoxarifadoItem.query.filter_by(id=id, admin_id=admin_id).first()
if item:
    db.session.delete(item)  # Cascade autom√°tico
    db.session.commit()
```

Op√ß√£o 2 - Se precisar manter SQL raw, documentar claramente:
```python
# IMPORTANTE: Ordem de exclus√£o deve ser mantida para evitar viola√ß√£o de FK
# 1. Deletar movimentos (FK para item)
# 2. Deletar estoques (FK para item)
# 3. Deletar item
db.session.execute(text("DELETE FROM almoxarifado_movimento WHERE item_id=:id AND admin_id=:aid"), 
                   {"id": id, "aid": admin_id})
db.session.execute(text("DELETE FROM almoxarifado_estoque WHERE item_id=:id AND admin_id=:aid"), 
                   {"id": id, "aid": admin_id})
db.session.execute(text("DELETE FROM almoxarifado_item WHERE id=:id AND admin_id=:aid"), 
                   {"id": id, "aid": admin_id})
```

**‚öôÔ∏è A√á√ÉO SOLICITADA**

1. Localize o arquivo `almoxarifado_views.py` e a fun√ß√£o `itens_deletar()` (linha ~604).
2. Analise o c√≥digo atual de exclus√£o com SQL raw.
3. Verifique no arquivo `models.py` se os relacionamentos entre `AlmoxarifadoItem`, `AlmoxarifadoMovimento` e `AlmoxarifadoEstoque` t√™m cascade configurado.
4. **Op√ß√£o Recomendada:** Se os relacionamentos t√™m cascade, refatore para usar ORM (Op√ß√£o 1).
5. **Op√ß√£o Alternativa:** Se houver motivo para manter SQL raw (performance), adicione coment√°rios detalhados e valida√ß√µes extras (Op√ß√£o 2).
6. Teste a exclus√£o de um item que tem movimentos e estoques associados.
7. Verifique se n√£o h√° registros √≥rf√£os ap√≥s a exclus√£o.
8. Forne√ßa um resumo da abordagem escolhida e das altera√ß√µes realizadas.

**COMANDO INICIAL:** Inicie a corre√ß√£o do BUG #008 agora, priorizando o uso do ORM com cascade.
```

---

## Resumo dos Bugs de Severidade ALTA

| Bug | T√≠tulo | Impacto | Complexidade |
|-----|--------|---------|--------------|
| #005 | N+1 Query Problem | Performance degradada | M√©dia |
| #006 | Missing Pagination | Memory overflow, browser travando | Baixa |
| #007 | Race Condition | Estoque negativo | Alta |
| #008 | Raw SQL DELETE | Registros √≥rf√£os potenciais | M√©dia |

## Ordem Recomendada de Corre√ß√£o

1. **BUG #006** (mais f√°cil, impacto imediato na UX)
2. **BUG #005** (melhora significativa de performance)
3. **BUG #008** (importante para manutenibilidade)
4. **BUG #007** (mais complexo, mas cr√≠tico para integridade)

## Testes Recomendados Ap√≥s Corre√ß√µes

1. **BUG #005:** Use uma ferramenta como Flask-DebugToolbar ou logging SQL para confirmar redu√ß√£o de queries
2. **BUG #006:** Teste com 500+ registros e verifique se a pagina√ß√£o funciona
3. **BUG #007:** Simule requisi√ß√µes concorrentes (pode usar scripts Python com threading)
4. **BUG #008:** Delete um item com movimentos/estoques e verifique integridade do banco

## Pr√≥ximos Passos

Ap√≥s corrigir os bugs de severidade ALTA, voc√™ pode prosseguir com os bugs de severidade M√âDIA e BAIXA.
