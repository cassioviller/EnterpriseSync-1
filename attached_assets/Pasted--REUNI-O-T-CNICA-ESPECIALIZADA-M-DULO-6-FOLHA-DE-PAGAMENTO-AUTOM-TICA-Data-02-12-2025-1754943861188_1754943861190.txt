# 🎯 REUNIÃO TÉCNICA ESPECIALIZADA - MÓDULO 6: FOLHA DE PAGAMENTO AUTOMÁTICA

**Data:** 02/12/2025 - 08:00h  
**Duração:** 5 horas  
**Contexto:** Implementação do sexto módulo - Módulos 1, 2, 3, 4 e 5 já funcionando perfeitamente  
**Status:** Continuidade da evolução SIGE v8.0

---

## 👥 PARTICIPANTES DA REUNIÃO

**Marina Santos** - Product Manager (Moderadora)  
**Carlos Rodriguez** - Tech Lead  
**Ana Silva** - Backend Developer  
**Lucia Ferreira** - Frontend/UX  
**Rafael Costa** - AI/ML Engineer  
**João Mendes** - DevOps Engineer  
**Patricia Lima** - Especialista em RH (Especialista principal)  
**Roberto Almeida** - Especialista em Logística  
**Dr. Eduardo Martins** - Especialista em Biometria  
**Dra. Carla Mendes** - Contadora e Especialista em CLT (nova participante)  
**Prof. Ricardo Santos** - Especialista em Legislação Trabalhista (novo participante)  

---

## 📋 AGENDA DA REUNIÃO

### **08:00 - Abertura e Status dos Módulos Anteriores**

**Marina:** Bom dia, pessoal! Estamos com um progresso excepcional nos módulos anteriores:
- **Módulo 1:** Propostas sendo aprovadas e convertidas automaticamente - 100% funcional
- **Módulo 2:** Clientes acompanhando obras em tempo real com 98% de satisfação
- **Módulo 3:** Gestores alocando equipes visualmente com criação automática de RDO
- **Módulo 4:** Almoxarifado inteligente com código de barras e XML funcionando perfeitamente
- **Módulo 5:** Reconhecimento facial para ponto automático com 99.38% de precisão

Agora vamos implementar o **Módulo 6 - Sistema de Folha de Pagamento Automática**. Este módulo vai **AUTOMATIZAR COMPLETAMENTE** a folha de pagamento, eliminando cálculos manuais e garantindo conformidade total com CLT. Dra. Carla e Prof. Ricardo, bem-vindos à equipe!

**Dra. Carla:** Obrigada, Marina! Analisei o sistema atual e vejo uma oportunidade única. Com os pontos automáticos do Módulo 5, podemos criar a **folha de pagamento mais precisa do mercado**. Zero erro humano, conformidade total com CLT e cálculos automáticos de INSS, IRRF, FGTS e todos os encargos.

**Prof. Ricardo:** Exato! E vamos implementar **todas as regras da CLT** automaticamente: DSR, horas extras com percentuais corretos, adicional noturno, faltas justificadas, férias proporcionais, 13º salário e muito mais. O sistema será **mais confiável que qualquer contador**.

### **08:15 - Análise Profunda do Sistema de Ponto Atual**

**Carlos:** Vamos revisar como o sistema de ponto atual alimentará a folha automática:

```python
# Sistema de ponto existente que será INTEGRADO
class Ponto(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    data_ponto = db.Column(db.Date, nullable=False)
    hora_entrada = db.Column(db.Time)
    hora_saida = db.Column(db.Time)
    obra_id = db.Column(db.Integer, db.ForeignKey('obra.id'))  # Módulo 3
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))
    metodo_registro = db.Column(db.String(20), default='MANUAL')  # Módulo 5
    confianca_facial = db.Column(db.Float)  # Módulo 5
    
    # SERÁ INTEGRADO: cálculos automáticos de horas
```

**Ana:** O ponto crucial é que já temos **dados precisos de entrada e saída** com o reconhecimento facial. Agora vamos **calcular automaticamente**:
- **Horas normais** trabalhadas
- **Horas extras** (50% e 100%)
- **Adicional noturno** (20%)
- **DSR** (Descanso Semanal Remunerado)
- **Faltas** e **atrasos**

**Patricia:** E vamos implementar **todos os benefícios** automaticamente:
- **Vale alimentação** e **vale transporte**
- **Plano de saúde** e **seguro de vida**
- **Adiantamentos** e **empréstimos**
- **Descontos** diversos

### **08:30 - Arquitetura da Folha de Pagamento Automática**

**Carlos:** Vou projetar uma arquitetura que seja **100% automática e confiável**:

```python
# NOVA ARQUITETURA - 8 COMPONENTES PRINCIPAIS

# 1. CONFIGURAÇÃO SALARIAL
class ConfiguracaoSalarial(db.Model):
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    salario_base = db.Column(db.Numeric(10, 2))  # Salário base
    tipo_salario = db.Column(db.String(20))  # MENSAL, HORISTA, COMISSIONADO
    valor_hora = db.Column(db.Numeric(10, 2))  # Para horistas
    percentual_comissao = db.Column(db.Numeric(5, 2))  # Para comissionados
    carga_horaria_mensal = db.Column(db.Integer, default=220)  # Horas/mês
    data_inicio = db.Column(db.Date)
    data_fim = db.Column(db.Date)
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))

# 2. BENEFÍCIOS E DESCONTOS
class BeneficioFuncionario(db.Model):
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    tipo_beneficio = db.Column(db.String(50))  # VR, VT, PLANO_SAUDE, etc.
    valor = db.Column(db.Numeric(10, 2))
    percentual_desconto = db.Column(db.Numeric(5, 2))  # % descontado do funcionário
    ativo = db.Column(db.Boolean, default=True)
    data_inicio = db.Column(db.Date)
    data_fim = db.Column(db.Date)
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))

# 3. CÁLCULO MENSAL DE HORAS
class CalculoHorasMensal(db.Model):
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    mes_referencia = db.Column(db.Date)  # Primeiro dia do mês
    horas_normais = db.Column(db.Numeric(8, 2))
    horas_extras_50 = db.Column(db.Numeric(8, 2))  # Extras 50%
    horas_extras_100 = db.Column(db.Numeric(8, 2))  # Extras 100%
    horas_noturnas = db.Column(db.Numeric(8, 2))  # Adicional noturno
    horas_dsr = db.Column(db.Numeric(8, 2))  # Descanso semanal
    faltas_horas = db.Column(db.Numeric(8, 2))
    atrasos_horas = db.Column(db.Numeric(8, 2))
    dias_trabalhados = db.Column(db.Integer)
    dias_faltas = db.Column(db.Integer)
    processado_em = db.Column(db.DateTime, default=datetime.utcnow)
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))

# 4. FOLHA DE PAGAMENTO MENSAL
class FolhaPagamento(db.Model):
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    mes_referencia = db.Column(db.Date)
    
    # PROVENTOS
    salario_base = db.Column(db.Numeric(10, 2))
    horas_extras = db.Column(db.Numeric(10, 2))
    adicional_noturno = db.Column(db.Numeric(10, 2))
    dsr = db.Column(db.Numeric(10, 2))
    comissoes = db.Column(db.Numeric(10, 2))
    bonus = db.Column(db.Numeric(10, 2))
    outros_proventos = db.Column(db.Numeric(10, 2))
    total_proventos = db.Column(db.Numeric(10, 2))
    
    # DESCONTOS
    inss = db.Column(db.Numeric(10, 2))
    irrf = db.Column(db.Numeric(10, 2))
    fgts = db.Column(db.Numeric(10, 2))
    vale_refeicao = db.Column(db.Numeric(10, 2))
    vale_transporte = db.Column(db.Numeric(10, 2))
    plano_saude = db.Column(db.Numeric(10, 2))
    faltas = db.Column(db.Numeric(10, 2))
    atrasos = db.Column(db.Numeric(10, 2))
    adiantamentos = db.Column(db.Numeric(10, 2))
    outros_descontos = db.Column(db.Numeric(10, 2))
    total_descontos = db.Column(db.Numeric(10, 2))
    
    # LÍQUIDO
    salario_liquido = db.Column(db.Numeric(10, 2))
    
    # CONTROLE
    status = db.Column(db.String(20), default='CALCULADO')  # CALCULADO, APROVADO, PAGO
    calculado_em = db.Column(db.DateTime, default=datetime.utcnow)
    aprovado_em = db.Column(db.DateTime)
    aprovado_por = db.Column(db.Integer, db.ForeignKey('usuario.id'))
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))

# 5. LANÇAMENTOS RECORRENTES
class LancamentoRecorrente(db.Model):
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    tipo = db.Column(db.String(20))  # PROVENTO, DESCONTO
    descricao = db.Column(db.String(100))
    valor = db.Column(db.Numeric(10, 2))
    percentual = db.Column(db.Numeric(5, 2))  # Se for percentual do salário
    dia_vencimento = db.Column(db.Integer)  # Dia do mês
    ativo = db.Column(db.Boolean, default=True)
    data_inicio = db.Column(db.Date)
    data_fim = db.Column(db.Date)
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))

# 6. ADIANTAMENTOS
class Adiantamento(db.Model):
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    valor = db.Column(db.Numeric(10, 2))
    data_solicitacao = db.Column(db.Date)
    data_aprovacao = db.Column(db.Date)
    aprovado_por = db.Column(db.Integer, db.ForeignKey('usuario.id'))
    parcelas = db.Column(db.Integer, default=1)
    valor_parcela = db.Column(db.Numeric(10, 2))
    parcelas_pagas = db.Column(db.Integer, default=0)
    status = db.Column(db.String(20))  # SOLICITADO, APROVADO, QUITADO
    observacoes = db.Column(db.Text)
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))

# 7. FÉRIAS E 13º
class FeriasDecimo(db.Model):
    funcionario_id = db.Column(db.Integer, db.ForeignKey('funcionario.id'))
    tipo = db.Column(db.String(20))  # FERIAS, DECIMO_TERCEIRO
    ano_referencia = db.Column(db.Integer)
    periodo_inicio = db.Column(db.Date)
    periodo_fim = db.Column(db.Date)
    dias_direito = db.Column(db.Integer)
    dias_gozados = db.Column(db.Integer)
    valor_calculado = db.Column(db.Numeric(10, 2))
    terco_constitucional = db.Column(db.Numeric(10, 2))  # 1/3 férias
    status = db.Column(db.String(20))  # CALCULADO, PAGO
    data_pagamento = db.Column(db.Date)
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))

# 8. PARÂMETROS LEGAIS
class ParametrosLegais(db.Model):
    admin_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))
    ano_vigencia = db.Column(db.Integer)
    
    # INSS
    inss_faixa1_limite = db.Column(db.Numeric(10, 2))
    inss_faixa1_percentual = db.Column(db.Numeric(5, 2))
    inss_faixa2_limite = db.Column(db.Numeric(10, 2))
    inss_faixa2_percentual = db.Column(db.Numeric(5, 2))
    inss_faixa3_limite = db.Column(db.Numeric(10, 2))
    inss_faixa3_percentual = db.Column(db.Numeric(5, 2))
    inss_teto = db.Column(db.Numeric(10, 2))
    
    # IRRF
    irrf_isencao = db.Column(db.Numeric(10, 2))
    irrf_faixa1_limite = db.Column(db.Numeric(10, 2))
    irrf_faixa1_percentual = db.Column(db.Numeric(5, 2))
    irrf_faixa2_limite = db.Column(db.Numeric(10, 2))
    irrf_faixa2_percentual = db.Column(db.Numeric(5, 2))
    irrf_faixa3_limite = db.Column(db.Numeric(10, 2))
    irrf_faixa3_percentual = db.Column(db.Numeric(5, 2))
    irrf_faixa4_percentual = db.Column(db.Numeric(5, 2))
    
    # OUTROS
    fgts_percentual = db.Column(db.Numeric(5, 2), default=8.0)
    salario_minimo = db.Column(db.Numeric(10, 2))
    vale_transporte_percentual = db.Column(db.Numeric(5, 2), default=6.0)
    adicional_noturno_percentual = db.Column(db.Numeric(5, 2), default=20.0)
    hora_extra_50_percentual = db.Column(db.Numeric(5, 2), default=50.0)
    hora_extra_100_percentual = db.Column(db.Numeric(5, 2), default=100.0)
```

**Ana:** Perfeito! E vou implementar **cache inteligente** dos cálculos para performance:
- **Cache** de parâmetros legais por ano
- **Invalidação automática** quando parâmetros mudam
- **Cálculos incrementais** para otimização

### **08:45 - Cálculos Automáticos da CLT**

**Dra. Carla:** A precisão dos cálculos é fundamental. Vamos implementar **todas as regras da CLT**:

**Cálculo de Horas Extras:**
```python
def calcular_horas_extras(funcionario_id, data_inicio, data_fim):
    """Calcular horas extras com precisão CLT"""
    
    pontos = Ponto.query.filter(
        Ponto.funcionario_id == funcionario_id,
        Ponto.data_ponto.between(data_inicio, data_fim)
    ).all()
    
    horas_extras_50 = 0
    horas_extras_100 = 0
    
    for ponto in pontos:
        if ponto.hora_entrada and ponto.hora_saida:
            # Calcular horas trabalhadas
            entrada = datetime.combine(ponto.data_ponto, ponto.hora_entrada)
            saida = datetime.combine(ponto.data_ponto, ponto.hora_saida)
            
            # Se saída for no dia seguinte
            if ponto.hora_saida < ponto.hora_entrada:
                saida += timedelta(days=1)
            
            horas_trabalhadas = (saida - entrada).total_seconds() / 3600
            
            # Descontar intervalo (1h para jornada > 6h)
            if horas_trabalhadas > 6:
                horas_trabalhadas -= 1
            
            # Verificar se é domingo (100%) ou dia útil (50%)
            if ponto.data_ponto.weekday() == 6:  # Domingo
                if horas_trabalhadas > 8:
                    horas_extras_100 += horas_trabalhadas - 8
                elif horas_trabalhadas > 0:
                    horas_extras_100 += horas_trabalhadas  # Todo domingo é 100%
            else:  # Dias úteis
                if horas_trabalhadas > 8:
                    # Primeiras 2h extras = 50%, depois 100%
                    extras = horas_trabalhadas - 8
                    if extras <= 2:
                        horas_extras_50 += extras
                    else:
                        horas_extras_50 += 2
                        horas_extras_100 += extras - 2
    
    return horas_extras_50, horas_extras_100
```

**Cálculo de Adicional Noturno:**
```python
def calcular_adicional_noturno(funcionario_id, data_inicio, data_fim):
    """Calcular adicional noturno (22h às 5h)"""
    
    pontos = Ponto.query.filter(
        Ponto.funcionario_id == funcionario_id,
        Ponto.data_ponto.between(data_inicio, data_fim)
    ).all()
    
    horas_noturnas = 0
    
    for ponto in pontos:
        if ponto.hora_entrada and ponto.hora_saida:
            entrada = ponto.hora_entrada
            saida = ponto.hora_saida
            
            # Período noturno: 22h às 5h
            inicio_noturno = time(22, 0)
            fim_noturno = time(5, 0)
            
            # Calcular interseção com período noturno
            if entrada <= fim_noturno or entrada >= inicio_noturno:
                # Trabalhou no período noturno
                if saida <= fim_noturno:
                    # Saída antes das 5h
                    if entrada >= inicio_noturno:
                        # Entrada após 22h
                        horas_noturnas += (datetime.combine(date.today(), saida) - 
                                         datetime.combine(date.today(), entrada)).total_seconds() / 3600
                    else:
                        # Entrada antes das 5h
                        horas_noturnas += (datetime.combine(date.today(), saida) - 
                                         datetime.combine(date.today(), time(0, 0))).total_seconds() / 3600
                elif entrada >= inicio_noturno:
                    # Entrada após 22h, saída após 5h
                    horas_noturnas += (datetime.combine(date.today(), time(23, 59, 59)) - 
                                     datetime.combine(date.today(), entrada)).total_seconds() / 3600
                    horas_noturnas += 5  # Das 0h às 5h
    
    return horas_noturnas
```

**Prof. Ricardo:** E vamos implementar **DSR automático**:
```python
def calcular_dsr(funcionario_id, mes_referencia):
    """Calcular Descanso Semanal Remunerado"""
    
    # DSR = (Horas extras + Adicional noturno + Comissões) / Dias úteis * Domingos e feriados
    
    inicio_mes = mes_referencia.replace(day=1)
    fim_mes = (inicio_mes + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    
    # Contar domingos e feriados no mês
    domingos_feriados = 0
    dias_uteis = 0
    
    data_atual = inicio_mes
    while data_atual <= fim_mes:
        if data_atual.weekday() == 6:  # Domingo
            domingos_feriados += 1
        elif data_atual.weekday() < 5:  # Segunda a sexta
            dias_uteis += 1
        data_atual += timedelta(days=1)
    
    # Obter valores que compõem o DSR
    calculo_horas = CalculoHorasMensal.query.filter_by(
        funcionario_id=funcionario_id,
        mes_referencia=inicio_mes
    ).first()
    
    if not calculo_horas or dias_uteis == 0:
        return 0
    
    # Calcular valor hora
    config_salarial = ConfiguracaoSalarial.query.filter_by(
        funcionario_id=funcionario_id
    ).filter(
        ConfiguracaoSalarial.data_inicio <= fim_mes,
        or_(ConfiguracaoSalarial.data_fim.is_(None), 
            ConfiguracaoSalarial.data_fim >= inicio_mes)
    ).first()
    
    if not config_salarial:
        return 0
    
    valor_hora = config_salarial.valor_hora or (config_salarial.salario_base / config_salarial.carga_horaria_mensal)
    
    # Base de cálculo do DSR
    base_dsr = (
        (calculo_horas.horas_extras_50 * valor_hora * 1.5) +
        (calculo_horas.horas_extras_100 * valor_hora * 2.0) +
        (calculo_horas.horas_noturnas * valor_hora * 0.2)
    )
    
    # DSR = Base / Dias úteis * Domingos e feriados
    dsr = (base_dsr / dias_uteis) * domingos_feriados if dias_uteis > 0 else 0
    
    return dsr
```

### **09:00 - Cálculos de INSS, IRRF e FGTS**

**Dra. Carla:** Vamos implementar os cálculos **exatos** dos impostos:

**Cálculo de INSS (Progressivo):**
```python
def calcular_inss(salario_bruto, parametros_legais):
    """Calcular INSS com tabela progressiva"""
    
    if salario_bruto <= parametros_legais.inss_faixa1_limite:
        return salario_bruto * (parametros_legais.inss_faixa1_percentual / 100)
    
    elif salario_bruto <= parametros_legais.inss_faixa2_limite:
        inss = parametros_legais.inss_faixa1_limite * (parametros_legais.inss_faixa1_percentual / 100)
        inss += (salario_bruto - parametros_legais.inss_faixa1_limite) * (parametros_legais.inss_faixa2_percentual / 100)
        return inss
    
    elif salario_bruto <= parametros_legais.inss_faixa3_limite:
        inss = parametros_legais.inss_faixa1_limite * (parametros_legais.inss_faixa1_percentual / 100)
        inss += (parametros_legais.inss_faixa2_limite - parametros_legais.inss_faixa1_limite) * (parametros_legais.inss_faixa2_percentual / 100)
        inss += (salario_bruto - parametros_legais.inss_faixa2_limite) * (parametros_legais.inss_faixa3_percentual / 100)
        return inss
    
    else:
        # Teto do INSS
        return parametros_legais.inss_teto

def calcular_irrf(salario_bruto, inss, dependentes, parametros_legais):
    """Calcular IRRF com tabela progressiva"""
    
    # Base de cálculo = Salário bruto - INSS - (Dependentes * 189.59)
    base_calculo = salario_bruto - inss - (dependentes * 189.59)
    
    if base_calculo <= parametros_legais.irrf_isencao:
        return 0
    
    elif base_calculo <= parametros_legais.irrf_faixa1_limite:
        irrf = base_calculo * (parametros_legais.irrf_faixa1_percentual / 100)
        return max(0, irrf - 142.80)  # Dedução da primeira faixa
    
    elif base_calculo <= parametros_legais.irrf_faixa2_limite:
        irrf = base_calculo * (parametros_legais.irrf_faixa2_percentual / 100)
        return max(0, irrf - 354.80)  # Dedução da segunda faixa
    
    elif base_calculo <= parametros_legais.irrf_faixa3_limite:
        irrf = base_calculo * (parametros_legais.irrf_faixa3_percentual / 100)
        return max(0, irrf - 636.13)  # Dedução da terceira faixa
    
    else:
        irrf = base_calculo * (parametros_legais.irrf_faixa4_percentual / 100)
        return max(0, irrf - 869.36)  # Dedução da quarta faixa

def calcular_fgts(salario_bruto, parametros_legais):
    """Calcular FGTS (8% sobre salário bruto)"""
    return salario_bruto * (parametros_legais.fgts_percentual / 100)
```

**Ana:** E vou implementar **validações automáticas**:
- **Verificar** se cálculos estão dentro dos limites legais
- **Alertar** sobre inconsistências
- **Sugerir** correções automáticas
- **Gerar** relatórios de conformidade

### **09:15 - Sistema de Benefícios Automático**

**Patricia:** Como gerenciar benefícios automaticamente?

**Carlos:** Vou criar sistema **inteligente de benefícios**:

```python
def processar_beneficios_automaticos(funcionario_id, mes_referencia):
    """Processar benefícios automáticos do funcionário"""
    
    beneficios = BeneficioFuncionario.query.filter_by(
        funcionario_id=funcionario_id,
        ativo=True
    ).filter(
        BeneficioFuncionario.data_inicio <= mes_referencia,
        or_(BeneficioFuncionario.data_fim.is_(None), 
            BeneficioFuncionario.data_fim >= mes_referencia)
    ).all()
    
    total_beneficios = 0
    total_descontos = 0
    detalhes_beneficios = {}
    
    for beneficio in beneficios:
        if beneficio.tipo_beneficio == 'VALE_REFEICAO':
            # Vale refeição por dias trabalhados
            dias_trabalhados = contar_dias_trabalhados(funcionario_id, mes_referencia)
            valor_total = beneficio.valor * dias_trabalhados
            desconto = valor_total * (beneficio.percentual_desconto / 100)
            
            total_beneficios += valor_total
            total_descontos += desconto
            detalhes_beneficios['vale_refeicao'] = {
                'valor_total': valor_total,
                'desconto': desconto,
                'dias': dias_trabalhados
            }
            
        elif beneficio.tipo_beneficio == 'VALE_TRANSPORTE':
            # Vale transporte com limite de 6% do salário
            config_salarial = obter_configuracao_salarial(funcionario_id, mes_referencia)
            limite_vt = config_salarial.salario_base * 0.06
            
            dias_trabalhados = contar_dias_trabalhados(funcionario_id, mes_referencia)
            valor_total = beneficio.valor * dias_trabalhados * 2  # Ida e volta
            desconto = min(valor_total, limite_vt)
            
            total_beneficios += valor_total
            total_descontos += desconto
            detalhes_beneficios['vale_transporte'] = {
                'valor_total': valor_total,
                'desconto': desconto,
                'limite': limite_vt
            }
            
        elif beneficio.tipo_beneficio == 'PLANO_SAUDE':
            # Plano de saúde - desconto fixo
            total_descontos += beneficio.valor
            detalhes_beneficios['plano_saude'] = {
                'desconto': beneficio.valor
            }
            
        elif beneficio.tipo_beneficio == 'SEGURO_VIDA':
            # Seguro de vida - desconto fixo
            total_descontos += beneficio.valor
            detalhes_beneficios['seguro_vida'] = {
                'desconto': beneficio.valor
            }
    
    return total_beneficios, total_descontos, detalhes_beneficios

def processar_lancamentos_recorrentes(funcionario_id, mes_referencia):
    """Processar lançamentos recorrentes (adiantamentos, empréstimos, etc.)"""
    
    lancamentos = LancamentoRecorrente.query.filter_by(
        funcionario_id=funcionario_id,
        ativo=True
    ).filter(
        LancamentoRecorrente.data_inicio <= mes_referencia,
        or_(LancamentoRecorrente.data_fim.is_(None), 
            LancamentoRecorrente.data_fim >= mes_referencia)
    ).all()
    
    total_proventos = 0
    total_descontos = 0
    detalhes = {}
    
    for lancamento in lancamentos:
        if lancamento.percentual:
            # Calcular baseado no percentual do salário
            config_salarial = obter_configuracao_salarial(funcionario_id, mes_referencia)
            valor = config_salarial.salario_base * (lancamento.percentual / 100)
        else:
            valor = lancamento.valor
        
        if lancamento.tipo == 'PROVENTO':
            total_proventos += valor
        else:
            total_descontos += valor
        
        detalhes[lancamento.descricao] = {
            'tipo': lancamento.tipo,
            'valor': valor
        }
    
    return total_proventos, total_descontos, detalhes
```

### **09:30 - Processamento Automático da Folha**

**Marina:** Como será o fluxo completo de processamento?

**Carlos:** Vou desenhar o fluxo **100% automático**:

```python
def processar_folha_mensal(admin_id, mes_referencia):
    """Processar folha de pagamento completa do mês"""
    
    inicio_mes = mes_referencia.replace(day=1)
    fim_mes = (inicio_mes + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    
    # Obter todos os funcionários ativos
    funcionarios = Funcionario.query.filter_by(
        admin_id=admin_id,
        ativo=True
    ).all()
    
    # Obter parâmetros legais do ano
    parametros = ParametrosLegais.query.filter_by(
        admin_id=admin_id,
        ano_vigencia=mes_referencia.year
    ).first()
    
    if not parametros:
        raise Exception(f"Parâmetros legais não configurados para {mes_referencia.year}")
    
    resultados = []
    
    for funcionario in funcionarios:
        try:
            # 1. CALCULAR HORAS TRABALHADAS
            calculo_horas = calcular_horas_mensal(funcionario.id, inicio_mes, fim_mes)
            
            # 2. OBTER CONFIGURAÇÃO SALARIAL
            config_salarial = obter_configuracao_salarial(funcionario.id, mes_referencia)
            if not config_salarial:
                continue
            
            # 3. CALCULAR PROVENTOS
            proventos = calcular_proventos(funcionario, config_salarial, calculo_horas, parametros)
            
            # 4. CALCULAR DESCONTOS
            descontos = calcular_descontos(funcionario, proventos, parametros, mes_referencia)
            
            # 5. PROCESSAR BENEFÍCIOS
            beneficios_valor, beneficios_desconto, detalhes_beneficios = processar_beneficios_automaticos(
                funcionario.id, mes_referencia
            )
            
            # 6. PROCESSAR LANÇAMENTOS RECORRENTES
            recorrentes_proventos, recorrentes_descontos, detalhes_recorrentes = processar_lancamentos_recorrentes(
                funcionario.id, mes_referencia
            )
            
            # 7. PROCESSAR ADIANTAMENTOS
            adiantamentos_desconto = processar_adiantamentos_mes(funcionario.id, mes_referencia)
            
            # 8. CALCULAR TOTAIS
            total_proventos = (
                proventos['salario_base'] +
                proventos['horas_extras'] +
                proventos['adicional_noturno'] +
                proventos['dsr'] +
                proventos['comissoes'] +
                recorrentes_proventos +
                beneficios_valor
            )
            
            total_descontos = (
                descontos['inss'] +
                descontos['irrf'] +
                descontos['fgts'] +
                beneficios_desconto +
                recorrentes_descontos +
                adiantamentos_desconto +
                proventos['faltas'] +
                proventos['atrasos']
            )
            
            salario_liquido = total_proventos - total_descontos
            
            # 9. SALVAR FOLHA DE PAGAMENTO
            folha = FolhaPagamento(
                funcionario_id=funcionario.id,
                mes_referencia=inicio_mes,
                
                # Proventos
                salario_base=proventos['salario_base'],
                horas_extras=proventos['horas_extras'],
                adicional_noturno=proventos['adicional_noturno'],
                dsr=proventos['dsr'],
                comissoes=proventos['comissoes'],
                outros_proventos=recorrentes_proventos,
                total_proventos=total_proventos,
                
                # Descontos
                inss=descontos['inss'],
                irrf=descontos['irrf'],
                fgts=descontos['fgts'],
                vale_refeicao=detalhes_beneficios.get('vale_refeicao', {}).get('desconto', 0),
                vale_transporte=detalhes_beneficios.get('vale_transporte', {}).get('desconto', 0),
                plano_saude=detalhes_beneficios.get('plano_saude', {}).get('desconto', 0),
                faltas=proventos['faltas'],
                atrasos=proventos['atrasos'],
                adiantamentos=adiantamentos_desconto,
                outros_descontos=recorrentes_descontos,
                total_descontos=total_descontos,
                
                # Líquido
                salario_liquido=salario_liquido,
                
                admin_id=admin_id
            )
            
            db.session.add(folha)
            
            resultados.append({
                'funcionario': funcionario,
                'folha': folha,
                'sucesso': True
            })
            
        except Exception as e:
            resultados.append({
                'funcionario': funcionario,
                'erro': str(e),
                'sucesso': False
            })
    
    db.session.commit()
    
    return resultados

def calcular_proventos(funcionario, config_salarial, calculo_horas, parametros):
    """Calcular todos os proventos do funcionário"""
    
    valor_hora = config_salarial.valor_hora or (config_salarial.salario_base / config_salarial.carga_horaria_mensal)
    
    # Salário base proporcional aos dias trabalhados
    if config_salarial.tipo_salario == 'HORISTA':
        salario_base = calculo_horas.horas_normais * valor_hora
    else:
        # Salário mensal proporcional
        dias_mes = calendar.monthrange(calculo_horas.mes_referencia.year, calculo_horas.mes_referencia.month)[1]
        salario_base = config_salarial.salario_base * (calculo_horas.dias_trabalhados / dias_mes)
    
    # Horas extras
    horas_extras = (
        (calculo_horas.horas_extras_50 * valor_hora * 1.5) +
        (calculo_horas.horas_extras_100 * valor_hora * 2.0)
    )
    
    # Adicional noturno
    adicional_noturno = calculo_horas.horas_noturnas * valor_hora * (parametros.adicional_noturno_percentual / 100)
    
    # DSR
    dsr = calcular_dsr(funcionario.id, calculo_horas.mes_referencia)
    
    # Comissões (se aplicável)
    comissoes = 0
    if config_salarial.tipo_salario == 'COMISSIONADO':
        # Calcular comissões baseado nas vendas/obras
        comissoes = calcular_comissoes_funcionario(funcionario.id, calculo_horas.mes_referencia)
    
    # Descontos por faltas e atrasos
    faltas = calculo_horas.faltas_horas * valor_hora
    atrasos = calculo_horas.atrasos_horas * valor_hora
    
    return {
        'salario_base': salario_base,
        'horas_extras': horas_extras,
        'adicional_noturno': adicional_noturno,
        'dsr': dsr,
        'comissoes': comissoes,
        'faltas': faltas,
        'atrasos': atrasos
    }

def calcular_descontos(funcionario, proventos, parametros, mes_referencia):
    """Calcular todos os descontos obrigatórios"""
    
    salario_bruto = (
        proventos['salario_base'] +
        proventos['horas_extras'] +
        proventos['adicional_noturno'] +
        proventos['dsr'] +
        proventos['comissoes']
    )
    
    # INSS
    inss = calcular_inss(salario_bruto, parametros)
    
    # IRRF
    dependentes = funcionario.dependentes or 0
    irrf = calcular_irrf(salario_bruto, inss, dependentes, parametros)
    
    # FGTS (não é desconto, mas é calculado)
    fgts = calcular_fgts(salario_bruto, parametros)
    
    return {
        'inss': inss,
        'irrf': irrf,
        'fgts': fgts
    }
```

### **09:45 - Integração com Módulos Anteriores**

**Marina:** Como este módulo se integra com os anteriores?

**Carlos:** Integração **perfeita e inteligente**:

**Com Módulo 1 (Propostas):**
- **Comissões** calculadas automaticamente baseado em propostas aprovadas
- **Metas** de vendas integradas com bonificações

**Com Módulo 2 (Portal Cliente):**
- **Cliente** pode ver custos de mão de obra em tempo real
- **Transparência** total sobre investimento em equipe

**Com Módulo 3 (Gestão Equipes):**
- **Alocação** por obra alimenta cálculo de comissões
- **Produtividade** por funcionário medida automaticamente

**Com Módulo 4 (Almoxarifado):**
- **Custos** de materiais vs mão de obra comparados
- **Eficiência** da equipe medida por consumo de materiais

**Com Módulo 5 (Reconhecimento Facial):**
- **Pontos automáticos** alimentam folha sem intervenção humana
- **Precisão total** de horas trabalhadas
- **Zero fraude** no controle de ponto

**Ana:** E prepara terreno para o próximo módulo:

**Módulo 7 (Contabilidade):**
- **Lançamentos automáticos** de folha de pagamento
- **Provisões** de 13º, férias e encargos
- **DRE** com custos de pessoal detalhados

### **10:00 - Dashboard e Relatórios Avançados**

**Lucia:** Vou criar **dashboard inteligente** para RH:

**Métricas em Tempo Real:**
- **Custo total** da folha por mês
- **Evolução salarial** por funcionário
- **Comparativo** de horas extras
- **Eficiência** da equipe por obra
- **Projeções** de custos futuros

**Relatórios Automáticos:**
- **Holerite** individual detalhado
- **Resumo da folha** para contabilidade
- **Relatório de encargos** para provisões
- **Análise de produtividade** por funcionário
- **Comparativo mensal** de custos

```python
def gerar_dashboard_rh(admin_id, mes_referencia):
    """Gerar dashboard completo para RH"""
    
    # Métricas do mês atual
    folhas_mes = FolhaPagamento.query.filter_by(
        admin_id=admin_id,
        mes_referencia=mes_referencia
    ).all()
    
    # Métricas do mês anterior para comparação
    mes_anterior = (mes_referencia - timedelta(days=1)).replace(day=1)
    folhas_anterior = FolhaPagamento.query.filter_by(
        admin_id=admin_id,
        mes_referencia=mes_anterior
    ).all()
    
    # Calcular totais
    total_folha_atual = sum(f.total_proventos for f in folhas_mes)
    total_folha_anterior = sum(f.total_proventos for f in folhas_anterior)
    total_liquido_atual = sum(f.salario_liquido for f in folhas_mes)
    total_encargos_atual = sum(f.inss + f.fgts for f in folhas_mes)
    
    # Variação percentual
    variacao_folha = ((total_folha_atual - total_folha_anterior) / total_folha_anterior * 100) if total_folha_anterior > 0 else 0
    
    # Análise por funcionário
    funcionarios_stats = []
    for folha in folhas_mes:
        horas_extras_total = folha.horas_extras
        percentual_extras = (horas_extras_total / folha.salario_base * 100) if folha.salario_base > 0 else 0
        
        funcionarios_stats.append({
            'funcionario': folha.funcionario,
            'salario_bruto': folha.total_proventos,
            'salario_liquido': folha.salario_liquido,
            'horas_extras': horas_extras_total,
            'percentual_extras': percentual_extras,
            'eficiencia': calcular_eficiencia_funcionario(folha.funcionario_id, mes_referencia)
        })
    
    # Top 5 maiores salários
    top_salarios = sorted(funcionarios_stats, key=lambda x: x['salario_bruto'], reverse=True)[:5]
    
    # Top 5 mais horas extras
    top_extras = sorted(funcionarios_stats, key=lambda x: x['horas_extras'], reverse=True)[:5]
    
    return {
        'total_folha': total_folha_atual,
        'total_liquido': total_liquido_atual,
        'total_encargos': total_encargos_atual,
        'variacao_folha': variacao_folha,
        'total_funcionarios': len(folhas_mes),
        'media_salarial': total_folha_atual / len(folhas_mes) if folhas_mes else 0,
        'top_salarios': top_salarios,
        'top_extras': top_extras,
        'funcionarios_stats': funcionarios_stats
    }

def gerar_holerite_pdf(funcionario_id, mes_referencia):
    """Gerar holerite em PDF"""
    
    folha = FolhaPagamento.query.filter_by(
        funcionario_id=funcionario_id,
        mes_referencia=mes_referencia
    ).first()
    
    if not folha:
        return None
    
    # Gerar PDF usando reportlab
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    
    filename = f"holerite_{funcionario_id}_{mes_referencia.strftime('%Y_%m')}.pdf"
    filepath = os.path.join('static/holerites', filename)
    os.makedirs('static/holerites', exist_ok=True)
    
    c = canvas.Canvas(filepath, pagesize=A4)
    
    # Cabeçalho
    c.setFont("Helvetica-Bold", 16)
    c.drawString(50, 800, "DEMONSTRATIVO DE PAGAMENTO")
    
    # Dados da empresa
    c.setFont("Helvetica", 10)
    c.drawString(50, 770, f"Empresa: {folha.funcionario.admin.nome}")
    c.drawString(50, 755, f"CNPJ: {folha.funcionario.admin.cnpj}")
    
    # Dados do funcionário
    c.drawString(50, 730, f"Funcionário: {folha.funcionario.nome}")
    c.drawString(50, 715, f"Matrícula: {folha.funcionario.matricula}")
    c.drawString(50, 700, f"Cargo: {folha.funcionario.cargo}")
    c.drawString(50, 685, f"Período: {mes_referencia.strftime('%m/%Y')}")
    
    # Tabela de proventos e descontos
    y_pos = 650
    
    # Cabeçalho da tabela
    c.setFont("Helvetica-Bold", 10)
    c.drawString(50, y_pos, "DESCRIÇÃO")
    c.drawString(300, y_pos, "PROVENTOS")
    c.drawString(400, y_pos, "DESCONTOS")
    
    # Linha
    c.line(50, y_pos-5, 500, y_pos-5)
    y_pos -= 20
    
    # Proventos
    c.setFont("Helvetica", 9)
    if folha.salario_base > 0:
        c.drawString(50, y_pos, "Salário Base")
        c.drawString(300, y_pos, f"R$ {folha.salario_base:.2f}")
        y_pos -= 15
    
    if folha.horas_extras > 0:
        c.drawString(50, y_pos, "Horas Extras")
        c.drawString(300, y_pos, f"R$ {folha.horas_extras:.2f}")
        y_pos -= 15
    
    if folha.adicional_noturno > 0:
        c.drawString(50, y_pos, "Adicional Noturno")
        c.drawString(300, y_pos, f"R$ {folha.adicional_noturno:.2f}")
        y_pos -= 15
    
    if folha.dsr > 0:
        c.drawString(50, y_pos, "DSR")
        c.drawString(300, y_pos, f"R$ {folha.dsr:.2f}")
        y_pos -= 15
    
    # Descontos
    y_pos = 650 - 20
    if folha.inss > 0:
        c.drawString(50, y_pos, "INSS")
        c.drawString(400, y_pos, f"R$ {folha.inss:.2f}")
        y_pos -= 15
    
    if folha.irrf > 0:
        c.drawString(50, y_pos, "IRRF")
        c.drawString(400, y_pos, f"R$ {folha.irrf:.2f}")
        y_pos -= 15
    
    if folha.vale_refeicao > 0:
        c.drawString(50, y_pos, "Vale Refeição")
        c.drawString(400, y_pos, f"R$ {folha.vale_refeicao:.2f}")
        y_pos -= 15
    
    if folha.vale_transporte > 0:
        c.drawString(50, y_pos, "Vale Transporte")
        c.drawString(400, y_pos, f"R$ {folha.vale_transporte:.2f}")
        y_pos -= 15
    
    # Totais
    y_pos = 400
    c.line(50, y_pos, 500, y_pos)
    y_pos -= 20
    
    c.setFont("Helvetica-Bold", 10)
    c.drawString(50, y_pos, "TOTAL PROVENTOS")
    c.drawString(300, y_pos, f"R$ {folha.total_proventos:.2f}")
    c.drawString(50, y_pos-15, "TOTAL DESCONTOS")
    c.drawString(400, y_pos-15, f"R$ {folha.total_descontos:.2f}")
    
    c.line(50, y_pos-25, 500, y_pos-25)
    c.setFont("Helvetica-Bold", 12)
    c.drawString(50, y_pos-40, "SALÁRIO LÍQUIDO")
    c.drawString(350, y_pos-40, f"R$ {folha.salario_liquido:.2f}")
    
    c.save()
    
    return filepath
```

### **10:15 - Automação de Férias e 13º Salário**

**Dra. Carla:** Como calcular férias e 13º automaticamente?

**Prof. Ricardo:** Vou implementar **cálculos automáticos** baseados na CLT:

```python
def calcular_ferias_automatico(funcionario_id, ano_referencia):
    """Calcular férias automático baseado na CLT"""
    
    funcionario = Funcionario.query.get(funcionario_id)
    if not funcionario:
        return None
    
    # Período aquisitivo: 12 meses após admissão
    data_admissao = funcionario.data_admissao
    inicio_periodo = data_admissao.replace(year=ano_referencia)
    fim_periodo = inicio_periodo.replace(year=ano_referencia + 1) - timedelta(days=1)
    
    # Contar faltas injustificadas no período
    faltas_injustificadas = contar_faltas_injustificadas(funcionario_id, inicio_periodo, fim_periodo)
    
    # Calcular dias de direito baseado nas faltas
    if faltas_injustificadas <= 5:
        dias_direito = 30
    elif faltas_injustificadas <= 14:
        dias_direito = 24
    elif faltas_injustificadas <= 23:
        dias_direito = 18
    elif faltas_injustificadas <= 32:
        dias_direito = 12
    else:
        dias_direito = 0  # Perde o direito às férias
    
    if dias_direito == 0:
        return None
    
    # Calcular valor das férias
    config_salarial = obter_configuracao_salarial(funcionario_id, fim_periodo)
    if not config_salarial:
        return None
    
    # Média dos últimos 12 meses para cálculo
    media_salarial = calcular_media_salarial_12_meses(funcionario_id, fim_periodo)
    
    # Valor das férias proporcionais
    valor_ferias = (media_salarial / 30) * dias_direito
    
    # 1/3 constitucional
    terco_constitucional = valor_ferias / 3
    
    # Criar registro de férias
    ferias = FeriasDecimo(
        funcionario_id=funcionario_id,
        tipo='FERIAS',
        ano_referencia=ano_referencia,
        periodo_inicio=inicio_periodo,
        periodo_fim=fim_periodo,
        dias_direito=dias_direito,
        valor_calculado=valor_ferias,
        terco_constitucional=terco_constitucional,
        status='CALCULADO',
        admin_id=funcionario.admin_id
    )
    
    db.session.add(ferias)
    db.session.commit()
    
    return ferias

def calcular_decimo_terceiro_automatico(funcionario_id, ano_referencia):
    """Calcular 13º salário automático"""
    
    funcionario = Funcionario.query.get(funcionario_id)
    if not funcionario:
        return None
    
    # 13º é calculado baseado nos meses trabalhados no ano
    inicio_ano = date(ano_referencia, 1, 1)
    fim_ano = date(ano_referencia, 12, 31)
    
    # Se foi admitido no ano, considerar apenas meses trabalhados
    if funcionario.data_admissao.year == ano_referencia:
        inicio_calculo = funcionario.data_admissao
    else:
        inicio_calculo = inicio_ano
    
    # Contar meses trabalhados (mínimo 15 dias = 1 mês)
    meses_trabalhados = 0
    data_atual = inicio_calculo.replace(day=1)
    
    while data_atual <= fim_ano:
        # Verificar se trabalhou pelo menos 15 dias no mês
        if data_atual.month == inicio_calculo.month and inicio_calculo.day > 15:
            # Primeiro mês, trabalhou menos de 15 dias
            pass
        else:
            meses_trabalhados += 1
        
        # Próximo mês
        if data_atual.month == 12:
            data_atual = data_atual.replace(year=data_atual.year + 1, month=1)
        else:
            data_atual = data_atual.replace(month=data_atual.month + 1)
    
    if meses_trabalhados == 0:
        return None
    
    # Calcular valor do 13º
    media_salarial = calcular_media_salarial_12_meses(funcionario_id, fim_ano)
    valor_decimo = (media_salarial / 12) * meses_trabalhados
    
    # Criar registro de 13º
    decimo = FeriasDecimo(
        funcionario_id=funcionario_id,
        tipo='DECIMO_TERCEIRO',
        ano_referencia=ano_referencia,
        periodo_inicio=inicio_calculo,
        periodo_fim=fim_ano,
        dias_direito=meses_trabalhados * 30,  # Para controle
        valor_calculado=valor_decimo,
        status='CALCULADO',
        admin_id=funcionario.admin_id
    )
    
    db.session.add(decimo)
    db.session.commit()
    
    return decimo

def calcular_media_salarial_12_meses(funcionario_id, data_referencia):
    """Calcular média salarial dos últimos 12 meses"""
    
    # Últimos 12 meses
    fim_periodo = data_referencia.replace(day=1)
    inicio_periodo = (fim_periodo - timedelta(days=365)).replace(day=1)
    
    folhas = FolhaPagamento.query.filter(
        FolhaPagamento.funcionario_id == funcionario_id,
        FolhaPagamento.mes_referencia.between(inicio_periodo, fim_periodo)
    ).all()
    
    if not folhas:
        # Se não tem folhas, usar salário base atual
        config_salarial = obter_configuracao_salarial(funcionario_id, data_referencia)
        return config_salarial.salario_base if config_salarial else 0
    
    # Média dos salários (base + extras + adicionais)
    total_salarios = sum(
        f.salario_base + f.horas_extras + f.adicional_noturno + f.dsr + f.comissoes 
        for f in folhas
    )
    
    return total_salarios / len(folhas)
```

### **10:30 - Conformidade Legal e Auditoria**

**Prof. Ricardo:** Como garantir conformidade total com CLT?

**Dra. Carla:** Vou implementar **sistema de auditoria automática**:

```python
def auditar_folha_pagamento(admin_id, mes_referencia):
    """Auditar folha de pagamento para conformidade CLT"""
    
    folhas = FolhaPagamento.query.filter_by(
        admin_id=admin_id,
        mes_referencia=mes_referencia
    ).all()
    
    alertas = []
    erros = []
    
    for folha in folhas:
        funcionario = folha.funcionario
        
        # 1. Verificar salário mínimo
        parametros = ParametrosLegais.query.filter_by(
            admin_id=admin_id,
            ano_vigencia=mes_referencia.year
        ).first()
        
        if folha.salario_liquido < parametros.salario_minimo:
            erros.append(f"{funcionario.nome}: Salário líquido abaixo do mínimo legal")
        
        # 2. Verificar limite de horas extras
        config_salarial = obter_configuracao_salarial(funcionario.id, mes_referencia)
        valor_hora = config_salarial.valor_hora or (config_salarial.salario_base / config_salarial.carga_horaria_mensal)
        
        if folha.horas_extras > 0:
            horas_extras_quantidade = folha.horas_extras / (valor_hora * 1.5)
            if horas_extras_quantidade > 44:  # Limite mensal de extras
                alertas.append(f"{funcionario.nome}: Excesso de horas extras ({horas_extras_quantidade:.1f}h)")
        
        # 3. Verificar cálculo de INSS
        inss_calculado = calcular_inss(folha.total_proventos, parametros)
        if abs(folha.inss - inss_calculado) > 0.01:
            erros.append(f"{funcionario.nome}: INSS calculado incorretamente")
        
        # 4. Verificar cálculo de IRRF
        irrf_calculado = calcular_irrf(folha.total_proventos, folha.inss, funcionario.dependentes or 0, parametros)
        if abs(folha.irrf - irrf_calculado) > 0.01:
            erros.append(f"{funcionario.nome}: IRRF calculado incorretamente")
        
        # 5. Verificar limite de vale transporte
        if folha.vale_transporte > (folha.salario_base * 0.06):
            alertas.append(f"{funcionario.nome}: Vale transporte acima do limite de 6%")
        
        # 6. Verificar consistência de dados
        if folha.total_proventos - folha.total_descontos != folha.salario_liquido:
            erros.append(f"{funcionario.nome}: Inconsistência no cálculo do salário líquido")
    
    return {
        'total_funcionarios': len(folhas),
        'alertas': alertas,
        'erros': erros,
        'conformidade': len(erros) == 0
    }

def gerar_relatorio_conformidade(admin_id, ano):
    """Gerar relatório anual de conformidade"""
    
    relatorio = {
        'ano': ano,
        'meses_processados': [],
        'total_alertas': 0,
        'total_erros': 0,
        'conformidade_geral': True
    }
    
    for mes in range(1, 13):
        mes_referencia = date(ano, mes, 1)
        auditoria = auditar_folha_pagamento(admin_id, mes_referencia)
        
        relatorio['meses_processados'].append({
            'mes': mes,
            'auditoria': auditoria
        })
        
        relatorio['total_alertas'] += len(auditoria['alertas'])
        relatorio['total_erros'] += len(auditoria['erros'])
        
        if not auditoria['conformidade']:
            relatorio['conformidade_geral'] = False
    
    return relatorio
```

### **10:45 - Integração com eSocial e SEFIP**

**João:** Como integrar com sistemas governamentais?

**Dra. Carla:** Vou implementar **exportação automática** para eSocial:

```python
def gerar_arquivo_esocial(admin_id, mes_referencia):
    """Gerar arquivo XML para eSocial"""
    
    folhas = FolhaPagamento.query.filter_by(
        admin_id=admin_id,
        mes_referencia=mes_referencia
    ).all()
    
    # Estrutura XML do eSocial
    xml_data = {
        'eSocial': {
            'evtRemun': {
                'ideEvento': {
                    'indRetif': '1',
                    'nrRecibo': '',
                    'perApur': mes_referencia.strftime('%Y-%m'),
                    'tpAmb': '2',  # Ambiente de produção
                    'procEmi': '1',
                    'verProc': '1.0'
                },
                'ideEmpregador': {
                    'tpInsc': '1',
                    'nrInsc': admin_id  # CNPJ da empresa
                },
                'evtRemun': []
            }
        }
    }
    
    for folha in folhas:
        funcionario = folha.funcionario
        
        # Dados do trabalhador
        trabalhador = {
            'cpfTrab': funcionario.cpf,
            'nisTrab': funcionario.pis,
            'nmTrab': funcionario.nome,
            'codCateg': '101',  # Empregado
            'dtNascto': funcionario.data_nascimento.strftime('%Y-%m-%d'),
            'remunPerApur': [
                {
                    'matricula': funcionario.matricula,
                    'codCateg': '101',
                    'itensRemun': [
                        {
                            'codRubr': '1000',  # Salário base
                            'ideTabRubr': 'SALARIO_BASE',
                            'qtdRubr': '1',
                            'fatorRubr': '1',
                            'vrUnit': str(folha.salario_base),
                            'vrRubr': str(folha.salario_base)
                        }
                    ]
                }
            ]
        }
        
        # Adicionar horas extras se houver
        if folha.horas_extras > 0:
            trabalhador['remunPerApur'][0]['itensRemun'].append({
                'codRubr': '1010',  # Horas extras
                'ideTabRubr': 'HORAS_EXTRAS',
                'qtdRubr': '1',
                'fatorRubr': '1',
                'vrUnit': str(folha.horas_extras),
                'vrRubr': str(folha.horas_extras)
            })
        
        # Adicionar adicional noturno se houver
        if folha.adicional_noturno > 0:
            trabalhador['remunPerApur'][0]['itensRemun'].append({
                'codRubr': '1020',  # Adicional noturno
                'ideTabRubr': 'ADICIONAL_NOTURNO',
                'qtdRubr': '1',
                'fatorRubr': '1',
                'vrUnit': str(folha.adicional_noturno),
                'vrRubr': str(folha.adicional_noturno)
            })
        
        xml_data['eSocial']['evtRemun']['evtRemun'].append(trabalhador)
    
    # Converter para XML
    import xml.etree.ElementTree as ET
    
    def dict_to_xml(tag, d):
        elem = ET.Element(tag)
        for key, val in d.items():
            if isinstance(val, dict):
                child = dict_to_xml(key, val)
                elem.append(child)
            elif isinstance(val, list):
                for item in val:
                    if isinstance(item, dict):
                        child = dict_to_xml(key, item)
                        elem.append(child)
                    else:
                        child = ET.Element(key)
                        child.text = str(item)
                        elem.append(child)
            else:
                child = ET.Element(key)
                child.text = str(val)
                elem.append(child)
        return elem
    
    root = dict_to_xml('eSocial', xml_data['eSocial'])
    
    # Salvar arquivo
    filename = f"esocial_{admin_id}_{mes_referencia.strftime('%Y_%m')}.xml"
    filepath = os.path.join('static/esocial', filename)
    os.makedirs('static/esocial', exist_ok=True)
    
    tree = ET.ElementTree(root)
    tree.write(filepath, encoding='utf-8', xml_declaration=True)
    
    return filepath

def gerar_arquivo_sefip(admin_id, mes_referencia):
    """Gerar arquivo para SEFIP"""
    
    folhas = FolhaPagamento.query.filter_by(
        admin_id=admin_id,
        mes_referencia=mes_referencia
    ).all()
    
    # Formato SEFIP (texto fixo)
    linhas = []
    
    # Cabeçalho
    empresa = Usuario.query.get(admin_id)
    linha_cabecalho = f"00{empresa.cnpj.replace('.', '').replace('/', '').replace('-', ''):<14}{empresa.nome:<40}{mes_referencia.strftime('%m%Y')}"
    linhas.append(linha_cabecalho)
    
    # Dados dos funcionários
    for folha in folhas:
        funcionario = folha.funcionario
        
        # Linha do funcionário
        linha_funcionario = (
            f"10"  # Tipo de registro
            f"{funcionario.pis:<11}"  # PIS
            f"{funcionario.nome:<40}"  # Nome
            f"{folha.salario_base:>10.2f}".replace('.', '')  # Salário base
            f"{folha.total_proventos:>10.2f}".replace('.', '')  # Total proventos
            f"{folha.inss:>8.2f}".replace('.', '')  # INSS
            f"{folha.fgts:>8.2f}".replace('.', '')  # FGTS
        )
        linhas.append(linha_funcionario)
    
    # Rodapé
    total_funcionarios = len(folhas)
    total_salarios = sum(f.total_proventos for f in folhas)
    total_inss = sum(f.inss for f in folhas)
    total_fgts = sum(f.fgts for f in folhas)
    
    linha_rodape = (
        f"99"  # Tipo de registro
        f"{total_funcionarios:>6}"  # Total funcionários
        f"{total_salarios:>12.2f}".replace('.', '')  # Total salários
        f"{total_inss:>10.2f}".replace('.', '')  # Total INSS
        f"{total_fgts:>10.2f}".replace('.', '')  # Total FGTS
    )
    linhas.append(linha_rodape)
    
    # Salvar arquivo
    filename = f"sefip_{admin_id}_{mes_referencia.strftime('%Y_%m')}.txt"
    filepath = os.path.join('static/sefip', filename)
    os.makedirs('static/sefip', exist_ok=True)
    
    with open(filepath, 'w', encoding='latin-1') as f:
        for linha in linhas:
            f.write(linha + '\n')
    
    return filepath
```

### **11:00 - Cronograma de Implementação**

**Marina:** Qual o cronograma para este módulo?

**Carlos:** Baseado na complexidade e importância:

**Semana 1:**
- Implementar classes de banco de dados
- Sistema básico de configuração salarial
- Cálculos básicos de horas

**Semana 2:**
- Cálculos de INSS, IRRF e FGTS
- Sistema de benefícios automático
- Processamento da folha mensal

**Semana 3:**
- Dashboard e relatórios
- Holerites em PDF
- Sistema de auditoria

**Semana 4:**
- Férias e 13º automático
- Integração eSocial/SEFIP
- Testes extensivos

**Dra. Carla:** Posso ajudar com validação dos cálculos e conformidade legal durante todo o processo.

**Prof. Ricardo:** E eu garanto que todas as regras da CLT estejam implementadas corretamente.

### **11:15 - Considerações Técnicas Avançadas**

**Rafael:** Algumas preocupações técnicas importantes:

**Performance dos Cálculos:**
```python
# Cache de cálculos para otimização
class CacheFolhaPagamento:
    def __init__(self):
        self.cache_parametros = {}  # ano -> parametros
        self.cache_configuracoes = {}  # funcionario_id -> config
        self.cache_calculos = {}  # funcionario_id + mes -> calculo
    
    def get_parametros_legais(self, admin_id, ano):
        """Obter parâmetros com cache"""
        key = f"{admin_id}_{ano}"
        if key not in self.cache_parametros:
            self.cache_parametros[key] = ParametrosLegais.query.filter_by(
                admin_id=admin_id,
                ano_vigencia=ano
            ).first()
        return self.cache_parametros[key]
    
    def invalidar_cache_funcionario(self, funcionario_id):
        """Invalidar cache quando dados do funcionário mudam"""
        keys_to_remove = [k for k in self.cache_configuracoes.keys() if k.startswith(f"{funcionario_id}_")]
        for key in keys_to_remove:
            del self.cache_configuracoes[key]
```

**Validações Críticas:**
```python
def validar_dados_folha(folha):
    """Validar dados da folha antes de salvar"""
    
    erros = []
    
    # 1. Validar valores não negativos
    if folha.salario_base < 0:
        erros.append("Salário base não pode ser negativo")
    
    if folha.total_descontos > folha.total_proventos:
        erros.append("Total de descontos não pode ser maior que proventos")
    
    # 2. Validar limites legais
    parametros = ParametrosLegais.query.filter_by(
        admin_id=folha.admin_id,
        ano_vigencia=folha.mes_referencia.year
    ).first()
    
    if folha.salario_liquido < parametros.salario_minimo:
        erros.append("Salário líquido abaixo do mínimo legal")
    
    # 3. Validar cálculos
    calculado_liquido = folha.total_proventos - folha.total_descontos
    if abs(calculado_liquido - folha.salario_liquido) > 0.01:
        erros.append("Inconsistência no cálculo do salário líquido")
    
    return erros
```

**Lucia:** E vou implementar:
- **Interface responsiva** para mobile
- **Aprovação eletrônica** de folhas
- **Notificações** automáticas para RH
- **Backup** automático de dados

### **11:30 - Próximos Passos**

**Marina:** Resumindo as responsabilidades:

1. **Ana** - Classes de banco e lógica de cálculos
2. **Dra. Carla** - Validação de cálculos e conformidade CLT
3. **Prof. Ricardo** - Regras legais e auditoria
4. **Lucia** - Interface de RH e relatórios
5. **João** - Performance e integrações governamentais
6. **Carlos** - Integração com sistema existente e revisão técnica

**Próxima reunião:** Sexta-feira para review do Módulo 6 completo.

---

## 📝 DECISÕES TÉCNICAS FINAIS

### **Arquitetura:**
- **8 novas classes:** ConfiguracaoSalarial, BeneficioFuncionario, CalculoHorasMensal, FolhaPagamento, LancamentoRecorrente, Adiantamento, FeriasDecimo, ParametrosLegais
- **Integração total** com sistema de ponto existente (Módulo 5)
- **Cálculos automáticos** de INSS, IRRF, FGTS
- **Conformidade CLT** completa

### **Funcionalidades:**
- **Processamento automático** da folha mensal
- **Cálculos precisos** de horas extras, adicional noturno, DSR
- **Benefícios automáticos** (VR, VT, plano de saúde)
- **Férias e 13º** calculados automaticamente
- **Holerites em PDF** gerados automaticamente
- **Dashboard** completo para RH

### **Integrações:**
- **Módulo 5:** Pontos automáticos alimentam folha
- **eSocial:** Exportação automática
- **SEFIP:** Geração de arquivos
- **Sistema existente:** Zero modificação nas classes atuais

### **Segurança:**
- **Auditoria** completa de todos os cálculos
- **Validações** automáticas de conformidade
- **Logs** de todas as alterações
- **Backup** automático de dados

**Status:** Módulo 6 especificado e pronto para implementação! 🚀

