# Solu√ß√£o Completa: Erros de `admin_id` em Produ√ß√£o

## Resumo Executivo

O sistema **EnterpriseSync (SIGE)** est√° com **3 tabelas cr√≠ticas sem a coluna `admin_id`** no banco de dados de produ√ß√£o, causando m√∫ltiplos erros em cascata que impedem o funcionamento normal da aplica√ß√£o.

---

## Tabelas Afetadas

| Tabela | Modelo tem `admin_id` | DB tem `admin_id` | Status | Severidade |
|--------|----------------------|-------------------|--------|------------|
| `rdo` | ‚úÖ | ‚úÖ | ‚úÖ OK | - |
| `rdo_servico_subatividade` | ‚úÖ | ‚úÖ | ‚úÖ OK | - |
| **`funcao`** | ‚úÖ | ‚ùå | ‚ùå **ERRO** | üî¥ **CR√çTICO** |
| **`rdo_mao_obra`** | ‚úÖ | ‚ùå | ‚ùå **ERRO** | üî¥ **CR√çTICO** |
| **`registro_alimentacao`** | ‚úÖ | ‚ùå | ‚ùå **ERRO** | üî¥ **CR√çTICO** |

---

## Erros em Produ√ß√£o

### 1. P√°gina de Funcion√°rios Quebrada

**Erro:**
```
psycopg2.errors.UndefinedColumn: column funcao.admin_id does not exist
```

**Origem:**
- Arquivo: `/app/views.py`, linha 1680
- Template: `/app/templates/funcionarios.html`, linha 479
- C√≥digo: `{{ kpi.funcionario.funcao_ref.nome.lower() if kpi.funcionario.funcao_ref else '' }}`

**Causa:**
- Lazy loading do relacionamento `funcao_ref`
- SQLAlchemy tenta carregar a tabela `funcao` com `admin_id`
- Coluna n√£o existe no banco de dados

**Impacto:**
- ‚ùå P√°gina de funcion√°rios completamente quebrada
- ‚ùå Imposs√≠vel visualizar KPIs de funcion√°rios
- ‚ùå Imposs√≠vel visualizar fun√ß√µes dos funcion√°rios

---

### 2. C√°lculo de M√©tricas do RDO Quebrado

**Erro:**
```
ERRO c√°lculo RDO 104: (psycopg2.errors.UndefinedColumn) column rdo_mao_obra.admin_id does not exist
```

**Origem:**
- Arquivo: `/app/crud_rdo_completo.py`, linha 66
- C√≥digo: `RDOMaoObra.query.filter_by(rdo_id=rdo.id).count()`

**Causa:**
- Query tenta contar registros de m√£o de obra
- SQLAlchemy inclui `admin_id` no SELECT
- Coluna n√£o existe no banco de dados

**Impacto:**
- ‚ùå Imposs√≠vel calcular m√©tricas de m√£o de obra
- ‚ùå Dashboards de RDO n√£o funcionam
- ‚ùå Relat√≥rios de progresso quebrados

---

### 3. Detalhes da Obra Quebrados

**Erro:**
```
psycopg2.errors.UndefinedColumn: column registro_alimentacao.admin_id does not exist
```

**Origem:**
- Arquivo: `/app/views.py`, linha 3051
- View: `detalhes_obra`

**Causa:**
- Query busca registros de alimenta√ß√£o por obra e per√≠odo
- SQLAlchemy inclui `admin_id` no SELECT
- Coluna n√£o existe no banco de dados

**Impacto:**
- ‚ùå P√°gina de detalhes da obra quebrada
- ‚ùå Imposs√≠vel visualizar registros de alimenta√ß√£o
- ‚ùå Relat√≥rios de custos com alimenta√ß√£o n√£o funcionam

---

### 4. Transa√ß√£o SQL Abortada (Efeito Cascata)

**Erro:**
```
psycopg2.errors.InFailedSqlTransaction: current transaction is aborted, 
commands ignored until end of transaction block
```

**Causa:**
- Uma query falha (ex: `rdo_mao_obra.admin_id` n√£o existe)
- PostgreSQL aborta a transa√ß√£o automaticamente
- Queries subsequentes s√£o rejeitadas at√© ROLLBACK

**Impacto:**
- ‚ùå Efeito cascata: queries em tabelas corretas tamb√©m falham
- ‚ùå Mensagens de erro confusas (erro aparece em tabela diferente da causa)
- ‚ùå Sistema inst√°vel e imprevis√≠vel

---

## Causa Raiz

### Migration 48 N√£o Foi Executada

A **Migration 48** foi criada para adicionar `admin_id` em m√∫ltiplas tabelas (arquivo `migrations.py`, linhas 3980-4380), mas **n√£o foi executada no banco de produ√ß√£o**.

**Evid√™ncias:**

1. ‚úÖ Migration 48 existe no c√≥digo
2. ‚úÖ Inclui as 3 tabelas problem√°ticas
3. ‚úÖ Tem estrat√©gias de backfill inteligentes
4. ‚ùå N√£o foi registrada na tabela `migration_history`
5. ‚ùå Colunas n√£o existem no banco de dados

**Estrat√©gias de backfill da Migration 48:**

```python
# funcao (linha 4016-4023)
'funcao': ("""
    UPDATE funcao fu
    SET admin_id = f.admin_id
    FROM funcionario f
    WHERE f.funcao_id = fu.id
      AND fu.admin_id IS NULL
      AND f.admin_id IS NOT NULL
""", "via funcionario.funcao_id"),

# registro_alimentacao (linha 4144-4151)
'registro_alimentacao': ("""
    UPDATE registro_alimentacao ra
    SET admin_id = f.admin_id
    FROM funcionario f
    WHERE ra.funcionario_id = f.id
      AND ra.admin_id IS NULL
      AND f.admin_id IS NOT NULL
""", "via funcionario_id"),

# rdo_mao_obra (linha 4153-4161)
'rdo_mao_obra': ("""
    UPDATE rdo_mao_obra rm
    SET admin_id = o.admin_id
    FROM rdo r
    JOIN obra o ON r.obra_id = o.id
    WHERE rm.rdo_id = r.id
      AND rm.admin_id IS NULL
      AND o.admin_id IS NOT NULL
""", "via rdo ‚Üí obra"),
```

---

## Solu√ß√£o Completa

### Passo 1: Verificar Estado Atual

Execute este script para confirmar quais tabelas t√™m problema:

```python
# check_admin_id_status.py
from app import app, db

with app.app_context():
    connection = db.engine.raw_connection()
    cursor = connection.cursor()
    
    tabelas = ['funcao', 'rdo_mao_obra', 'registro_alimentacao']
    
    print("=" * 80)
    print("üîç VERIFICA√á√ÉO DE COLUNA admin_id")
    print("=" * 80)
    
    for tabela in tabelas:
        cursor.execute("""
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = %s AND column_name = 'admin_id'
        """, (tabela,))
        
        if cursor.fetchone():
            print(f"‚úÖ {tabela}: admin_id EXISTE")
        else:
            print(f"‚ùå {tabela}: admin_id N√ÉO EXISTE")
    
    print("=" * 80)
    
    cursor.close()
    connection.close()
```

---

### Passo 2: Aplicar Corre√ß√£o SQL (RECOMENDADO)

Use este script SQL idempotente que pode ser executado m√∫ltiplas vezes:

```sql
-- fix_admin_id_production.sql

BEGIN;

-- ============================================================================
-- 1. TABELA: funcao
-- ============================================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'funcao' AND column_name = 'admin_id'
    ) THEN
        RAISE NOTICE 'üîÑ Adicionando admin_id na tabela funcao...';
        
        -- Adicionar coluna
        ALTER TABLE funcao ADD COLUMN admin_id INTEGER;
        
        -- Backfill baseado em funcionario.funcao_id
        UPDATE funcao fu
        SET admin_id = f.admin_id
        FROM funcionario f
        WHERE f.funcao_id = fu.id
          AND fu.admin_id IS NULL
          AND f.admin_id IS NOT NULL;
        
        -- Verificar registros √≥rf√£os
        DECLARE
            orfaos INTEGER;
        BEGIN
            SELECT COUNT(*) INTO orfaos FROM funcao WHERE admin_id IS NULL;
            
            IF orfaos > 0 THEN
                RAISE NOTICE '‚ö†Ô∏è  % registros √≥rf√£os em funcao - usando admin_id padr√£o', orfaos;
                -- Usar admin_id padr√£o (2) para registros √≥rf√£os
                UPDATE funcao SET admin_id = 2 WHERE admin_id IS NULL;
            END IF;
        END;
        
        -- Aplicar NOT NULL
        ALTER TABLE funcao ALTER COLUMN admin_id SET NOT NULL;
        
        -- Adicionar foreign key
        ALTER TABLE funcao
        ADD CONSTRAINT fk_funcao_admin_id
        FOREIGN KEY (admin_id) REFERENCES usuario(id) ON DELETE CASCADE;
        
        -- Criar √≠ndice
        CREATE INDEX idx_funcao_admin_id ON funcao(admin_id);
        
        RAISE NOTICE '‚úÖ funcao.admin_id criada com sucesso';
    ELSE
        RAISE NOTICE '‚è≠Ô∏è  funcao.admin_id j√° existe';
    END IF;
END $$;

-- ============================================================================
-- 2. TABELA: registro_alimentacao
-- ============================================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'registro_alimentacao' AND column_name = 'admin_id'
    ) THEN
        RAISE NOTICE 'üîÑ Adicionando admin_id na tabela registro_alimentacao...';
        
        -- Adicionar coluna
        ALTER TABLE registro_alimentacao ADD COLUMN admin_id INTEGER;
        
        -- Backfill baseado em funcionario_id
        UPDATE registro_alimentacao ra
        SET admin_id = f.admin_id
        FROM funcionario f
        WHERE ra.funcionario_id = f.id
          AND ra.admin_id IS NULL
          AND f.admin_id IS NOT NULL;
        
        -- Verificar registros √≥rf√£os
        DECLARE
            orfaos INTEGER;
        BEGIN
            SELECT COUNT(*) INTO orfaos FROM registro_alimentacao WHERE admin_id IS NULL;
            
            IF orfaos > 0 THEN
                RAISE NOTICE '‚ö†Ô∏è  % registros √≥rf√£os em registro_alimentacao - usando admin_id padr√£o', orfaos;
                UPDATE registro_alimentacao SET admin_id = 2 WHERE admin_id IS NULL;
            END IF;
        END;
        
        -- Aplicar NOT NULL
        ALTER TABLE registro_alimentacao ALTER COLUMN admin_id SET NOT NULL;
        
        -- Adicionar foreign key
        ALTER TABLE registro_alimentacao
        ADD CONSTRAINT fk_registro_alimentacao_admin_id
        FOREIGN KEY (admin_id) REFERENCES usuario(id) ON DELETE CASCADE;
        
        -- Criar √≠ndice
        CREATE INDEX idx_registro_alimentacao_admin_id ON registro_alimentacao(admin_id);
        
        RAISE NOTICE '‚úÖ registro_alimentacao.admin_id criada com sucesso';
    ELSE
        RAISE NOTICE '‚è≠Ô∏è  registro_alimentacao.admin_id j√° existe';
    END IF;
END $$;

-- ============================================================================
-- 3. TABELA: rdo_mao_obra
-- ============================================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'rdo_mao_obra' AND column_name = 'admin_id'
    ) THEN
        RAISE NOTICE 'üîÑ Adicionando admin_id na tabela rdo_mao_obra...';
        
        -- Adicionar coluna
        ALTER TABLE rdo_mao_obra ADD COLUMN admin_id INTEGER;
        
        -- Backfill baseado em rdo ‚Üí obra
        UPDATE rdo_mao_obra rm
        SET admin_id = o.admin_id
        FROM rdo r
        JOIN obra o ON r.obra_id = o.id
        WHERE rm.rdo_id = r.id
          AND rm.admin_id IS NULL
          AND o.admin_id IS NOT NULL;
        
        -- Verificar registros √≥rf√£os
        DECLARE
            orfaos INTEGER;
        BEGIN
            SELECT COUNT(*) INTO orfaos FROM rdo_mao_obra WHERE admin_id IS NULL;
            
            IF orfaos > 0 THEN
                RAISE NOTICE '‚ö†Ô∏è  % registros √≥rf√£os em rdo_mao_obra - usando admin_id padr√£o', orfaos;
                UPDATE rdo_mao_obra SET admin_id = 2 WHERE admin_id IS NULL;
            END IF;
        END;
        
        -- Aplicar NOT NULL
        ALTER TABLE rdo_mao_obra ALTER COLUMN admin_id SET NOT NULL;
        
        -- Adicionar foreign key
        ALTER TABLE rdo_mao_obra
        ADD CONSTRAINT fk_rdo_mao_obra_admin_id
        FOREIGN KEY (admin_id) REFERENCES usuario(id) ON DELETE CASCADE;
        
        -- Criar √≠ndice
        CREATE INDEX idx_rdo_mao_obra_admin_id ON rdo_mao_obra(admin_id);
        
        RAISE NOTICE '‚úÖ rdo_mao_obra.admin_id criada com sucesso';
    ELSE
        RAISE NOTICE '‚è≠Ô∏è  rdo_mao_obra.admin_id j√° existe';
    END IF;
END $$;

-- ============================================================================
-- 4. REGISTRAR NO HIST√ìRICO DE MIGRATIONS
-- ============================================================================

INSERT INTO migration_history 
    (migration_number, migration_name, executed_at, status)
VALUES 
    (48, 'Adicionar admin_id em funcao, registro_alimentacao, rdo_mao_obra', NOW(), 'success')
ON CONFLICT (migration_number) DO UPDATE 
SET executed_at = NOW(), status = 'success';

COMMIT;

-- ============================================================================
-- 5. VALIDA√á√ÉO
-- ============================================================================

SELECT 
    'funcao' as tabela,
    COUNT(*) as total_registros,
    COUNT(admin_id) as com_admin_id,
    COUNT(*) - COUNT(admin_id) as sem_admin_id
FROM funcao

UNION ALL

SELECT 
    'registro_alimentacao' as tabela,
    COUNT(*) as total_registros,
    COUNT(admin_id) as com_admin_id,
    COUNT(*) - COUNT(admin_id) as sem_admin_id
FROM registro_alimentacao

UNION ALL

SELECT 
    'rdo_mao_obra' as tabela,
    COUNT(*) as total_registros,
    COUNT(admin_id) as com_admin_id,
    COUNT(*) - COUNT(admin_id) as sem_admin_id
FROM rdo_mao_obra;
```

**Executar:**
```bash
psql -U usuario -d nome_banco -f fix_admin_id_production.sql
```

---

### Passo 3: Validar Resultado

Execute este script para confirmar que tudo foi corrigido:

```python
# validate_fix.py
from app import app, db

with app.app_context():
    connection = db.engine.raw_connection()
    cursor = connection.cursor()
    
    tabelas = ['funcao', 'rdo_mao_obra', 'registro_alimentacao']
    
    print("=" * 80)
    print("üîç VALIDA√á√ÉO P√ìS-CORRE√á√ÉO")
    print("=" * 80)
    
    all_ok = True
    
    for tabela in tabelas:
        print(f"\nüìã Tabela: {tabela}")
        
        # 1. Verificar coluna
        cursor.execute("""
            SELECT column_name, data_type, is_nullable 
            FROM information_schema.columns 
            WHERE table_name = %s AND column_name = 'admin_id'
        """, (tabela,))
        
        col = cursor.fetchone()
        if col:
            print(f"  ‚úÖ Coluna admin_id existe ({col[1]}, nullable={col[2]})")
        else:
            print(f"  ‚ùå Coluna admin_id N√ÉO existe")
            all_ok = False
            continue
        
        # 2. Verificar foreign key
        cursor.execute("""
            SELECT constraint_name 
            FROM information_schema.table_constraints 
            WHERE table_name = %s 
              AND constraint_type = 'FOREIGN KEY'
              AND constraint_name LIKE '%%admin_id%%'
        """, (tabela,))
        
        fk = cursor.fetchone()
        if fk:
            print(f"  ‚úÖ Foreign key: {fk[0]}")
        else:
            print(f"  ‚ö†Ô∏è  Foreign key n√£o encontrada")
        
        # 3. Verificar √≠ndice
        cursor.execute("""
            SELECT indexname 
            FROM pg_indexes 
            WHERE tablename = %s 
              AND indexname LIKE '%%admin_id%%'
        """, (tabela,))
        
        idx = cursor.fetchone()
        if idx:
            print(f"  ‚úÖ √çndice: {idx[0]}")
        else:
            print(f"  ‚ö†Ô∏è  √çndice n√£o encontrado")
        
        # 4. Verificar dados
        cursor.execute(f"""
            SELECT 
                COUNT(*) as total,
                COUNT(admin_id) as com_admin_id,
                COUNT(*) - COUNT(admin_id) as sem_admin_id
            FROM {tabela}
        """)
        
        stats = cursor.fetchone()
        print(f"  üìä Dados:")
        print(f"     Total: {stats[0]}")
        print(f"     Com admin_id: {stats[1]}")
        print(f"     Sem admin_id: {stats[2]}")
        
        if stats[2] > 0:
            print(f"  ‚ùå {stats[2]} registros sem admin_id!")
            all_ok = False
    
    print("\n" + "=" * 80)
    if all_ok:
        print("‚úÖ TODAS AS TABELAS CORRIGIDAS COM SUCESSO!")
    else:
        print("‚ùå AINDA H√Å PROBLEMAS - REVISAR ACIMA")
    print("=" * 80)
    
    cursor.close()
    connection.close()
```

---

### Passo 4: Adicionar Tratamento de Erros (Preventivo)

Para evitar efeito cascata de transa√ß√µes abortadas, adicione tratamento de erro:

```python
# crud_rdo_completo.py - CORRE√á√ÉO

# Adicionar no in√≠cio do arquivo
from functools import wraps
import logging

logger = logging.getLogger(__name__)

def safe_db_operation(default_value=None):
    """Decorator para opera√ß√µes de banco com rollback autom√°tico"""
    def decorator(f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            try:
                return f(*args, **kwargs)
            except Exception as e:
                db.session.rollback()
                logger.error(f"Erro em {f.__name__}: {e}", exc_info=True)
                if default_value is not None:
                    return default_value
                raise
        return wrapped
    return decorator

# Aplicar no loop de processamento (linha 63)
rdos_processados = []
for rdo, obra in rdos_paginated.items:
    try:
        # Contadores
        total_subatividades = RDOServicoSubatividade.query.filter_by(rdo_id=rdo.id).count()
        total_funcionarios = RDOMaoObra.query.filter_by(rdo_id=rdo.id).count()
        
        # F√ìRMULA SIMPLES PROGRESSO
        subatividades = RDOServicoSubatividade.query.filter_by(rdo_id=rdo.id).all()
        if subatividades:
            soma_perc = sum(s.percentual_conclusao for s in subatividades)
            total_sub = len(subatividades)
            progresso_medio = round(soma_perc / total_sub, 1)
        else:
            progresso_medio = 0.0
    
    except Exception as e:
        # ROLLBACK para evitar InFailedSqlTransaction
        db.session.rollback()
        logger.error(f"Erro ao processar RDO {rdo.id}: {e}", exc_info=True)
        
        # Valores padr√£o
        total_subatividades = 0
        total_funcionarios = 0
        progresso_medio = 0.0
    
    # ... resto do c√≥digo ...
```

---

## Checklist de Deploy

### Pr√©-Deploy
- [ ] Criar backup completo do banco de dados
- [ ] Executar `check_admin_id_status.py` em produ√ß√£o
- [ ] Testar script SQL em ambiente de staging
- [ ] Comunicar janela de manuten√ß√£o aos usu√°rios

### Deploy
- [ ] Colocar aplica√ß√£o em modo manuten√ß√£o
- [ ] Executar `fix_admin_id_production.sql`
- [ ] Executar `validate_fix.py`
- [ ] Verificar logs de erro
- [ ] Testar funcionalidades cr√≠ticas:
  - [ ] P√°gina de funcion√°rios
  - [ ] Visualizar RDO
  - [ ] Calcular m√©tricas de m√£o de obra
  - [ ] Detalhes da obra
  - [ ] Registros de alimenta√ß√£o

### P√≥s-Deploy
- [ ] Remover modo manuten√ß√£o
- [ ] Monitorar logs por 1 hora
- [ ] Verificar m√©tricas de erro
- [ ] Confirmar com usu√°rios que sistema est√° funcionando

### Em Caso de Problema
- [ ] Colocar aplica√ß√£o em modo manuten√ß√£o
- [ ] Restaurar backup
- [ ] Investigar causa raiz
- [ ] Comunicar usu√°rios

---

## Conclus√£o

O sistema est√° com **3 tabelas cr√≠ticas sem `admin_id`** devido √† **n√£o execu√ß√£o da Migration 48**. A solu√ß√£o √©:

1. ‚úÖ **Executar script SQL** para adicionar colunas
2. ‚úÖ **Validar resultado** com script de verifica√ß√£o
3. ‚úÖ **Adicionar tratamento de erro** para prevenir efeito cascata
4. ‚úÖ **Monitorar** logs ap√≥s deploy

Com essas corre√ß√µes, todas as funcionalidades voltar√£o a funcionar normalmente.
