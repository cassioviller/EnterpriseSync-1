# ğŸ§¹ PROMPT PARA LIMPEZA SEGURA E VERIFICAÃ‡ÃƒO DE INTEGRIDADE DO SIGE

## ğŸ¯ OBJETIVO

Realizar uma limpeza meticulosa e segura do sistema SIGE, removendo arquivos Ã³rfÃ£os, corrigindo relacionamentos quebrados e validando a integridade entre mÃ³dulos, preparando o sistema para implementaÃ§Ã£o do mÃ³dulo financeiro.

---

## ğŸ“Š ANÃLISE ATUAL DO SISTEMA

### **SITUAÃ‡ÃƒO IDENTIFICADA:**
- âœ… **153 arquivos Python** no diretÃ³rio raiz
- âš ï¸ **95 arquivos Ã³rfÃ£os** (62% do total) nÃ£o sÃ£o importados
- âš ï¸ **152 templates HTML** (alguns podem estar Ã³rfÃ£os)
- âŒ **MÃºltiplas ForeignKeys Ã³rfÃ£s** apontando para tabelas inexistentes
- âŒ **Relacionamentos quebrados** entre mÃ³dulos

### **PROBLEMAS CRÃTICOS ENCONTRADOS:**
1. **Tabela `usuario` referenciada mas nÃ£o existe** - deveria ser `Usuario`
2. **Tabelas do mÃ³dulo financeiro** (`plano_contas`, `lancamento_contabil`) referenciadas mas nÃ£o implementadas
3. **Tabelas de propostas** (`propostas_comerciais`, `proposta_templates`) com referÃªncias inconsistentes
4. **MÃ³dulos Ã³rfÃ£os** com cÃ³digo duplicado e funcionalidades sobrepostas

---

## ğŸ”§ PLANO DE LIMPEZA SEGURA

### **FASE 1: BACKUP E PREPARAÃ‡ÃƒO (CRÃTICO)**

```python
def criar_backup_completo():
    """
    OBRIGATÃ“RIO: Criar backup completo antes de qualquer limpeza
    """
    import os
    import datetime
    from shutil import copytree, ignore_patterns
    
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_dir = f'backup_pre_limpeza_{timestamp}'
    
    # Backup do cÃ³digo
    copytree('.', backup_dir, 
             ignore=ignore_patterns('__pycache__', '*.pyc', '.git', 'node_modules'))
    
    # Backup do banco de dados
    os.system(f'pg_dump $DATABASE_URL > {backup_dir}/database_backup.sql')
    
    print(f"âœ… Backup criado em: {backup_dir}")
    return backup_dir
```

### **FASE 2: ANÃLISE DE DEPENDÃŠNCIAS**

```python
def analisar_dependencias_seguras():
    """
    Identificar quais arquivos podem ser removidos com seguranÃ§a
    """
    
    # ARQUIVOS SEGUROS PARA REMOÃ‡ÃƒO (Scripts de migraÃ§Ã£o antigos)
    arquivos_seguros_remocao = [
        'adicionar_tipos_folga_ferias.py',
        'atualizar_admin_ids.py',
        'atualizar_badges_tabela.py',
        'correcao_horas_extras_final.py',
        'correcao_obras_completa.py',
        'create_foto_base64_column.py',
        'deploy_final_checklist.py',
        'deploy_fix_subatividades_v10.py',
        'deploy_rdo_completo_v10.py',
        'deploy_veiculos_v2_production.py',
        'excluir_registros_agosto.py',
        'fix_detalhes_uso_production.py',
        'fix_producao_urgente.py',
        'gerar_lancamentos_julho.py',
        'migrate_v8_0.py',
        'migration_rdo_melhorias.py',
        'populacao_nova_simples.py',
        'script_migracao_producao.py',
        'substituir_lancamentos_vale_verde.py',
        'validar_correcao_custo.py',
        'validar_correcao_final.py',
        # ... outros scripts de migraÃ§Ã£o pontuais
    ]
    
    # ARQUIVOS DE TESTE (Podem ser movidos para pasta tests/)
    arquivos_teste = [
        'test_accessibility.py',
        'test_healthcheck_endpoint.py',
        'test_performance.py',
        'test_rdo_comprehensive.py',
        'tests_modulos_consolidados.py',
    ]
    
    # ARQUIVOS DUPLICADOS (Funcionalidade jÃ¡ implementada em outros)
    arquivos_duplicados = [
        'alimentacao_crud.py',  # Funcionalidade em alimentacao_views.py
        'api_servicos_corrigida.py',  # Funcionalidade em api_servicos_obra_limpa.py
        'dashboard_hotfix.py',  # Funcionalidade em views.py
        'login_simples.py',  # Funcionalidade em auth.py
        'mobile_api.py',  # NÃ£o estÃ¡ sendo usado
    ]
    
    return {
        'seguros_remocao': arquivos_seguros_remocao,
        'arquivos_teste': arquivos_teste,
        'duplicados': arquivos_duplicados
    }
```

### **FASE 3: CORREÃ‡ÃƒO DE RELACIONAMENTOS**

```python
def corrigir_relacionamentos_models():
    """
    Corrigir ForeignKeys Ã³rfÃ£s e relacionamentos quebrados
    """
    
    # CORREÃ‡Ã•ES NECESSÃRIAS NO MODELS.PY:
    
    # 1. Corrigir referÃªncias para 'usuario' -> 'Usuario'
    correcoes_fk = {
        "db.ForeignKey('usuario.id')": "db.ForeignKey('usuario.id')",  # Manter como estÃ¡ (tabela real)
        # Verificar se a tabela realmente se chama 'usuario' ou 'Usuario'
    }
    
    # 2. Remover/comentar modelos nÃ£o implementados
    modelos_nao_implementados = [
        'PlanoContas',  # SerÃ¡ implementado no mÃ³dulo financeiro
        'LancamentoContabil',  # SerÃ¡ implementado no mÃ³dulo financeiro
        'CentroCustoContabil',  # SerÃ¡ implementado no mÃ³dulo financeiro
        'NotaFiscal',  # NÃ£o estÃ¡ sendo usado
        'CategoriaServico',  # Verificar se estÃ¡ sendo usado
    ]
    
    # 3. Validar relacionamentos existentes
    relacionamentos_validar = [
        'Funcionario -> Departamento',
        'Funcionario -> Funcao',
        'Obra -> Funcionario (responsavel)',
        'RegistroPonto -> Funcionario',
        'RegistroPonto -> Obra',
        'ServicoObra -> Obra',
        'ServicoObra -> Servico',
    ]
    
    return {
        'correcoes_fk': correcoes_fk,
        'modelos_nao_implementados': modelos_nao_implementados,
        'relacionamentos_validar': relacionamentos_validar
    }
```

### **FASE 4: LIMPEZA DE TEMPLATES Ã“RFÃƒOS**

```python
def identificar_templates_orfaos():
    """
    Identificar templates HTML nÃ£o referenciados
    """
    import os
    import re
    
    # Buscar por render_template em todos os arquivos Python
    templates_referenciados = set()
    
    for root, dirs, files in os.walk('.'):
        for file in files:
            if file.endswith('.py'):
                filepath = os.path.join(root, file)
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        content = f.read()
                        # Buscar padrÃµes render_template('template.html')
                        matches = re.findall(r"render_template\(['\"]([^'\"]+)['\"]", content)
                        templates_referenciados.update(matches)
                except:
                    continue
    
    # Listar todos os templates existentes
    templates_existentes = set()
    for root, dirs, files in os.walk('templates'):
        for file in files:
            if file.endswith('.html'):
                # Caminho relativo a partir de templates/
                rel_path = os.path.relpath(os.path.join(root, file), 'templates')
                templates_existentes.add(rel_path)
    
    # Templates Ã³rfÃ£os
    templates_orfaos = templates_existentes - templates_referenciados
    
    return {
        'referenciados': templates_referenciados,
        'existentes': templates_existentes,
        'orfaos': templates_orfaos
    }
```

---

## ğŸ” VERIFICAÃ‡ÃƒO DE INTEGRIDADE ENTRE MÃ“DULOS

### **TESTE 1: Integridade de Dados**

```python
def testar_integridade_dados():
    """
    Verificar se os relacionamentos entre mÃ³dulos estÃ£o funcionando
    """
    from app import app, db
    from models import *
    
    with app.app_context():
        testes = []
        
        # Teste 1: FuncionÃ¡rio -> Departamento
        try:
            funcionario = Funcionario.query.first()
            if funcionario and funcionario.departamento_id:
                departamento = funcionario.departamento_ref
                testes.append({
                    'teste': 'Funcionario -> Departamento',
                    'status': 'OK' if departamento else 'ERRO',
                    'detalhes': f'FuncionÃ¡rio {funcionario.nome} -> Depto {departamento.nome if departamento else "NULL"}'
                })
        except Exception as e:
            testes.append({
                'teste': 'Funcionario -> Departamento',
                'status': 'ERRO',
                'detalhes': str(e)
            })
        
        # Teste 2: Obra -> ResponsÃ¡vel
        try:
            obra = Obra.query.first()
            if obra and obra.responsavel_id:
                responsavel = Funcionario.query.get(obra.responsavel_id)
                testes.append({
                    'teste': 'Obra -> Responsavel',
                    'status': 'OK' if responsavel else 'ERRO',
                    'detalhes': f'Obra {obra.nome} -> Resp {responsavel.nome if responsavel else "NULL"}'
                })
        except Exception as e:
            testes.append({
                'teste': 'Obra -> Responsavel',
                'status': 'ERRO',
                'detalhes': str(e)
            })
        
        # Teste 3: RegistroPonto -> Funcionario/Obra
        try:
            registro = RegistroPonto.query.first()
            if registro:
                funcionario = registro.funcionario_ref
                obra = registro.obra_ref
                testes.append({
                    'teste': 'RegistroPonto -> Funcionario/Obra',
                    'status': 'OK' if (funcionario and obra) else 'ERRO',
                    'detalhes': f'Ponto {registro.data} -> {funcionario.nome if funcionario else "NULL"} / {obra.nome if obra else "NULL"}'
                })
        except Exception as e:
            testes.append({
                'teste': 'RegistroPonto -> Funcionario/Obra',
                'status': 'ERRO',
                'detalhes': str(e)
            })
        
        return testes
```

### **TESTE 2: Funcionalidades dos MÃ³dulos**

```python
def testar_funcionalidades_modulos():
    """
    Testar se as funcionalidades principais de cada mÃ³dulo estÃ£o funcionando
    """
    from app import app
    import requests
    
    # URLs para testar (assumindo que o app estÃ¡ rodando)
    base_url = 'http://localhost:5000'
    
    testes_urls = [
        # MÃ³dulo Principal
        {'url': '/', 'modulo': 'Dashboard', 'esperado': 200},
        {'url': '/funcionarios', 'modulo': 'FuncionÃ¡rios', 'esperado': 200},
        {'url': '/obras', 'modulo': 'Obras', 'esperado': 200},
        
        # MÃ³dulo RDO
        {'url': '/rdo', 'modulo': 'RDO', 'esperado': 200},
        
        # MÃ³dulo VeÃ­culos/Frota
        {'url': '/frota', 'modulo': 'Frota', 'esperado': 200},
        
        # MÃ³dulo Almoxarifado
        {'url': '/almoxarifado', 'modulo': 'Almoxarifado', 'esperado': 200},
        
        # MÃ³dulo Ponto
        {'url': '/ponto', 'modulo': 'Ponto', 'esperado': 200},
        
        # MÃ³dulo Propostas
        {'url': '/propostas', 'modulo': 'Propostas', 'esperado': 200},
        
        # APIs
        {'url': '/api/funcionarios', 'modulo': 'API FuncionÃ¡rios', 'esperado': 200},
    ]
    
    resultados = []
    
    with app.test_client() as client:
        for teste in testes_urls:
            try:
                response = client.get(teste['url'])
                status = 'OK' if response.status_code == teste['esperado'] else 'ERRO'
                resultados.append({
                    'modulo': teste['modulo'],
                    'url': teste['url'],
                    'status_code': response.status_code,
                    'esperado': teste['esperado'],
                    'status': status
                })
            except Exception as e:
                resultados.append({
                    'modulo': teste['modulo'],
                    'url': teste['url'],
                    'status_code': 'ERRO',
                    'esperado': teste['esperado'],
                    'status': 'ERRO',
                    'erro': str(e)
                })
    
    return resultados
```

### **TESTE 3: LanÃ§amentos AutomÃ¡ticos**

```python
def testar_lancamentos_automaticos():
    """
    Testar se os lanÃ§amentos automÃ¡ticos entre mÃ³dulos estÃ£o funcionando
    """
    from app import app, db
    from models import *
    from datetime import datetime, date
    
    with app.app_context():
        testes_lancamentos = []
        
        # Teste 1: Criar registro de ponto -> Deve impactar KPIs
        try:
            funcionario = Funcionario.query.first()
            obra = Obra.query.first()
            
            if funcionario and obra:
                # Criar registro de ponto
                registro = RegistroPonto(
                    funcionario_id=funcionario.id,
                    obra_id=obra.id,
                    data=date.today(),
                    entrada=datetime.now().time(),
                    admin_id=funcionario.admin_id
                )
                db.session.add(registro)
                db.session.commit()
                
                # Verificar se foi criado
                registro_criado = RegistroPonto.query.filter_by(
                    funcionario_id=funcionario.id,
                    data=date.today()
                ).first()
                
                testes_lancamentos.append({
                    'teste': 'Criar Registro Ponto',
                    'status': 'OK' if registro_criado else 'ERRO',
                    'detalhes': f'Registro ID: {registro_criado.id if registro_criado else "NULL"}'
                })
                
                # Limpar teste
                if registro_criado:
                    db.session.delete(registro_criado)
                    db.session.commit()
                    
        except Exception as e:
            testes_lancamentos.append({
                'teste': 'Criar Registro Ponto',
                'status': 'ERRO',
                'detalhes': str(e)
            })
        
        # Teste 2: Criar entrada no almoxarifado -> Deve impactar estoque
        try:
            # Verificar se mÃ³dulo almoxarifado estÃ¡ implementado
            if hasattr(sys.modules.get('models'), 'AlmoxarifadoItem'):
                item = AlmoxarifadoItem.query.first()
                if item:
                    estoque_antes = AlmoxarifadoEstoque.query.filter_by(item_id=item.id).first()
                    quantidade_antes = estoque_antes.quantidade if estoque_antes else 0
                    
                    # Simular entrada (isso deveria ser feito via service)
                    # ... cÃ³digo de teste de entrada ...
                    
                    testes_lancamentos.append({
                        'teste': 'Entrada Almoxarifado',
                        'status': 'IMPLEMENTAR',
                        'detalhes': 'MÃ³dulo almoxarifado detectado'
                    })
                else:
                    testes_lancamentos.append({
                        'teste': 'Entrada Almoxarifado',
                        'status': 'SEM_DADOS',
                        'detalhes': 'Nenhum item no almoxarifado'
                    })
            else:
                testes_lancamentos.append({
                    'teste': 'Entrada Almoxarifado',
                    'status': 'NAO_IMPLEMENTADO',
                    'detalhes': 'MÃ³dulo almoxarifado nÃ£o encontrado'
                })
                
        except Exception as e:
            testes_lancamentos.append({
                'teste': 'Entrada Almoxarifado',
                'status': 'ERRO',
                'detalhes': str(e)
            })
        
        return testes_lancamentos
```

---

## ğŸ“‹ CHECKLIST DE EXECUÃ‡ÃƒO

### **PRÃ‰-EXECUÃ‡ÃƒO (OBRIGATÃ“RIO)**
- [ ] âœ… Criar backup completo do sistema e banco de dados
- [ ] âœ… Testar backup (restaurar em ambiente de teste)
- [ ] âœ… Documentar versÃ£o atual do sistema
- [ ] âœ… Notificar usuÃ¡rios sobre manutenÃ§Ã£o

### **EXECUÃ‡ÃƒO FASE 1: LIMPEZA SEGURA**
- [ ] ğŸ—‘ï¸ Mover arquivos de teste para pasta `tests/`
- [ ] ğŸ—‘ï¸ Remover scripts de migraÃ§Ã£o antigos (jÃ¡ executados)
- [ ] ğŸ—‘ï¸ Remover arquivos duplicados (manter versÃ£o mais recente)
- [ ] ğŸ—‘ï¸ Limpar pasta `attached_assets/` (arquivos temporÃ¡rios)
- [ ] ğŸ“ Criar pasta `archive/` para arquivos histÃ³ricos

### **EXECUÃ‡ÃƒO FASE 2: CORREÃ‡ÃƒO DE MODELOS**
- [ ] ğŸ”§ Corrigir ForeignKeys Ã³rfÃ£s no `models.py`
- [ ] ğŸ”§ Remover/comentar modelos nÃ£o implementados
- [ ] ğŸ”§ Validar relacionamentos existentes
- [ ] ğŸ”§ Executar migraÃ§Ã£o para corrigir banco de dados
- [ ] âœ… Testar integridade dos relacionamentos

### **EXECUÃ‡ÃƒO FASE 3: LIMPEZA DE TEMPLATES**
- [ ] ğŸ¨ Identificar templates Ã³rfÃ£os
- [ ] ğŸ¨ Mover templates nÃ£o utilizados para `templates/archive/`
- [ ] ğŸ¨ Validar templates principais
- [ ] ğŸ¨ Testar renderizaÃ§Ã£o das pÃ¡ginas principais

### **EXECUÃ‡ÃƒO FASE 4: TESTES DE INTEGRIDADE**
- [ ] ğŸ§ª Executar testes de integridade de dados
- [ ] ğŸ§ª Testar funcionalidades de cada mÃ³dulo
- [ ] ğŸ§ª Validar lanÃ§amentos automÃ¡ticos
- [ ] ğŸ§ª Testar APIs principais
- [ ] ğŸ“Š Gerar relatÃ³rio de integridade

### **PÃ“S-EXECUÃ‡ÃƒO**
- [ ] ğŸ“ Documentar mudanÃ§as realizadas
- [ ] ğŸš€ Deploy em ambiente de produÃ§Ã£o
- [ ] ğŸ‘¥ Treinar usuÃ¡rios sobre mudanÃ§as
- [ ] ğŸ“Š Monitorar sistema por 48h
- [ ] âœ… Confirmar que tudo estÃ¡ funcionando

---

## âš ï¸ CUIDADOS ESPECIAIS

### **ARQUIVOS QUE NÃƒO DEVEM SER REMOVIDOS**
- `app.py` - Arquivo principal da aplicaÃ§Ã£o
- `models.py` - Modelos de dados principais
- `views.py` - Views principais
- `auth.py` - Sistema de autenticaÃ§Ã£o
- `migrations.py` - Sistema de migraÃ§Ãµes
- Qualquer arquivo importado em `app.py`

### **VALIDAÃ‡Ã•ES OBRIGATÃ“RIAS**
1. **Antes de remover qualquer arquivo:**
   ```bash
   grep -r "nome_do_arquivo" . --exclude="nome_do_arquivo.py"
   ```

2. **Antes de alterar models.py:**
   ```python
   # Testar em ambiente de desenvolvimento primeiro
   python3 -c "from models import *; print('Modelos OK')"
   ```

3. **ApÃ³s cada mudanÃ§a:**
   ```bash
   python3 app.py  # Verificar se inicia sem erro
   ```

### **ROLLBACK PLAN**
Se algo der errado:
1. Parar aplicaÃ§Ã£o
2. Restaurar backup do cÃ³digo
3. Restaurar backup do banco de dados
4. Reiniciar aplicaÃ§Ã£o
5. Validar funcionamento

---

## ğŸ¯ RESULTADO ESPERADO

ApÃ³s a execuÃ§Ã£o completa:

### **SISTEMA LIMPO**
- âœ… **~60 arquivos removidos** (scripts antigos, duplicados, testes)
- âœ… **Estrutura organizada** com pastas `tests/` e `archive/`
- âœ… **Zero ForeignKeys Ã³rfÃ£s** no models.py
- âœ… **Templates organizados** sem Ã³rfÃ£os

### **INTEGRIDADE VALIDADA**
- âœ… **Relacionamentos funcionando** entre todos os mÃ³dulos
- âœ… **APIs respondendo** corretamente
- âœ… **LanÃ§amentos automÃ¡ticos** testados e funcionais
- âœ… **Zero erros** no log da aplicaÃ§Ã£o

### **PREPARADO PARA FINANCEIRO**
- âœ… **Base de dados limpa** e consistente
- âœ… **Estrutura de relacionamentos** validada
- âœ… **Performance otimizada** sem cÃ³digo morto
- âœ… **DocumentaÃ§Ã£o atualizada** do que foi alterado

---

## ğŸš€ IMPLEMENTAÃ‡ÃƒO

**Para executar esta limpeza, use este prompt no Replit:**

```
Atue como um especialista em refatoraÃ§Ã£o de sistemas Python/Flask. Execute uma limpeza meticulosa e segura do sistema SIGE seguindo EXATAMENTE o plano detalhado acima.

CRÃTICO: 
1. SEMPRE criar backup completo antes de qualquer alteraÃ§Ã£o
2. Testar cada mudanÃ§a antes de prosseguir
3. Documentar tudo que foi alterado
4. Validar integridade apÃ³s cada fase

Execute as 4 fases na ordem, reportando o progresso de cada etapa.

OBJETIVO: Deixar o sistema limpo, organizado e com integridade validada, preparado para implementaÃ§Ã£o do mÃ³dulo financeiro.
```

**Este processo transformarÃ¡ o SIGE em uma base sÃ³lida e confiÃ¡vel para futuras implementaÃ§Ãµes!** ğŸ§¹âœ¨
