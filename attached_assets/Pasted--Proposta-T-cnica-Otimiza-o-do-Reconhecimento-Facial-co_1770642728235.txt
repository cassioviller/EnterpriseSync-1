# Proposta Técnica: Otimização do Reconhecimento Facial com InsightFace (V2)

**Autor**: Manus AI
**Data**: 09 de Fevereiro de 2026

## 1. Resumo Executivo

O presente documento detalha uma proposta para a criação de um sistema de reconhecimento facial de alta performance, denominado **V2**, a ser implementado em paralelo ao sistema V1 existente. O sistema atual, embora funcional e preciso, apresenta um tempo de resposta inaceitavelmente alto (aproximadamente 21 segundos), o que compromete a experiência do usuário no registro de ponto eletrônico.

A análise da V1 indica que a lentidão não reside no modelo de embedding (`SFace`), que é extremamente rápido, mas na lógica de implementação que não utiliza o cache de embeddings de forma eficaz, recorrendo a um processo de comparação lento.

A solução proposta para a V2 é a adoção da biblioteca **InsightFace**, que utiliza modelos de reconhecimento facial de última geração (como o ArcFace) e o **ONNX Runtime** para aceleração de inferência. Esta abordagem promete uma redução drástica no tempo de reconhecimento, mantendo ou até superando a alta precisão do sistema atual. A V2 será desenvolvida como um sistema paralelo e independente, permitindo uma comparação direta com a V1 antes de uma decisão final sobre qual sistema adotar.

## 2. Análise do Sistema V1 (DeepFace)

O sistema V1 utiliza a biblioteca `DeepFace` com o modelo `SFace` para gerar embeddings faciais de 128 dimensões. A precisão alcançada é excelente, com uma distância de cosseno de 0.1943 (bem abaixo do limiar de 0.4), validando a qualidade do modelo escolhido.

### Diagnóstico do Problema de Performance

O gargalo de performance não está na geração do embedding em si. Testes isolados mostram que o método `model.forward()` do SFace executa em aproximadamente **0.029 segundos**, um tempo excelente. O problema real, que eleva o tempo total para 21 segundos, reside na lógica de reconhecimento `1:N` (um para muitos).

O fluxo atual, ao falhar em utilizar o cache pré-calculado (`cache_facial.pkl`), recorre a uma função de fallback (`DeepFace.find`). Esta função, por sua vez, não utiliza os embeddings em memória; ela carrega e processa novamente **cada uma das imagens** de referência do banco de dados a cada nova tentativa de reconhecimento. Esse processo de I/O de disco e reprocessamento de imagem em tempo real é a causa raiz da lentidão observada.

## 3. Proposta para o Sistema V2: InsightFace + ONNX Runtime

Para contornar o problema de implementação da V1 e oferecer uma alternativa mais robusta e performática, propomos a utilização da biblioteca `InsightFace`.

> **InsightFace** é um conjunto de ferramentas de código aberto para análise facial 2D e 3D, contendo uma variedade de modelos pré-treinados de alta precisão para detecção, reconhecimento e alinhamento facial. [1]

> **ONNX Runtime** (Open Neural Network Exchange) é um acelerador de inferência de alta performance para modelos de machine learning, que otimiza a execução do modelo no hardware subjacente (CPU ou GPU), resultando em uma latência significativamente menor. [2]

### Arquitetura Proposta para a V2

A nova arquitetura será autocontida para não interferir na V1 e consistirá em:

1.  **Carregamento do Modelo**: Utilizaremos o `insightface.app.FaceAnalysis`, que carrega um pipeline completo de detecção e reconhecimento. O modelo recomendado é o `buffalo_l`, um modelo rápido e preciso que utiliza o ArcFace.
2.  **Geração de Cache V2**: Um novo script (`gerar_cache_facial_v2.py`) será criado para gerar o arquivo `cache_facial_v2.pkl`. Este script irá iterar sobre os funcionários e suas fotos, gerar os embeddings usando o InsightFace e salvá-los em um dicionário, seguindo a mesma estrutura multi-tenant do cache V1.
3.  **Lógica de Reconhecimento V2**: Uma nova função, `identificar_rosto_v2`, receberá a imagem do ponto, gerará um único embedding para o rosto detectado e o comparará com **todos os embeddings pré-carregados do cache V2**. A comparação será feita em memória usando `numpy` para o cálculo da similaridade de cosseno, um processo extremamente rápido.

## 4. Comparativo de Performance e Precisão

A tabela abaixo compara as métricas entre a implementação atual da V1, o potencial teórico da V1 (se o cache fosse usado corretamente) e a performance estimada para a V2.

| Métrica | V1 (Implementação Atual) | V1 (Implementação Corrigida) | V2 (Proposta com InsightFace) |
| :--- | :--- | :--- | :--- |
| **Tempo de Reconhecimento** | ~21.12 segundos | **~0.1 - 0.3 segundos** | **< 0.1 segundos** |
| **Modelo de Embedding** | SFace (via DeepFace) | SFace (via DeepFace) | ArcFace (via InsightFace) |
| **Aceleração** | Nenhuma | Nenhuma | ONNX Runtime |
| **Precisão** | Alta (Distância ~0.19) | Alta (Distância ~0.19) | Muito Alta (State-of-the-art) |
| **Complexidade** | Média (com bug) | Baixa (após correção) | Média (nova dependência) |

## 5. Vantagens e Desvantagens da Abordagem V2

### Vantagens

*   **Performance Extrema**: A combinação do InsightFace com ONNX Runtime é uma das mais rápidas disponíveis em Python, eliminando completamente o gargalo de I/O.
*   **Precisão State-of-the-Art**: O modelo ArcFace é consistentemente classificado entre os melhores em benchmarks de reconhecimento facial.
*   **Implementação Robusta**: A lógica de comparação em memória com `numpy` é simples, direta e menos suscetível a bugs de implementação.
*   **Isolamento Total**: A V2 não modificará nenhuma parte do código da V1, permitindo testes A/B seguros.

### Desvantagens

*   **Nova Dependência**: O projeto passará a ter uma nova dependência principal (`insightface`, `onnxruntime`).
*   **Licenciamento**: Os modelos do InsightFace são primariamente para uso em pesquisa. Embora o uso em produção seja comum, a licença para uso comercial explícito pode ser necessária dependendo da escala do projeto. [3]

## 6. Plano de Implementação

O desenvolvimento da V2 seguirá os seguintes passos:

1.  **Instalação de Dependências**: Adicionar `insightface` e `onnxruntime` ao ambiente.
2.  **Criação do Script de Cache V2**: Desenvolver `gerar_cache_facial_v2.py`.
3.  **Desenvolvimento das Funções de Reconhecimento V2**: Criar as funções `gerar_embedding_v2` e `identificar_rosto_v2` no arquivo `app/utils/reconhecimento_facial_v2.py`.
4.  **Criação da Rota V2**: Adicionar uma nova rota `/ponto/facial-v2` em `app/views.py` que utilizará as novas funções.
5.  **Interface de Teste**: Modificar o template `ponto_facial.html` para incluir um botão ou link que permita testar o registro de ponto via V2.

## 7. Conclusão e Recomendação

A implementação do sistema V2 com **InsightFace e ONNX Runtime** é a solução técnica mais adequada para resolver o problema de performance do registro de ponto facial. A abordagem oferece um salto quântico em velocidade e mantém o sistema na vanguarda da tecnologia de reconhecimento facial.

Recomenda-se fortemente a implementação desta V2 em paralelo. Adicionalmente, sugere-se a **correção do bug da V1** como uma tarefa de baixa complexidade e alto impacto, o que permitiria uma comparação justa e pragmática entre uma V1 otimizada e a nova arquitetura V2.

---

### Referências

[1] InsightFace Project. (2024). *Open Source Deep Face Analysis Library*. Recuperado de https://www.insightface.ai/

[2] ONNX Runtime. (2024). *Model optimizations*. Recuperado de https://onnxruntime.ai/docs/performance/model-optimizations/

[3] GitHub - deepinsight/insightface. (2024). *Issue #2530: improve the speed of face recognition on CPU*. Recuperado de https://github.com/deepinsight/insightface/issues/2530
