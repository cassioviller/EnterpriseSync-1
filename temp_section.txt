            # Gerar número da proposta
            ultimo_numero = db.session.query(func.max(PropostaComercial.id)).scalar() or 0
            numero_proposta = f"PROP-{datetime.now().year}-{ultimo_numero + 1:03d}"
            
            # Criar proposta
            proposta = PropostaComercial(
                numero_proposta=numero_proposta,
                cliente_nome=request.form['cliente_nome'],
                cliente_email=request.form['cliente_email'],
                cliente_telefone=request.form.get('cliente_telefone'),
                cliente_cpf_cnpj=request.form.get('cliente_cpf_cnpj'),
                endereco_obra=request.form['endereco_obra'],
                descricao_obra=request.form['descricao_obra'],
                area_total_m2=float(request.form['area_total_m2']) if request.form.get('area_total_m2') else None,
                valor_proposta=float(request.form['valor_proposta']),
                prazo_execucao=int(request.form['prazo_execucao']) if request.form.get('prazo_execucao') else None,
                admin_id=current_user.id,
                criado_por_id=current_user.id
            )
            
            db.session.add(proposta)
            db.session.flush()  # Para obter o ID da proposta
            
            # Adicionar serviços
            servicos_data = request.form.getlist('servicos')
            for i, servico_json in enumerate(servicos_data):
                servico = json.loads(servico_json)
                servico_obj = ServicoPropostaComercial(
                    proposta_id=proposta.id,
                    descricao_servico=servico['descricao'],
                    quantidade=servico['quantidade'],
                    unidade=servico['unidade'],
                    valor_unitario=servico['valor_unitario'],
                    valor_total=servico['valor_total'],
                    observacoes=servico.get('observacoes'),
                    ordem=i + 1
                )
                db.session.add(servico_obj)
            
            db.session.commit()
            flash('Proposta criada com sucesso!', 'success')
            return redirect(url_for('main.detalhes_proposta', id=proposta.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Erro ao criar proposta: {str(e)}', 'danger')
            return redirect(url_for('main.nova_proposta'))
    
    return render_template('propostas/nova_proposta.html')

@main_bp.route('/propostas/<int:id>')
@login_required
@admin_required
def detalhes_proposta(id):
    """Exibe os detalhes de uma proposta"""
    proposta = PropostaComercial.query.filter_by(id=id, admin_id=current_user.id).first_or_404()
    return render_template('propostas/detalhes_proposta.html', proposta=proposta)

@main_bp.route('/propostas/<int:id>/enviar', methods=['POST'])
@login_required
@admin_required
def enviar_proposta(id):
    """Envia a proposta para o cliente"""
    try:
        proposta = PropostaComercial.query.filter_by(id=id, admin_id=current_user.id).first_or_404()
        
        # Gerar token de acesso único
        import secrets
        token = secrets.token_urlsafe(32)
        
        proposta.token_acesso = token
        proposta.data_envio = datetime.utcnow()
        proposta.data_expiracao = datetime.utcnow() + timedelta(days=30)
        proposta.status = 'Enviada'
        
        db.session.commit()
        
        flash(f'Proposta enviada! Link do cliente: {request.url_root}cliente/proposta/{token}', 'success')
        return redirect(url_for('main.lista_propostas'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erro ao enviar proposta: {str(e)}', 'danger')
        return redirect(url_for('main.lista_propostas'))

@main_bp.route('/cliente/proposta/<token>')
def cliente_proposta(token):
    """Portal do cliente para visualizar proposta"""
    proposta = PropostaComercial.query.filter_by(token_acesso=token).first_or_404()
    
    # Verificar se a proposta não expirou
    if proposta.data_expiracao and datetime.utcnow() > proposta.data_expiracao:
        proposta.status = 'Expirada'
        db.session.commit()
    
    return render_template('cliente/proposta_detalhes.html', proposta=proposta)

@main_bp.route('/cliente/proposta/<token>/aprovar', methods=['POST'])
def cliente_aprovar_proposta(token):
    """Cliente aprova a proposta"""
    try:
        proposta = PropostaComercial.query.filter_by(token_acesso=token).first_or_404()
        
        if proposta.status != 'Enviada':
            flash('Esta proposta não pode mais ser aprovada.', 'warning')
            return redirect(url_for('main.cliente_proposta', token=token))
        
        proposta.status = 'Aprovada'
        proposta.data_resposta = datetime.utcnow()
        proposta.observacoes_cliente = request.form.get('observacoes')
        proposta.ip_assinatura = request.remote_addr
        proposta.user_agent_assinatura = request.headers.get('User-Agent')
        
        db.session.commit()
        
        flash('Proposta aprovada com sucesso! Entraremos em contato em breve.', 'success')
        return redirect(url_for('main.cliente_proposta', token=token))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erro ao aprovar proposta: {str(e)}', 'danger')
        return redirect(url_for('main.cliente_proposta', token=token))

@main_bp.route('/cliente/proposta/<token>/rejeitar', methods=['POST'])
def cliente_rejeitar_proposta(token):
    """Cliente rejeita a proposta"""
    try:
        proposta = PropostaComercial.query.filter_by(token_acesso=token).first_or_404()
        
        if proposta.status != 'Enviada':
            flash('Esta proposta não pode mais ser rejeitada.', 'warning')
            return redirect(url_for('main.cliente_proposta', token=token))
        
        proposta.status = 'Rejeitada'
        proposta.data_resposta = datetime.utcnow()
        proposta.observacoes_cliente = request.form.get('observacoes')
        proposta.ip_assinatura = request.remote_addr
        proposta.user_agent_assinatura = request.headers.get('User-Agent')
        
        db.session.commit()
        
        flash('Resposta registrada. Obrigado pelo seu tempo.', 'info')
        return redirect(url_for('main.cliente_proposta', token=token))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Erro ao rejeitar proposta: {str(e)}', 'danger')
        return redirect(url_for('main.cliente_proposta', token=token))

# ============================================================================
# API ENDPOINTS PARA DROPDOWNS INTELIGENTES - RDO OPERACIONAL
# ============================================================================

@main_bp.route('/api/obras/autocomplete')
@login_required
def obras_autocomplete():
    """API para autocomplete de obras"""
    q = request.args.get('q', '')
    obras = Obra.query.filter(
        or_(
            Obra.nome.ilike(f'%{q}%'),
            Obra.codigo.ilike(f'%{q}%'),
            Obra.endereco.ilike(f'%{q}%')
        )
    ).filter(Obra.ativo == True).limit(10).all()
    
    return jsonify([{
        'id': obra.id,
        'nome': obra.nome,
        'codigo': obra.codigo,
        'endereco': obra.endereco,
        'area_total_m2': float(obra.area_total_m2) if obra.area_total_m2 else 0
    } for obra in obras])

# REMOVIDO: Função duplicada, usando api_servicos_autocomplete abaixo

@main_bp.route('/api/servicos/<int:servico_id>/subatividades')
@login_required
def api_subatividades_servico(servico_id):
    """API para buscar subatividades de um serviço com status real baseado em RDOs"""
    subatividades = SubAtividade.query.filter_by(servico_id=servico_id, ativo=True).order_by(SubAtividade.ordem_execucao).all()
    
    result = []
    for sub in subatividades:
        # Calcular status real baseado em RDOs
        # Buscar RDO_Subatividades relacionadas
        try:
            rdo_subatividades = db.session.query(RDO_Subatividade).filter_by(
                subatividade_id=sub.id
            ).all()
            
            # Calcular percentual médio de conclusão
            total_percentual = 0
            count_rdos = len(rdo_subatividades)
            
            if count_rdos > 0:
                for rdo_sub in rdo_subatividades:
                    total_percentual += rdo_sub.percentual_concluido or 0
                percentual_medio = total_percentual / count_rdos
            else:
                percentual_medio = 0
                
        except Exception:
            # Se não existe a tabela RDO_Subatividade, usar 0
            percentual_medio = 0
            count_rdos = 0
        
        # Determinar status baseado no percentual real
        if percentual_medio >= 100:
            status = 'Concluída'
            status_class = 'success'
        elif percentual_medio >= 50:
            status = 'Em andamento'
            status_class = 'warning' 
        elif percentual_medio > 0:
            status = 'Iniciada'
            status_class = 'info'
        else:
            status = 'Pendente'
            status_class = 'secondary'
        
        result.append({
            'id': sub.id,
            'nome': sub.nome,
            'descricao': sub.descricao,
            'ordem_execucao': sub.ordem_execucao,
            'ferramentas_necessarias': sub.ferramentas_necessarias,
            'materiais_principais': sub.materiais_principais,
            'requer_aprovacao': sub.requer_aprovacao,
            'pode_executar_paralelo': sub.pode_executar_paralelo,
            'qualificacao_minima': sub.qualificacao_minima,
            'status': status,
            'status_class': status_class,
            'percentual_concluido': round(percentual_medio, 1),
            'rdos_count': count_rdos
        })
    
    return jsonify({
        'success': True,
        'subatividades': result
    })

@main_bp.route('/api/funcionarios/autocomplete')
@login_required
def funcionarios_autocomplete():
    """API para autocomplete de funcionários"""
    q = request.args.get('q', '')
    funcionarios = Funcionario.query.filter(
        or_(
            Funcionario.nome.ilike(f'%{q}%'),
            Funcionario.codigo.ilike(f'%{q}%')
        )
    ).filter(Funcionario.ativo == True).limit(10).all()
    
    return jsonify([{
        'id': funcionario.id,
        'nome': funcionario.nome,
        'codigo': funcionario.codigo,
        'funcao': funcionario.funcao_ref.nome if funcionario.funcao_ref else 'Sem função',
        'entrada': funcionario.horario_trabalho.entrada.strftime('%H:%M') if funcionario.horario_trabalho else '07:00',
        'saida': funcionario.horario_trabalho.saida.strftime('%H:%M') if funcionario.horario_trabalho else '17:00'
    } for funcionario in funcionarios])

@main_bp.route('/api/equipamentos/autocomplete')
@login_required
def equipamentos_autocomplete():
    """API para autocomplete de equipamentos/veículos"""
    q = request.args.get('q', '')
    veiculos = Veiculo.query.filter(
        or_(
            Veiculo.nome.ilike(f'%{q}%'),
            Veiculo.placa.ilike(f'%{q}%'),
            Veiculo.tipo.ilike(f'%{q}%')
        )
    ).filter(Veiculo.ativo == True).limit(10).all()
    
    return jsonify([{
        'id': veiculo.id,
        'nome': veiculo.nome,
        'placa': veiculo.placa,
        'tipo': veiculo.tipo,
        'status': veiculo.status
    } for veiculo in veiculos])

@main_bp.route('/api/servicos/<int:servico_id>')
@login_required
def servico_detalhes(servico_id):
    """API para obter detalhes de um serviço com subatividades"""
    servico = Servico.query.get_or_404(servico_id)
    subatividades = SubAtividade.query.filter_by(
        servico_id=servico_id, 
        ativo=True
    ).order_by(SubAtividade.ordem_execucao).all()
    
    return jsonify({
        'id': servico.id,
        'nome': servico.nome,
        'unidade_medida': servico.unidade_medida,
        'unidade_simbolo': get_simbolo_unidade(servico.unidade_medida),
        'subatividades': [{
            'id': sub.id,
            'nome': sub.nome,
            'descricao': sub.descricao,
            'ordem_execucao': sub.ordem_execucao
        } for sub in subatividades]
    })

@main_bp.route('/api/rdo/salvar', methods=['POST'])
@login_required
def salvar_rdo():
    """API para salvar RDO como rascunho"""
    try:
        dados = request.get_json()
        
        # Validações básicas
        if not dados.get('data_relatorio') or not dados.get('obra_id'):
            return jsonify({'success': False, 'message': 'Data e obra são obrigatórias'})
        
        # Verificar se já existe RDO para esta data/obra
        rdo_existente = RDO.query.filter_by(
            data_relatorio=datetime.strptime(dados['data_relatorio'], '%Y-%m-%d').date(),
            obra_id=dados['obra_id'],
            funcionario_id=current_user.id
        ).first()
        
        if rdo_existente:
            # Atualizar RDO existente
            rdo = rdo_existente
        else:
            # Criar novo RDO
            rdo = RDO(
                data_relatorio=datetime.strptime(dados['data_relatorio'], '%Y-%m-%d').date(),
                obra_id=dados['obra_id'],
                funcionario_id=current_user.id
            )
        
        # Atualizar dados do RDO
        rdo.tempo_manha = dados.get('tempo_manha', '')
        rdo.tempo_tarde = dados.get('tempo_tarde', '')
        rdo.tempo_noite = dados.get('tempo_noite', '')
        rdo.observacoes_meteorologicas = dados.get('observacoes_meteorologicas', '')
        rdo.comentario_geral = dados.get('comentario_geral', '')
        rdo.status = dados.get('status', 'Rascunho')
        
        db.session.add(rdo)
        db.session.flush()
        
        # Salvar dados das seções (JSON por simplicidade)
        rdo.dados_funcionarios = json.dumps(dados.get('funcionarios', []))
        rdo.dados_atividades = json.dumps(dados.get('atividades', []))
        rdo.dados_equipamentos = json.dumps(dados.get('equipamentos', []))
        rdo.dados_ocorrencias = json.dumps(dados.get('ocorrencias', []))
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'RDO salvo com sucesso!',
            'rdo_id': rdo.id
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Erro ao salvar RDO: {str(e)}'})

@main_bp.route('/api/rdo/finalizar', methods=['POST'])
@login_required
def finalizar_rdo():
    """API para finalizar RDO"""
    try:
        dados = request.get_json()
        
        # Primeiro salvar como rascunho
        resultado_salvar = salvar_rdo()
        if not resultado_salvar.get_json()['success']:
            return resultado_salvar
        
        # Buscar RDO salvo
        rdo = RDO.query.filter_by(
            data_relatorio=datetime.strptime(dados['data_relatorio'], '%Y-%m-%d').date(),
            obra_id=dados['obra_id'],
            funcionario_id=current_user.id
        ).first()
        
        if not rdo:
            return jsonify({'success': False, 'message': 'RDO não encontrado'})
        
        # Atualizar status
        rdo.status = 'Finalizado'
        
        # Processar dados de produtividade
        processar_dados_produtividade(rdo.id)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'RDO finalizado com sucesso!',
            'rdo_id': rdo.id
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Erro ao finalizar RDO: {str(e)}'})

# Função auxiliar para processar dados de produtividade (chamada pelos RDOs)
def processar_dados_produtividade(rdo_id):
    """Processa dados do RDO e gera histórico de produtividade"""
    try:
        rdo = RDO.query.get(rdo_id)
        if not rdo:
            return
        
        # Processar dados de atividades
        if rdo.dados_atividades:
            atividades = json.loads(rdo.dados_atividades)
            
            for atividade in atividades:
                if atividade.get('servico_id') and atividade.get('quantidade'):
                    # Calcular custo baseado nos funcionários que trabalharam
                    custo_total = 0
                    if rdo.dados_funcionarios:
                        funcionarios = json.loads(rdo.dados_funcionarios)
                        for func in funcionarios:
                            if func.get('funcionario_id') and func.get('horas'):
                                funcionario = Funcionario.query.get(func['funcionario_id'])
                                if funcionario:
                                    custo_hora = float(funcionario.salario) / 220  # 220 horas/mês
                                    custo_total += custo_hora * float(func['horas'])
                    
                    # Criar registro de produtividade
                    historico = HistoricoProdutividadeServico(
                        servico_id=atividade['servico_id'],
                        obra_id=rdo.obra_id,
                        funcionario_id=rdo.funcionario_id,
                        data_execucao=rdo.data_relatorio,
                        quantidade_executada=float(atividade['quantidade']),
                        tempo_execucao_horas=float(atividade.get('tempo', 0)),
                        custo_mao_obra_real=custo_total,
                        produtividade_hora=float(atividade['quantidade']) / max(float(atividade.get('tempo', 1)), 1)
                    )
                    
                    db.session.add(historico)
        
        db.session.commit()
        
    except Exception as e:
        print(f"Erro ao processar dados de produtividade: {str(e)}")

def get_simbolo_unidade(unidade_medida):
    """Retorna o símbolo da unidade de medida"""
    simbolos = {
        'm2': 'm²',
        'm3': 'm³',
        'kg': 'kg',
        'ton': 'ton',
        'un': 'un',
        'm': 'm',
        'h': 'h'
    }
    return simbolos.get(unidade_medida, unidade_medida)

# Ponto
@main_bp.route('/ponto')
@login_required
def ponto():
    # Obter funcionários do admin para filtrar registros de ponto
    funcionarios_admin = Funcionario.query.filter_by(admin_id=current_user.id).order_by(Funcionario.nome).all()
    funcionarios_ids = [f.id for f in funcionarios_admin]
    
    if funcionarios_ids:
        registros = RegistroPonto.query.filter(
            RegistroPonto.funcionario_id.in_(funcionarios_ids)
        ).order_by(RegistroPonto.data.desc()).limit(50).all()
    else:
        registros = []
    
    return render_template('ponto.html', registros=registros)

@main_bp.route('/ponto/novo', methods=['GET', 'POST'])
@login_required
def novo_ponto_lista():
    form = RegistroPontoForm()
    # Filtrar por admin_id para multi-tenant
    form.funcionario_id.choices = [(f.id, f.nome) for f in Funcionario.query.filter_by(ativo=True, admin_id=current_user.id).order_by(Funcionario.nome).all()]
    form.obra_id.choices = [(0, 'Selecione...')] + [(o.id, o.nome) for o in Obra.query.filter_by(status='Em andamento', admin_id=current_user.id).all()]
    
    if form.validate_on_submit():
        registro = RegistroPonto(
            funcionario_id=form.funcionario_id.data,
            obra_id=form.obra_id.data if form.obra_id.data > 0 else None,
            data=form.data.data,
            hora_entrada=form.hora_entrada.data,
            hora_saida=form.hora_saida.data,
            hora_almoco_saida=form.hora_almoco_saida.data,
            hora_almoco_retorno=form.hora_almoco_retorno.data,
            observacoes=form.observacoes.data
        )
        
        # Calcular horas trabalhadas
        if registro.hora_entrada and registro.hora_saida:
            horas_trabalhadas = calcular_horas_trabalhadas(
                registro.hora_entrada, registro.hora_saida,
                registro.hora_almoco_saida, registro.hora_almoco_retorno,
                registro.data
            )
            registro.horas_trabalhadas = horas_trabalhadas['total']
            registro.horas_extras = horas_trabalhadas['extras']
        
        db.session.add(registro)
        db.session.commit()
        
        # Atualizar cálculos automáticos do registro
        from kpis_engine import atualizar_calculos_ponto
        atualizar_calculos_ponto(registro.id)
        
        flash('Registro de ponto adicionado com sucesso!', 'success')
        return redirect(url_for('main.ponto'))
    
    # Obter funcionários do admin para filtrar registros de ponto
    funcionarios_admin = Funcionario.query.filter_by(admin_id=current_user.id).order_by(Funcionario.nome).all()
    funcionarios_ids = [f.id for f in funcionarios_admin]
    
    if funcionarios_ids:
        registros = RegistroPonto.query.filter(
            RegistroPonto.funcionario_id.in_(funcionarios_ids)
        ).order_by(RegistroPonto.data.desc()).limit(50).all()
    else:
        registros = []
    
    return render_template('ponto.html', form=form, registros=registros)

# Funções duplicadas removidas

# Função duplicada removida - implementação única mantida nas linhas posteriores

# ===== ROTAS DE RESTAURANTES =====
@main_bp.route('/restaurantes')
@admin_required
def lista_restaurantes():
    """Lista restaurantes - VERSÃO SIMPLES E FUNCIONAL"""
    try:
        # Determinar admin_id
        admin_id = current_user.id if current_user.tipo_usuario == TipoUsuario.ADMIN else current_user.admin_id
        
        # Query direta
        restaurantes = Restaurante.query.filter_by(admin_id=admin_id).all()
        
        return render_template('restaurantes.html', restaurantes=restaurantes)
        
    except Exception as e:
        return render_template('error_debug.html',
                             error_title="Erro no Módulo de Restaurantes",
                             error_message=f"ERRO: {str(e)}",
                             solution="Verificar schema da tabela restaurante")

@main_bp.route('/restaurantes/novo', methods=['GET', 'POST'])
@admin_required
def novo_restaurante():
    if request.method == 'POST':
        try:
            nome = request.form.get('nome', '').strip()
            endereco = request.form.get('endereco', '').strip()
            telefone = request.form.get('telefone', '').strip()
            responsavel = request.form.get('responsavel', '').strip()
            preco_almoco = float(request.form.get('preco_almoco', 0))
            preco_jantar = float(request.form.get('preco_jantar', 0))
            preco_lanche = float(request.form.get('preco_lanche', 0))
            
            if not nome:
                flash('Nome é obrigatório.', 'danger')
                return redirect(url_for('main.novo_restaurante'))
            
            # Verificar duplicatas
            admin_id = current_user.id if current_user.tipo_usuario == TipoUsuario.ADMIN else current_user.admin_id
            existing = Restaurante.query.filter_by(nome=nome, admin_id=admin_id).first()
            
            if existing:
                flash(f'Já existe um restaurante com o nome "{nome}".', 'danger')
                return redirect(url_for('main.novo_restaurante'))
            
